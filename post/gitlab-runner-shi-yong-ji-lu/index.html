<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="starliu,istarboy,个人博客,运维,技术备忘录,docker,kubernetes,iot">
<meta name="description" content="一个技术爱好者的备忘录">
<meta name="theme-color" content="#000">
<title>Gitlab-runner使用记录 | Zone</title>
<link rel="shortcut icon" href="/favicon.ico?v=1680578767566">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/solarized-dark.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



  <meta name="description" content="Gitlab-runner使用记录" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Zone</span>
            </a>  
          
        </div>
        
          <p class="subtitle">一个技术狂热爱好者的备忘录</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://stardemo.github.io/post/toolbox/" target="_self">
                  <i class="fa fa-globe"></i> 工具箱
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">starliu</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">64</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://stardemo.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/starDemo">
              <i class="fa fa-github-alt" title="GitHub"></i>
            </a>
          
            <a href="mailto:starliu1995@hotmail.com">
              <i class="fa fa-envelope-o" title="E-Mail"></i>
            </a>
          
            <a href="https://weibo.com/u/3947157689?nick=%E5%93%9F%E5%93%9F%E5%93%9F%E5%93%9F%E6%88%91%E5%B0%B1%E6%98%AF%E4%BD%A0%E5%A4%A7%E7%88%B7">
              <i class="fa fa-weibo" title="微博"></i>
            </a>
          
        
        
          
            <a class="social-img" href="#">
              <img src="/media/images/custom-array-imgSocials-1597890751911-socialImg.png" />
              <i class="fa fa-wechat" title="WeChat" ></i>
            </a>
          
        
      </div>
    </div>
  


</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%9F%BA%E4%BA%8E%E7%8E%B0%E6%9C%89%E7%9A%84docker%E5%87%AD%E8%AF%81%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BAsecret">基于现有的Docker凭证文件创建Secret</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://stardemo.github.io/post/gitlab-runner-shi-yong-ji-lu/">
      Gitlab-runner使用记录
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-04-08</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>2分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>196<span class="pc-show">字数</span></span>
    </span>
    
    
    
    <span id="/post/gitlab-runner-shi-yong-ji-lu/" data-flag-title="Gitlab-runner使用记录" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span>浏览量：<span class="leancloud-visitors-count"></span></span>
    </span>
    
  </div>
</header>
            <div class="post-body next-md-body" id="post_body">
              <h2 id="基于现有的docker凭证文件创建secret">基于现有的Docker凭证文件创建Secret</h2>
<p><a href="https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/">refrence: kubernetes-pull image private registry </a></p>
<p>A Kubernetes cluster uses the Secret of <code>docker-registry</code> type to authenticate with a container registry to pull a private image.</p>
<p>If you already ran <code>docker login</code>, you can copy that credential into Kubernetes:</p>
<pre><code class="language-shell">kubectl create secret generic regcred \
    --from-file=.dockerconfigjson=&lt;path/to/.docker/config.json&gt; \
    --type=kubernetes.io/dockerconfigjson
</code></pre>
<p>If you need more control (for example, to set a namespace or a label on the new secret) then you can customise the Secret before storing it. Be sure to:</p>
<ul>
<li>set the name of the data item to <code>.dockerconfigjson</code></li>
<li>base64 encode the docker file and paste that string, unbroken as the value for field <code>data[&quot;.dockerconfigjson&quot;]</code></li>
<li>set type to <code>kubernetes.io/dockerconfigjson</code></li>
</ul>
<p>If you get the error message<br>
<code>error: no objects passed to create</code>, it may mean the base64 encoded string is invalid. If you get an error message like</p>
<pre><code>Secret &quot;myregistrykey&quot; is invalid: 
data[.dockerconfigjson]: invalid value ...
</code></pre>
<p>, it means the base64 encoded string in the data was successfully decoded, but could not be parsed as a <code>.docker/config.json</code> file.</p>

            </div>
            <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      starliu
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://stardemo.github.io/post/gitlab-runner-shi-yong-ji-lu/" title="Gitlab-runner使用记录">https://stardemo.github.io/post/gitlab-runner-shi-yong-ji-lu/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Prometheus使用记录" href="https://stardemo.github.io/post/prometheus-shi-yong-ji-lu/">Prometheus使用记录</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Prometheus使用记录" href="https://stardemo.github.io/post/prometheus-shi-yong-ji-lu/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="iCloud Drive同步文件时，忽略指定目录" href="https://stardemo.github.io/post/icloud-drive-tong-bu-wen-jian-shi-hu-lue-zhi-ding-mu-lu/">iCloud Drive同步文件时，忽略指定目录</a>
        <a class="nav-mobile-next" title="iCloud Drive同步文件时，忽略指定目录" href="https://stardemo.github.io/post/icloud-drive-tong-bu-wen-jian-shi-hu-lue-zhi-ding-mu-lu/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.16/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('https://upimage.alexhchu.com/2020/04/21/47eda59424daa.gif');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: 'ay3qCVyltjxGp0o1Y9kKwrhE-MdYXbMMI',
    appKey: '0nCU2IBpxP1EVCfO8jWtpOn2',
    avatar: '',
    placeholder: '留下你的评论吧～',
    pageSize: '',
    lang: 'zh-cn',
    visitor: 'true' === 'true',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'false',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
    
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;"
    data-key="39cf9ba739c44d7c99091777e82ea862">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'tororo'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'Aoba') {
				AIimgSrc.push(message_Path + "model/Aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'Aoba') {
							model = message_Path + "model/Aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/centos-76-310x-nei-he-xia-chuang-jian-memory-cgroup-shi-bai-yuan-yin-yu-jie-jue-fang-an/"" data-c="
          &lt;p&gt;原文:  &lt;a href=&#34;https://zhuanlan.zhihu.com/p/106757502&#34;&gt;https://zhuanlan.zhihu.com/p/106757502&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;
">CentOS 7.6 3.10.x 内核下创建 memory cgroup 失败原因与解决方案</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/kubectl-gen-ju-pod-zhuang-tai-jin-xing-pi-liang-shan-chu/"" data-c="
          &lt;!-- more --&gt;
&lt;p&gt;Cmd:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl get pods -A |grep ${podStatus} |awk &#39;{printf(&amp;quot;kubectl delete pods %s -n %s\n&amp;quot;, $2,$1)}&#39; | /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl get pods -A |grep UnexpectedAdmissionError |awk &#39;{printf(&amp;quot;kubectl delete pods %s -n %s\n&amp;quot;, $2,$1)}&#39; | /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要删除成功的作业:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl delete jobs --field-selector status.successful=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除失败或长时间运行的作业:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl delete jobs --field-selector status.successful=0
&lt;/code&gt;&lt;/pre&gt;
">kubectl根据Pod状态进行批量删除</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/ru-he-tong-guo-pid-ding-wei-shi-na-ge-rong-qi/"" data-c="
          &lt;p&gt;日常排查集群故障问题时会从宿主机上定位到进程PID但是需要定位到具体哪个容器的问题就步骤多了些 这边文章把方法总结一下&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ul&gt;
&lt;li&gt;首先定位容器目录&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;pwdx PID
# pwdx 681978
# 681978: /
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;具体查询思路&lt;br&gt;
通过&lt;code&gt;docker ps -q&lt;/code&gt;命令，获取所有的容器&lt;code&gt;id&lt;/code&gt;，再通过&lt;code&gt;xargs&lt;/code&gt;管道，将这些容器&lt;code&gt;id&lt;/code&gt;转交给&lt;code&gt;docker inspect&lt;/code&gt;命令进行处理，通过&lt;code&gt;-f &#39;{{.State.Pid}} {{.Config.Hostname}}&#39;&lt;/code&gt;参数，只打印出来容器当前的&lt;code&gt;pid&lt;/code&gt;和容器&lt;code&gt;id&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;docker ps -q | xargs docker inspect -f &#39;{{.State.Pid}} {{.Config.Hostname}}&#39; | grep PID
## 回显
# PID container_ID
## 查询容器
# docker ps | grep container_ID
&lt;/code&gt;&lt;/pre&gt;
">如何通过PID定位是哪个容器</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/tong-guo-unshare-tan-suo-linux-namespaces/"" data-c="
          &lt;p&gt;unshare [options] program [arguments]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;run program with some namespaces unshared from parent(使用与父程序不共享的名称空间运行程序)&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;unshare-命令描述&#34;&gt;unshare 命令描述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Unshares the indicated namespaces from the parent process and then executes the specified program. The namespaces to be unshared are indicated via options. &lt;/code&gt;&lt;br&gt;
Unshare取消共享父进程中指定的命名空间，然后执行指定的程序。要取消共享的命名空间通过选项来指示。不可共享的命名空间有&lt;/p&gt;
&lt;h2 id=&#34;支持设置的namespace&#34;&gt;支持设置的namespace&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;mount namespace&lt;/li&gt;
&lt;li&gt;UTS namespace&lt;/li&gt;
&lt;li&gt;IPC namespace&lt;/li&gt;
&lt;li&gt;network namespace&lt;/li&gt;
&lt;li&gt;pid namespace&lt;/li&gt;
&lt;li&gt;user namespace&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_34939308/article/details/114115443?spm=1001.2101.3001.6650.5&amp;amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5-114115443-blog-116682761.pc_relevant_multi_platform_whitelistv3&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5-114115443-blog-116682761.pc_relevant_multi_platform_whitelistv3&amp;amp;utm_relevant_index=7&#34;&gt;unshare命令详解及案例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/dream397/p/13996275.html&#34;&gt;cnblogs unshare介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_42525428/article/details/116682761&#34;&gt;linux unshare 命令,Linux ip netns 命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">通过unshare探索Linux namespaces</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/k8s-chang-yong-ingress-shi-yong-ji-qiao/"" data-c="
          &lt;ul&gt;
&lt;li&gt;Traefik&lt;/li&gt;
&lt;li&gt;Ingress Nginx&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;annotations&#34;&gt;Annotations&lt;/h2&gt;
&lt;p&gt;annotations作为k8s资源常见的一个声明配置方式 在Ingress资源对象里可以很方便的进行一些规则配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Traefik 1.7     &lt;a href=&#34;https://doc.traefik.io/traefik/v1.7/configuration/backends/kubernetes/#annotations&#34;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Traefik 2.0+    &lt;a href=&#34;https://doc.traefik.io/traefik/routing/providers/kubernetes-ingress/#annotations&#34;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Ingress Nginx     &lt;a href=&#34;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/&#34;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">K8s 常用 Ingress 使用技巧</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/estargz-de-yan-chi-la-qu/"" data-c="
          &lt;p&gt;根据&lt;a href=&#34;https://docs.rancher.cn/docs/k3s/advanced/_index#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E8%BF%9F%E6%8B%89%E5%8F%96%E5%92%8C-estargz%EF%BC%9F&#34;&gt; Rancehr文档-配置 k3s 进行 eStargz 的延迟拉取&lt;/a&gt;学习研究&lt;br&gt;
什么是延迟拉取和 eStargz？&lt;/p&gt;
&lt;!-- more --&gt;
"> eStargz 的延迟拉取</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/golang-zhong-de-fan-she-jie-xi-jie-gou-ti-biao-qian-tag/"" data-c="
          &lt;p&gt;项目中用到的一个需求，查询记录备忘&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main
 
import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;reflect&amp;quot;
)
 
type resume struct {
    // 反射解析结构体标签tag
    Name string `info:&amp;quot;name&amp;quot; doc:&amp;quot;我的名字&amp;quot;`
    Sex string `info:&amp;quot;sex&amp;quot;`
}
// 方法一：传递结构体对象
func findTag(stru interface{}) {
    t := reflect.TypeOf(stru)
    for i := 0; i &amp;lt; t.NumField(); i++ {
        fmt.Println(&amp;quot;info：&amp;quot;, t.Field(i).Tag.Get(&amp;quot;info&amp;quot;), &amp;quot;doc：&amp;quot;, t.Field(i).Tag.Get(&amp;quot;doc&amp;quot;))
    }
}
// 方法二：传递结构体指针
func findTag2(struc interface{}) {
    t := reflect.TypeOf(struc).Elem()
    for i := 0; i &amp;lt; t.NumField(); i++ {
        fmt.Printf(&amp;quot;info: %s, doc: %s\n&amp;quot;, t.Field(i).Tag.Get(&amp;quot;info&amp;quot;), t.Field(i).Tag.Get(&amp;quot;doc&amp;quot;))
    }
}
 
func main() {
    r := resume{Name: &amp;quot;mayanan&amp;quot;, Sex: &amp;quot;男&amp;quot;}
    // 方法一：传递结构体对象
    findTag(r)
    // 方法二：传递结构体指针
    findTag2(&amp;amp;r)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;出处: &lt;a href=&#34;https://www.cnblogs.com/mayanan/p/15484309.html&#34;&gt;https://www.cnblogs.com/mayanan/p/15484309.html&lt;/a&gt;&lt;/p&gt;
">golang中的反射解析结构体标签tag</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/mysql-insert-ignoreinsert-he-replace-qu-bie/"" data-c="
          &lt;!-- more --&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;指令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;已经存在&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;不存在&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;insert&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;报错&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;插入&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;insert into names(name, age) values(“小明”, 23);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;insert ignore&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;忽略&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;插入&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;insert ignore into names(name, age) values(“小明”, 24);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;replace&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;替换&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;插入&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;replace into names(name, age) values(“小明”, 25);&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;要求：表有PrimaryKey或者unique索引&lt;/li&gt;
&lt;li&gt;结果：表id都会自增&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;a href=&#34;https://blog.csdn.net/mouday/article/details/81281946&#34;&gt;学习转载自:https://blog.csdn.net/mouday/article/details/81281946&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
">MYSQL insert ignore、insert和replace区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/kubernetes-networkpolicy/"" data-c="
          &lt;p&gt;Kubernetes通过namespace支持了多租户，不同租户间可以通过ResourceQuota来保证资源的隔离，也无法查看其他namespace的Pod信息等。但默认kubernetes并不限制访问Pod的网络请求，对于一些敏感的应用来说可能不够用。&lt;/p&gt;
&lt;p&gt;Refer: &lt;a href=&#34;https://kubernetes.io/zh/docs/concepts/services-networking/network-policies/&#34;&gt;Offical Docs&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;前置条件&#34;&gt;前置条件&lt;/h2&gt;
&lt;p&gt;网络策略通过&lt;a href=&#34;https://kubernetes.io/zh/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/&#34;&gt;网络插件&lt;/a&gt; 来实现。要使用网络策略，你必须使用支持&lt;code&gt;NetworkPolicy&lt;/code&gt;的网络解决方案。 创建一个 &lt;code&gt;NetworkPolicy &lt;/code&gt;资源对象而没有控制器来使它生效的话，是没有任何作用的。&lt;/p&gt;
">Kubernetes NetworkPolicy</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/golang-protobuf-xue-xi-ji-lu/"" data-c="
          &lt;p&gt;使用Golang 实践protobuf&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;https://geektutu.com/post/quick-go-protobuf.html&lt;/p&gt;
">Golang Protobuf学习记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/percona-toolkit-shi-yong/"" data-c="
          &lt;h1 id=&#34;percona-toolkit使用&#34;&gt;Percona-toolkit使用&lt;/h1&gt;
&lt;h2 id=&#34;安装依赖&#34;&gt;安装&amp;amp;依赖&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install perl-DBI perl-DBD-MySQL perl-Time-HiRes perl-IO-Socket-SSL perl-Digest-MD5 perl-TermReadKey -y
# centos 7
wget https://www.percona.com/downloads/percona-toolkit/3.3.1/binary/redhat/7/x86_64/percona-toolkit-3.3.1-1.el7.x86_64.rpm
rpm -ivh percona-toolkit-3.0.13-1.el7.x86_64.rpm
# centos 6
# wget https://www.percona.com/downloads/percona-toolkit/3.3.1/binary/redhat/6/x86_64/percona-toolkit-3.3.1-1.el6.x86_64.rpm
# rpm -ivh percona-toolkit-3.0.13-1.el6.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;percona-toolkit-工作及作用&#34;&gt;Percona-toolkit 工作及作用&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;工具类别&lt;/th&gt;
&lt;th&gt;工具命令&lt;/th&gt;
&lt;th&gt;工具作用&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;开发类&lt;/td&gt;
&lt;td&gt;pt-duplicate-key-checker&lt;/td&gt;
&lt;td&gt;列出并删除重复的索引和外键&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-online-schema-change&lt;/td&gt;
&lt;td&gt;在线修改表结构&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-query-advisor&lt;/td&gt;
&lt;td&gt;分析查询语句，并给出建议，有bug&lt;/td&gt;
&lt;td&gt;已废弃&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-show-grants&lt;/td&gt;
&lt;td&gt;规范化和打印权限&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-upgrade&lt;/td&gt;
&lt;td&gt;在多个服务器上执行查询，并比较不同&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;性能类&lt;/td&gt;
&lt;td&gt;pt-index-usage&lt;/td&gt;
&lt;td&gt;分析日志中索引使用情况，并出报告&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-pmp&lt;/td&gt;
&lt;td&gt;为查询结果跟踪，并汇总跟踪结果&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-visual-explain&lt;/td&gt;
&lt;td&gt;格式化执行计划&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-table-usage&lt;/td&gt;
&lt;td&gt;分析日志中查询并分析表使用情况&lt;/td&gt;
&lt;td&gt;pt 2.2新增命令&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;配置类&lt;/td&gt;
&lt;td&gt;pt-config-diff&lt;/td&gt;
&lt;td&gt;比较配置文件和参数&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-mysql-summary&lt;/td&gt;
&lt;td&gt;对mysql配置和status进行汇总&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-variable-advisor&lt;/td&gt;
&lt;td&gt;分析参数，并提出建议&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;监控类&lt;/td&gt;
&lt;td&gt;pt-deadlock-logger&lt;/td&gt;
&lt;td&gt;提取和记录mysql死锁信息&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-fk-error-logger&lt;/td&gt;
&lt;td&gt;提取和记录外键信息&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-mext&lt;/td&gt;
&lt;td&gt;并行查看status样本信息&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-query-digest&lt;/td&gt;
&lt;td&gt;分析查询日志，并产生报告&lt;/td&gt;
&lt;td&gt;常用命令&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-trend&lt;/td&gt;
&lt;td&gt;按照时间段读取slow日志信息&lt;/td&gt;
&lt;td&gt;已废弃&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;复制类&lt;/td&gt;
&lt;td&gt;pt-heartbeat&lt;/td&gt;
&lt;td&gt;监控mysql复制延迟&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-slave-delay&lt;/td&gt;
&lt;td&gt;设定从落后主的时间&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-slave-find&lt;/td&gt;
&lt;td&gt;查找和打印所有mysql复制层级关系&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-slave-restart&lt;/td&gt;
&lt;td&gt;监控salve错误，并尝试重启salve&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-table-checksum&lt;/td&gt;
&lt;td&gt;校验主从复制一致性&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-table-sync&lt;/td&gt;
&lt;td&gt;高效同步表数据&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;系统类&lt;/td&gt;
&lt;td&gt;pt-diskstats&lt;/td&gt;
&lt;td&gt;查看系统磁盘状态&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-fifo-split&lt;/td&gt;
&lt;td&gt;模拟切割文件并输出&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-summary&lt;/td&gt;
&lt;td&gt;收集和显示系统概况&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-stalk&lt;/td&gt;
&lt;td&gt;出现问题时，收集诊断数据&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-sift&lt;/td&gt;
&lt;td&gt;浏览由pt-stalk创建的文件&lt;/td&gt;
&lt;td&gt;pt 2.2新增命令&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-ioprofile&lt;/td&gt;
&lt;td&gt;查询进程IO并打印一个IO活动表&lt;/td&gt;
&lt;td&gt;pt 2.2新增命令&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;实用类&lt;/td&gt;
&lt;td&gt;pt-archiver&lt;/td&gt;
&lt;td&gt;将表数据归档到另一个表或文件中&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-find&lt;/td&gt;
&lt;td&gt;查找表并执行命令&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-kill&lt;/td&gt;
&lt;td&gt;Kill掉符合条件的sql&lt;/td&gt;
&lt;td&gt;常用命令&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-align&lt;/td&gt;
&lt;td&gt;对齐其他工具的输出&lt;/td&gt;
&lt;td&gt;pt 2.2新增命令&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt-fingerprint&lt;/td&gt;
&lt;td&gt;将查询转成密文&lt;/td&gt;
&lt;td&gt;pt 2.2新增命令&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">Percona-toolkit使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/jing-xiang-la-qu-jia-su-fang-an-zong-jie/"" data-c="
          &lt;p&gt;日常遇到一些gcr/github的容器镜像由于网络原因拉取速度较慢，或者无法拉取下来，整理一些方案。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;使用阿里云加速k8sgcr的下载&#34;&gt;使用阿里云加速k8s.gcr的下载&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;registry.aliyuncs.com/google_containers/&lt;/code&gt;替换&lt;code&gt; k8s.gcr.io/sig-storage/&lt;/code&gt;即可&lt;/p&gt;
&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;
&lt;p&gt;拉取CSI相关组件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export IMAGE=csi-attacher:v3.2.1
docker pull registry.aliyuncs.com/google_containers/$IMAGE &amp;amp;&amp;amp; docker tag registry.aliyuncs.com/google_containers/$IMAGE  k8s.gcr.io/sig-storage/$IMAGE


export IMAGE=csi-provisioner:v2.1.2
docker pull registry.aliyuncs.com/google_containers/$IMAGE &amp;amp;&amp;amp; docker tag registry.aliyuncs.com/google_containers/$IMAGE  k8s.gcr.io/sig-storage/$IMAGE


export IMAGE=csi-resizer:v1.2.0
docker pull registry.aliyuncs.com/google_containers/$IMAGE &amp;amp;&amp;amp; docker tag registry.aliyuncs.com/google_containers/$IMAGE  k8s.gcr.io/sig-storage/$IMAGE

export IMAGE=csi-snapshotter:v3.0.3
docker pull registry.aliyuncs.com/google_containers/$IMAGE &amp;amp;&amp;amp; docker tag registry.aliyuncs.com/google_containers/$IMAGE  k8s.gcr.io/sig-storage/$IMAGE


export IMAGE=csi-node-driver-registrar:v2.3.0 
docker pull registry.aliyuncs.com/google_containers/$IMAGE &amp;amp;&amp;amp; docker tag registry.aliyuncs.com/google_containers/$IMAGE  k8s.gcr.io/sig-storage/$IMAGE
&lt;/code&gt;&lt;/pre&gt;
">镜像拉取加速方案总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/redisearch-shi-yong-ji-lu/"" data-c="
          &lt;p&gt;看到redisearch的特性，研究研究 ，对比下ES使用&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;附录&#34;&gt;附录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;官方文档 &lt;a href=&#34;https://oss.redislabs.com/redisearch/Commands/&#34;&gt;https://oss.redislabs.com/redisearch/Commands/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Redisearch 使用记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/nginx-ingress-shi-yong-shou-ce/"" data-c="
          &lt;!-- more --&gt;
&lt;p&gt;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#&lt;/p&gt;
">Nginx Ingress使用手册</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/a-li-yun-shi-yong-bei-wang/"" data-c="
          &lt;!-- more --&gt;
&lt;p&gt;https://help.aliyun.com/document_detail/86532.html?spm=5176.2020520112.help.dexternal.4e7934c0W010f5&lt;/p&gt;
">阿里云使用备忘</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/ji-lu-yi-ci-kubelet-cuo-wu-ri-zhi-pai-cha/"" data-c="
          &lt;p&gt;线上K8s集群的一个节点总报告kubelet不健康，使用journalctl 查看日志发现大量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Scope libcontainer-nnnnn has no PIDs. Refusing&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt; Orphaned pod found - but volume paths are still present on disk&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在此记录下问题的解决方案&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;问题1-scope-libcontainer-nnnnn-has-no-pids-refusing&#34;&gt;问题1. &lt;code&gt;Scope libcontainer-nnnnn has no PIDs. Refusing&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;使用journalctl查询&lt;code&gt; /var/log/messages&lt;/code&gt;处日志，有大量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Scope libcontainer-nnnnn has no PIDs. Refusing
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;问题原因&#34;&gt;问题原因&lt;/h3&gt;
&lt;h3 id=&#34;问题解法&#34;&gt;问题解法&lt;/h3&gt;
&lt;h3 id=&#34;参考出处&#34;&gt;参考出处&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/support/pages/recurring-messages-complain-scope-libcontainer-nnnnn-has-no-pids-refusing&#34;&gt;https://www.ibm.com/support/pages/recurring-messages-complain-scope-libcontainer-nnnnn-has-no-pids-refusing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;问题2-orphaned-pod-found-but-volume-paths-are-still-present-on-disk&#34;&gt;问题2. &lt;code&gt;Orphaned pod found - but volume paths are still present on disk&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;问题描述-2&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;使用journalctl查询&lt;code&gt; /var/log/messages&lt;/code&gt;处日志，有大量报错&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[kubelet_volumes.go:128] Orphaned pod &amp;quot;86d60ee9-9fae-11e8-8cfc-525400290b20&amp;quot; found, but volume paths are still present on disk. : There were a total of 100 errors similar to this.  Turn up verbosity to see them
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;问题原因-2&#34;&gt;问题原因&lt;/h3&gt;
&lt;p&gt;集群Pod停止删除了，数据文件未自动清理&lt;/p&gt;
&lt;h3 id=&#34;问题解法-2&#34;&gt;问题解法&lt;/h3&gt;
&lt;p&gt;删除&lt;code&gt;/var/lib/kubelet/pods&lt;/code&gt;对应日志ID的残留文件&lt;/p&gt;
&lt;h3 id=&#34;参考出处-2&#34;&gt;参考出处&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1385911&#34;&gt;https://cloud.tencent.com/developer/article/1385911&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">记录一次kubelet错误日志排查</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/study-makefile/"" data-c="
          &lt;p&gt;整理学习 -_-｜&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;makefile中phony的作用&#34;&gt;Makefile中.PHONY的作用&lt;/h2&gt;
&lt;p&gt;单词phony (即phoney)的意思是：伪造的，假的。来自collins的解释是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;If you describe something as phoney, you disapprove of it because it is false 
rather than genuine. 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么，在Makefile中，.PHONY后面的target表示的也是一个伪造的target, 而不是真实存在的文件target，注意Makefile的target默认是文件。&lt;/p&gt;
&lt;h3 id=&#34;举例&#34;&gt;举例:&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cat -n Makefile1
     1    clean:
     2        rm -f foo
$ cat -n Makefile2
     1    .PHONY: clean
     2    clean:
     3        rm -f foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Makefile1和Makefile2的差别就是在Makefile2中定义了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 .PHONY: clean
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接Make看看:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ls -l
total 8
-rw-r--r-- 1 huanli huanli 18 Jul 13 17:51 Makefile1
-rw-r--r-- 1 huanli huanli 32 Jul 13 17:51 Makefile2
$ make -f Makefile1 clean
rm -f foo
$ make -f Makefile2 clean
rm -f foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这么观察 Makefile1/Makefile2没什么区别&lt;/p&gt;
&lt;p&gt;再创建一个文件起名clean, 再make看看&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ touch clean
$ ls -l
total 8
-rw-r--r-- 1 huanli huanli  0 Jul 13 18:06 clean
-rw-r--r-- 1 huanli huanli 18 Jul 13 17:51 Makefile1
-rw-r--r-- 1 huanli huanli 32 Jul 13 17:51 Makefile2
$ make -f Makefile1 clean
make: &#39;clean&#39; is up to date.
$ make -f Makefile2 clean
rm -f foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区别来了，Makefile1拒绝了执行clean, 因为文件clean存在。而Makefile2却不理会文件clean的存在，总是执行clean后面的规则。由此可见，.PHONY clean发挥了作用。&lt;/p&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;.PHONY: clean
    o means the word &amp;quot;clean&amp;quot; doesn&#39;t represent a file name in this Makefile;
    o means the Makefile has nothing to do with a file called &amp;quot;clean&amp;quot; 
      in the same directory.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html&#34;&gt;Phony Targets of GNU Make&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/idorax/p/9306528.html&#34;&gt;Veli Cnblogs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Makefile学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/ji-lu-yi-ci-fu-wu-qi-ci-pan-rong-liang-bu-zu-de-qing-li-guo-cheng/"" data-c="
          &lt;p&gt;遇到了两个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/var/spool/postfix/maildrop &lt;/code&gt;产生大量文件&lt;/li&gt;
&lt;li&gt;目录中文件过多导致ls命令卡住&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;前因&#34;&gt;前因&lt;/h2&gt;
&lt;p&gt;收到服务器报警邮件，磁盘使用率超过百分之97，遂上线检查清理&lt;/p&gt;
&lt;h3 id=&#34;检查目录占用情况&#34;&gt;检查目录占用情况&lt;/h3&gt;
&lt;p&gt;笨办法，&lt;code&gt;du -sh *&lt;/code&gt; 查看目录/文件大小，发现卡在&lt;code&gt;var&lt;/code&gt;目录下，进入目录继续测试，发现最终卡在&lt;code&gt;/var/spool/postfix/maildrop &lt;/code&gt;下，进入目录，ls 发现ls卡死，需要kil 才能恢复，&lt;code&gt;ls -l |wc -l &lt;/code&gt;同样结果，遂开始研究问题。&lt;/p&gt;
&lt;h2 id=&#34;问题1-varspoolpostfixmaildrop-产生大量文件&#34;&gt;问题1.  &lt;code&gt;/var/spool/postfix/maildrop &lt;/code&gt;产生大量文件&lt;/h2&gt;
&lt;p&gt;crontab 每次执行任务后会发送邮件，接受者是在他的配置文件 “/etc/crontab” 通过 MAILTO=root’ 来设置的，默认是root。发送后的邮件就到&lt;code&gt;/var/spool/postfix/maildrop&lt;/code&gt;下了。&lt;/p&gt;
&lt;p&gt;如果需要邮件发送到指定邮箱，则需要配置此处。&lt;/p&gt;
&lt;p&gt;继续检查发现发现服务器上有很多crontab任务，因而判断发送太多邮件到maildrop下导致文件超多。&lt;/p&gt;
&lt;h3 id=&#34;解决方案&#34;&gt;解决方案&lt;/h3&gt;
&lt;h4 id=&#34;方案1&#34;&gt;方案1&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;修改“/etc/crontab”
将‘MAILTO=root’替换成‘MAILTO=&amp;quot;&amp;quot;’修改之后没有成功，需要重启crond服务才可以
也可从在crontab（crontab -e）中最前面直接加入MAILTO=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;方案2&#34;&gt;方案2&lt;/h4&gt;
&lt;p&gt;如果是我们不关心的备注型等输出我们完全可以让其输出到 &lt;code&gt;/dev/null&lt;/code&gt; 这样就不会因为发送失败到导致在&lt;code&gt;/var/spool/postfix/maildrop&lt;/code&gt;下面产出什么文件。&lt;br&gt;
如果需要收集输出log，可在&lt;code&gt;crontab job&lt;/code&gt;后增加&lt;code&gt;&amp;gt;&lt;/code&gt;定向输出&lt;br&gt;
例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 输出空
*/10 * * * * /tmp/test.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
# 定向输出到文件
*/10 * * * * /tmp/test.sh &amp;gt;/log/test.log 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;结果&#34;&gt;结果&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;方案1&lt;/code&gt;后重启crond服务，则不会产生新的文件。&lt;/p&gt;
&lt;h2 id=&#34;问题2-目录中文件过多导致ls命令卡住&#34;&gt;问题2. 目录中文件过多导致ls命令卡住&lt;/h2&gt;
&lt;h3 id=&#34;解决方案-2&#34;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;如果需要立马显示文件内容，则使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ls -1 -f 
# 删除文件
ls -1 -f | xargs rm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可立马显示文件。&lt;/p&gt;
&lt;h3 id=&#34;问题原因&#34;&gt;问题原因&lt;/h3&gt;
&lt;p&gt;(https://www.jianshu.com/p/353a5dbcd423)[https://www.jianshu.com/p/353a5dbcd423]&lt;/p&gt;
">记录一次服务器磁盘容量不足的清理过程</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/mian-jing-chang-jian-mian-shi-wen-da-zheng-li/"" data-c="
          &lt;p&gt;收集各路面试问答，做一个记录&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-网络基础&#34;&gt;1. 网络基础&lt;/h2&gt;
&lt;h3 id=&#34;11-问三次握手和四次挥手&#34;&gt;1.1 问：三次握手和四次挥手&lt;/h3&gt;
&lt;p&gt;为什么要进行三次握手：为了确认对方的发送和接收能力。&lt;/p&gt;
&lt;h4 id=&#34;三次握手&#34;&gt;三次握手&lt;/h4&gt;
&lt;p&gt;三次握手主要流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一开始双方处于 &lt;code&gt;CLOSED&lt;/code&gt;状态，然后服务端开始监听某个端口进入 &lt;code&gt;LISTEN&lt;/code&gt; 状态&lt;/li&gt;
&lt;li&gt;然后客户端主动发起连接，发送 &lt;code&gt;SYN&lt;/code&gt;，然后自己变为 &lt;code&gt;SYN-SENT&lt;/code&gt;，&lt;code&gt;seq = x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务端收到之后，返回 &lt;code&gt;SYN seq = y&lt;/code&gt; 和 &lt;code&gt;ACK ack = x + 1&lt;/code&gt;（对于客户端发来的 SYN），自己变成 &lt;code&gt;SYN-REVD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;之后客户端再次发送 &lt;code&gt;ACK seq = x + 1&lt;/code&gt;,&lt;code&gt; ack = y + 1&lt;/code&gt;给服务端，自己变成 &lt;code&gt;EASTABLISHED&lt;/code&gt; 状态，服务端收到 &lt;code&gt;ACK&lt;/code&gt;，也进入&lt;code&gt; ESTABLISHED&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;SYN 需要对端确认，所以 ACK 的序列化要加一，凡是需要对端确认的，一点要消耗 TCP 报文的序列化&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;为什么不是两次&#34;&gt;为什么不是两次？&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;无法确认客户端的接收能力。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果首先客户端发送了 SYN 报文，但是滞留在网络中，TCP 以为丢包了，然后重传，两次握手建立了连接。&lt;br&gt;
等到客户端关闭连接了。但是之后这个包如果到达了服务端，那么服务端接收到了，然后发送相应的数据表，就建立了链接，但是此时客户端已经关闭连接了，所以带来了链接资源的浪费。&lt;/p&gt;
&lt;h4 id=&#34;为什么不是四次&#34;&gt;为什么不是四次？&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;四次以上都可以，只不过 三次就够了&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;四次挥手&#34;&gt;四次挥手&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;一开始都处于 ESTABLISH 状态，然后客户端发送 FIN 报文，带上 seq = p，状态变为 FIN-WAIT-1&lt;/li&gt;
&lt;li&gt;服务端收到之后，发送 ACK 确认，ack = p + 1，然后进入 CLOSE-WAIT 状态&lt;/li&gt;
&lt;li&gt;客户端收到之后进入 FIN-WAIT-2  状态&lt;/li&gt;
&lt;li&gt;过了一会等数据处理完，再次发送 FIN、ACK，seq = q，ack = p + 1，进入 LAST-ACK 阶段&lt;/li&gt;
&lt;li&gt;客户端收到 FIN 之后，客户端收到之后进入 TIME_WAIT（等待 2MSL），然后发送 ACK 给服务端 ack = 1 + 1&lt;/li&gt;
&lt;li&gt;服务端收到之后进入 CLOSED 状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端这个时候还需要等待两次 MSL 之后，如果没有收到服务端的重发请求，就表明 ACK 成功到达，挥手结束，客户端变为 CLOSED 状态，否则进行 ACK 重发&lt;/p&gt;
&lt;h4 id=&#34;为什么需要等待-2mslmaximum-segement-lifetime&#34;&gt;为什么需要等待 2MSL（Maximum Segement Lifetime）：&lt;/h4&gt;
&lt;p&gt;因为如果不等待的话，如果服务端还有很多数据包要给客户端发，且此时客户端端口被新应用占据，那么就会接收到无用的数据包，造成数据包混乱，所以说最保险的方法就是等服务器发来的数据包都死翘翘了再启动新应用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1个 MSL 保证四次挥手中主动关闭方最后的 ACK 报文能最终到达对端&lt;/li&gt;
&lt;li&gt;1个 MSL 保证对端没有收到 ACK 那么进行重传的 FIN 报文能够到达&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;为什么是四次而不是三次&#34;&gt;为什么是四次而不是三次？&lt;/h4&gt;
&lt;p&gt;如果是三次的话，那么服务端的 ACK 和 FIN 合成一个挥手，那么长时间的延迟可能让 TCP 一位 FIN 没有达到服务器端，然后让客户的不断的重发 FIN&lt;/p&gt;
&lt;h4 id=&#34;参考资料&#34;&gt;参考资料&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/86426969&#34;&gt;https://zhuanlan.zhihu.com/p/86426969&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6844904070889603085&#34;&gt;https://juejin.cn/post/6844904070889603085&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;n-转载源&#34;&gt;n. 转载源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6939691851746279437&#34;&gt;juejin-图雀社区-字节跳动最爱考的前端面试题：计算机网络基础&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">[面经] 常见面试问答整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/macos-xia-shi-yong-nvm-guan-li-node-huan-jing/"" data-c="
          &lt;p&gt;node版本变化有些快，需要切换不同版本构建项目，使用nvm管理node是一个比较成熟的方案。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-安装nvm&#34;&gt;1. 安装nvm&lt;/h2&gt;
&lt;h3 id=&#34;11-macos&#34;&gt;1.1 MacOS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;brew安装&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew install nvm 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;官方脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-linux&#34;&gt;1.2 Linux&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-安装注意事项&#34;&gt;1.3 安装注意事项&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;==&amp;gt; Caveats
Please note that upstream has asked us to make explicit managing
nvm via Homebrew is unsupported by them and you should check any
problems against the standard nvm install method prior to reporting.

You should create NVM&#39;s working directory if it doesn&#39;t exist:

  mkdir ~/.nvm

Add the following to ~/.zshrc or your desired shell
configuration file:

  export NVM_DIR=&amp;quot;$HOME/.nvm&amp;quot;
  [ -s &amp;quot;/opt/homebrew/opt/nvm/nvm.sh&amp;quot; ] &amp;amp;&amp;amp; . &amp;quot;/opt/homebrew/opt/nvm/nvm.sh&amp;quot;  # This loads nvm
  [ -s &amp;quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&amp;quot; ] &amp;amp;&amp;amp; . &amp;quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&amp;quot;  # This loads nvm bash_completion

You can set $NVM_DIR to any location, but leaving it unchanged from
/opt/homebrew/opt/nvm will destroy any nvm-installed Node installations
upon upgrade/reinstall.

Type `nvm help` for further information.

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;创建nvm目录&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir ~/.nvm
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;处理&lt;code&gt;~/.zshrc&lt;/code&gt;或者&lt;code&gt;~/.bashrc&lt;/code&gt;（此处zsh举例）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;  export NVM_DIR=&amp;quot;$HOME/.nvm&amp;quot;
  [ -s &amp;quot;/opt/homebrew/opt/nvm/nvm.sh&amp;quot; ] &amp;amp;&amp;amp; . &amp;quot;/opt/homebrew/opt/nvm/nvm.sh&amp;quot;  # This loads nvm
  [ -s &amp;quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&amp;quot; ] &amp;amp;&amp;amp; . &amp;quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&amp;quot;  # This loads nvm bash_completion
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-nvm使用说明&#34;&gt;1.4 nvm使用说明&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 显示服务器端版本列表
nvm ls-remote
# 安装指定版本
nvm install vXX.XX.XX
# 设置默认的版本
nvm alias default vXX.XX.XX
# 显示本地下载的版本列表
nvm list
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-配置镜像加速&#34;&gt;2. 配置镜像加速&lt;/h2&gt;
&lt;h3 id=&#34;21-nvm加速&#34;&gt;2.1 nvm加速&lt;/h3&gt;
&lt;p&gt;需要设置环境变量&lt;code&gt;NVM_NODEJS_ORG_MIRROR&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 临时设置
export NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node
# 配置上述命令到bashrc/zshrc中保持生效
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-npm加速&#34;&gt;2.2 npm加速&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看当前registry
npm config -g get registry
# 设置registry
npm config -g set registry https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-yarn配置&#34;&gt;2.3 yarn配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 安装yarn
npm install -g yarn
# 查看yarn registry
yarn config get registry
# 设置yarn registry
yarn config set registry http://registry.npm.taobao.org/
&lt;/code&gt;&lt;/pre&gt;
">MacOS 下使用nvm管理node环境</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/git-httpssh-dai-li-pei-zhi/"" data-c="
          &lt;p&gt;github访问日益困难,配置git服务代理以快速clone代码🐶&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;技术方案转载于&lt;a href=&#34;http://www.chenhe.cc/p/406&#34;&gt;http://www.chenhe.cc/p/406&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;http-代理&#34;&gt;HTTP 代理&lt;/h2&gt;
&lt;h3 id=&#34;配置全局代理&#34;&gt;配置全局代理&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# HTTP 代理
git config --global http.proxy http://127.0.0.1:7890
git config --global https.proxy http://127.0.0.1:7890

# Socks5 代理
git config --global http.proxy socks5://127.0.0.1:7890
git config --global https.proxy socks5://127.0.0.1:7890
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里的&lt;code&gt;socks5&lt;/code&gt;仅仅是代理使用的协议，它依然是针对 http 设置的，所以仅对 http 协议的仓库有效。使用 &lt;code&gt;git@xxx &lt;/code&gt;这种 ssh 连接的不会使用代理。&lt;/p&gt;
&lt;h3 id=&#34;分域名设置代理&#34;&gt;分域名设置代理&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global http.https://github.com.proxy http://127.0.0.1:7890
git config --global https.https://github.com.proxy https://127.0.0.1:7890
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ssh-代理&#34;&gt;SSH 代理&lt;/h2&gt;
&lt;p&gt;SSH 代理需要在密钥目录 (&lt;code&gt;~/.ssh&lt;/code&gt;) (Windows 下是 &lt;code&gt;C:\Users\{UserName}\.ssh&lt;/code&gt;) 新建一个 config 文件，没有后缀名。&lt;/p&gt;
&lt;h3 id=&#34;linuxmacos-系统写入以下配置&#34;&gt;Linux/MacOS 系统写入以下配置：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 需要 netcat
Host github.com
  User git
  Port 22
  Hostname github.com
  TCPKeepAlive yes
  ProxyCommand nc -v -x 127.0.0.1:1080 %h %p
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;windows系统配置&#34;&gt;Windows系统配置&lt;/h3&gt;
&lt;p&gt;需要额外安装&lt;code&gt;connect.exe&lt;/code&gt;程序,如果找不到 connect 命令那么指定其绝对路径，一般在 git 安装目录下 \mingw64\bin\connect.exe。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Host github.com
  User git
  Port 22
  Hostname github.com
  TCPKeepAlive yes
  # -S 为 socks, -H 为 HTTP
  ProxyCommand connect -S 127.0.0.1:1080 %h %p
&lt;/code&gt;&lt;/pre&gt;
">Git HTTP+SSH 代理配置</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/linux-xia-shi-yong-curl-cha-kan-http-qing-qiu-ge-jie-duan-hao-shi/"" data-c="
          &lt;p&gt;HTTP接口在业务中速度较慢，使用curl进行排查&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-准备文件模版curltxt&#34;&gt;1. 准备文件模版（curl.txt）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;\n
            time_namelookup:  %{time_namelookup}\n
               time_connect:  %{time_connect}\n
            time_appconnect:  %{time_appconnect}\n
           time_pretransfer:  %{time_pretransfer}\n
              time_redirect:  %{time_redirect}\n
         time_starttransfer:  %{time_starttransfer}\n
                            ----------\n
                 time_total:  %{time_total}\n
\n
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-使用curl带以下参数请求&#34;&gt;2. 使用curl带以下参数请求&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -w &amp;quot;@curl.txt&amp;quot; -o /dev/null -s https://api.example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[@ ~]# curl -w &amp;quot;@curl&amp;quot; -o /dev/null -s https://api.example.com

            time_namelookup:  0.004
               time_connect:  0.014
            time_appconnect:  0.141
           time_pretransfer:  0.141
              time_redirect:  0.000
         time_starttransfer:  0.153
                            ----------
                 time_total:  0.165
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-参数说明&#34;&gt;3. 参数说明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;NAMELOOKUP：从开始计算，域名解析完成的耗时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CURLINFO_NAMELOOKUP_TIME. The time it took from the start until the name resolving was completed.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CONNECT：从开始计算，TCP建立完成的耗时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CURLINFO_CONNECT_TIME. The time it took from the start until the connect to the remote host (or proxy) was completed.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;APPCONNECT：从开始计算，应用层（SSL，在TCP之上的应用层）连接/握手完成的耗时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CURLINFO_APPCONNECT_TIME. The time it took from the start until the SSL connect/handshake with the remote host was completed. (Added in in 7.19.0)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PRETRANSFER：从开始计算，准备开始传输数据的耗时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CURLINFO_PRETRANSFER_TIME. The time it took from the start until the file transfer is just about to begin. This includes all pre-transfer commands and negotiations that are specific to the particular protocol(s) involved.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STARTTRANSFER：从开始计算，开始传输数据的耗时（libcurl接收到第一个字节）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CURLINFO_STARTTRANSFER_TIME. The time it took from the start until the first byte is received by libcurl.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TOTAL：总的耗时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CURLINFO_TOTAL_TIME. Total time of the previous request.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;REDIRECT：整个过程重定向的耗时，如果整个过程没有重定向，这个时间为0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;文章来源于互联网,原地址&lt;a href=&#34;https://www.cnblogs.com/lnlvinso/p/9775484.html&#34;&gt;https://www.cnblogs.com/lnlvinso/p/9775484.html&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
">Linux下使用curl查看http请求各阶段耗时</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/zai-macos-xia-qi-yong-cgo_enabled-de-jiao-cha-bian-yi/"" data-c="
          &lt;p&gt;go 启用CGO_ENABLED遇到报错的解决方案&lt;br&gt;
&lt;code&gt;gcc_libinit_windows.c:7:10: fatal error: &#39;windows.h&#39; file not found&lt;/code&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;在macos下启用cgo_enabled的交叉编译&#34;&gt;在macOS下启用CGO_ENABLED的交叉编译&lt;/h2&gt;
&lt;p&gt;在启用CGO_ENABLED的情况下，尝试使用下面命令进行Windows平台的交叉编译：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ CGO_ENABLED=1 GOOS=windows GOARCH=386 go build -x -v -ldflags &amp;quot;-s -w&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;出现错误如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# runtime/cgo
gcc_libinit_windows.c:7:10: fatal error: &#39;windows.h&#39; file not found
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装mingw-w64&#34;&gt;安装mingw-w64&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ brew install mingw-w64
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/isl-0.22.1.big_sur.bottle.tar.gz
==&amp;gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/15376fb7aff7adec3786e6a31ec9b5cad585fd01ecbd5c4744ef9461b10965ff?response-content-disposition=attachment%3Bfilename%3D%22isl-0.22.1.big_sur.bottle.tar.gz%22&amp;amp;Policy=eyJTdGF0Z
######################################################################## 100.0%
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/mpfr-4.1.0.big_sur.bottle.tar.gz
==&amp;gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/1e8eb0326f62d3461d420d98af6fc088daca481cae89fd77a75b420d2e76d776?response-content-disposition=attachment%3Bfilename%3D%22mpfr-4.1.0.big_sur.bottle.tar.gz%22&amp;amp;Policy=eyJTdGF0Z
######################################################################## 100.0%
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/libmpc-1.2.1.big_sur.bottle.tar.gz
######################################################################## 100.0%
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/mingw-w64-8.0.0.catalina.bottle.tar.gz
==&amp;gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/d294bc0e960294bf573b9da364a8d95a06a257aec8f388c16e2b975ed8e4410c?response-content-disposition=attachment%3Bfilename%3D%22mingw-w64-8.0.0.catalina.bottle.tar.gz%22&amp;amp;Policy=eyJ
######################################################################## 100.0%
==&amp;gt; Installing dependencies for mingw-w64: isl, mpfr and libmpc
==&amp;gt; Installing mingw-w64 dependency: isl
==&amp;gt; Pouring isl-0.22.1.big_sur.bottle.tar.gz
🍺  /usr/local/Cellar/isl/0.22.1: 72 files, 4.9MB
==&amp;gt; Installing mingw-w64 dependency: mpfr
==&amp;gt; Pouring mpfr-4.1.0.big_sur.bottle.tar.gz
🍺  /usr/local/Cellar/mpfr/4.1.0: 30 files, 5.2MB
==&amp;gt; Installing mingw-w64 dependency: libmpc
==&amp;gt; Pouring libmpc-1.2.1.big_sur.bottle.tar.gz
🍺  /usr/local/Cellar/libmpc/1.2.1: 13 files, 425.0KB
==&amp;gt; Installing mingw-w64
==&amp;gt; Pouring mingw-w64-8.0.0.catalina.bottle.tar.gz
🍺  /usr/local/Cellar/mingw-w64/8.0.0: 7,402 files, 854.6MB
$ which x86_64-w64-mingw32-gcc
/usr/local/bin/x86_64-w64-mingw32-gcc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;编译x64&#34;&gt;编译x64&lt;/h2&gt;
&lt;h3 id=&#34;可执行文件&#34;&gt;可执行文件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ GOOS=windows GOARCH=amd64 go build -x -v -ldflags &amp;quot;-s -w&amp;quot; -o app.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;静态库&#34;&gt;静态库&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ GOOS=windows GOARCH=amd64 go build -buildmode=c-archive -x -v -ldflags &amp;quot;-s -w&amp;quot; -o bin app.go
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;动态库&#34;&gt;动态库&lt;/h3&gt;
&lt;p&gt;将&lt;code&gt;-buildmode=c-archive&lt;/code&gt;改为&lt;code&gt;-buildmode=c-shared&lt;/code&gt;即可&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;转载资料 出处:&lt;a href=&#34;https://www.dllhook.com/post/244.html&#34;&gt;https://www.dllhook.com/post/244.html&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
">在macOS下启用CGO_ENABLED的交叉编译</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/kubernetes-bao-lu-xin-xi-gei-pod/"" data-c="
          &lt;h3 id=&#34;capabilities-of-the-downward-api&#34;&gt;Capabilities of the Downward API&lt;/h3&gt;
&lt;h4 id=&#34;feildref即可以暴露的pod定义中的项目&#34;&gt;feildRef，即可以暴露的pod定义中的项目：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;spec.nodeName - the node’s name
status.hostIP - the node’s IP
metadata.name - the pod’s name
metadata.namespace - the pod’s namespace
status.podIP - the pod’s IP address
spec.serviceAccountName - the pod’s service account name
metadata.uid - the pod’s UID
metadata.labels[&#39;&amp;lt;KEY&amp;gt;&#39;] - the value of the pod’s label &amp;lt;KEY&amp;gt; (for example, metadata.labels[&#39;mylabel&#39;]); available in Kubernetes 1.9+
metadata.annotations[&#39;&amp;lt;KEY&amp;gt;&#39;] - the value of the pod’s annotation &amp;lt;KEY&amp;gt; (for example, metadata.annotations[&#39;myannotation&#39;]); available in Kubernetes 1.9+
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;resourcefieldref即可以暴露的container定义中的项目&#34;&gt;resourceFieldRef，即可以暴露的container定义中的项目：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;A Container’s CPU limit&lt;/li&gt;
&lt;li&gt;A Container’s CPU request&lt;/li&gt;
&lt;li&gt;A Container’s memory limit&lt;/li&gt;
&lt;li&gt;A Container’s memory request&lt;/li&gt;
&lt;/ul&gt;
">Kubernetes暴露信息给Pod</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/ldap-shi-yong-ji-lu/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;rancher访问ldap的默认规则&#34;&gt;Rancher访问LDAP的默认规则&lt;/h2&gt;
&lt;h3 id=&#34;用户&#34;&gt;用户&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;搜索起点: ou=Users,dc=thecover,dc=cn
对象分类: inetOrgPerson
登录字段: uid
名称字段: cn
搜索字段: uid|sn|givenName
启用字段:
禁用位掩码: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;用户组&#34;&gt;用户组&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;搜索起点: ou=Groups,dc=thecover,dc=cn
对象分类: groupOfNames
名称字段: cn
搜索字段: cn
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建只读用户&#34;&gt;创建只读用户&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;创建用户（可以用管理工具创建同objectClass的用户）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#密码
LDAP_READONLY_USER_PW=&#39;密码&#39;
#Base DN
LDAP_BASE_DN=&#39;dc=thecover,dc=cn&#39;
cat &amp;lt;&amp;lt;EOF &amp;gt; ./readOnly.ldif
dn: cn=readonly,${LDAP_BASE_DN}
cn: readonly
objectClass: simpleSecurityObject
objectClass: organizationalRole
description: LDAP read only user
userPassword: ${LDAP_READONLY_USER_PW}
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令行增加用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ldapadd -x -D cn=Manager,dc=okcoin,dc=com -w &#39;密码&#39; -f ./readOnly.ldif
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;配置权限&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;LDAP_BASE_DN=&#39;dc=thecover,dc=cn&#39;
cat &amp;lt;&amp;lt;EOF &amp;gt; readonly-user-acl.ldif
dn: olcDatabase={1}hdb,cn=config
changetype: modify
delete: olcAccess
-
add: olcAccess
olcAccess: {0}to attrs=userPassword,shadowLastChange 
 by dn=&amp;quot;cn=admin,dc=thecover,dc=cn&amp;quot; write 
 by anonymous auth 
 by self write 
 by dn=&amp;quot;cn=readonly,dc=thecover,dc=cn&amp;quot; read 
 by * none
olcAccess: {1}to dn.base=&amp;quot;&amp;quot; by * read
olcAccess: {2}to * by dn=&amp;quot;cn=Manager,dc=thecover,dc=cn&amp;quot; write by * read
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ldapmodify -Y EXTERNAL -H ldapi:/// -f readonly-user-acl.ldif
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;备注&lt;br&gt;
配置权限时需要使用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;slapcat -b cn=config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定位&lt;code&gt;olcDatabase&lt;/code&gt; &lt;code&gt;config&lt;/code&gt;的位置&lt;/p&gt;
&lt;h2 id=&#34;ldap增加memberof属性&#34;&gt;Ldap增加memberOf属性&lt;/h2&gt;
&lt;p&gt;https://www.linuxprobe.com/enable-memberof-openldap.html&lt;br&gt;
https://kifarunix.com/how-to-create-openldap-member-groups/&lt;/p&gt;
&lt;h2 id=&#34;配置缓存&#34;&gt;配置缓存&lt;/h2&gt;
&lt;h3 id=&#34;查询缓存配置&#34;&gt;查询缓存配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ldapsearch -Q -LLL -Y EXTERNAL -H ldapi:/// -b cn=config &#39;olcDatabase={0}mdb&#39; olcDbindex
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除旧配置&#34;&gt;删除旧配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;&amp;gt; del-1mdb-index.ldif &amp;lt;&amp;lt; EOF
dn: olcDatabase={1}mdb, cn=config
changetype:modify
delete: olcDbIndex
olcDbIndex: uid eq
EOF
 ldapmodify -Q -Y EXTERNAL -H ldapi:/// -f del-1mdb-index.ldif
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;新增配置&#34;&gt;新增配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;&amp;gt; mdb-index.ldif &amp;lt;&amp;lt; EOF
dn: olcDatabase={1}mdb, cn=config
changetype:modify
add:olcDbIndex
olcDbIndex: uid pres,eq,sub
EOF
ldapmodify -Q -Y EXTERNAL -H ldapi:/// -f mdb-index.ldif
&lt;/code&gt;&lt;/pre&gt;
">LDAP使用记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/a-li-yun-k8s-zui-jia-shi-jian-bi-ji/"" data-c="
          &lt;p&gt;记录使用阿里云ACK容器服务以及阿里云的各服务的总结笔记&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-配置阿里云slb到集群的ingress&#34;&gt;1. 配置阿里云SLB到集群的Ingress&lt;/h2&gt;
&lt;h3 id=&#34;11-同时使用私网slb与公网slb配合&#34;&gt;1.1 同时使用私网SLB与公网SLB配合&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;对于一些特殊场景，您期望容器集群内的服务既能允许公网访问，同时又希望能被同一个VPC下的其他服务直接访问（不经过公网）。您只需额外部署一个kube-system/nginx-ingress-lb-intranet服务。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;使用阿里云创建的容器集群默认已经创建了一个绑定到公网的SLB，位于&lt;code&gt;kube-system&lt;/code&gt;下。创建一个符合期望配置的内网SLB实例，新增一个Service描述，使集群自动绑定监听到SLB。&lt;/p&gt;
&lt;p&gt;配置模版&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# intranet nginx ingress slb service
apiVersion: v1
kind: Service
metadata:
 # 这里服务取名为nginx-ingress-lb-intranet
 name: nginx-ingress-lb-intranet
 namespace: kube-system
 labels:
   app: nginx-ingress-lb-intranet
 annotations:
   # 指明SLB实例地址类型为私网类型
   service.beta.kubernetes.io/alicloud-loadbalancer-address-type: intranet
   # 修改为您的私网SLB实例ID
   service.beta.kubernetes.io/alicloud-loadbalancer-id: &amp;lt;YOUR_INTRANET_SLB_ID&amp;gt;
   # 是否自动创建SLB端口监听（会覆写已有端口监听），也可手动创建端口监听
   service.beta.kubernetes.io/alicloud-loadbalancer-force-override-listeners: &#39;true&#39;
spec:
 type: LoadBalancer
 # route traffic to other nodes
 externalTrafficPolicy: &amp;quot;Cluster&amp;quot;
 ports:
 - port: 80
   name: http
   targetPort: 80
 - port: 443
   name: https
   targetPort: 443
 selector:
   # select app=ingress-nginx pods
   app: ingress-nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建服务之后通过如下命令,查看svc状态&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; kubectl -n kube-system get svc | grep nginx-ingress-lb
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-coredns的特殊用法&#34;&gt;2. CoreDNS的特殊用法&lt;/h2&gt;
&lt;h3 id=&#34;21-coredns拦截域名解析&#34;&gt;2.1 CoreDNS拦截域名解析&lt;/h3&gt;
&lt;p&gt;在内网多个集群的场景下，有些域名需要解析到内网避免出现公网流量，之前处理方案有如下几种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在VPC内网内自建一个DNS服务器，将所有服务器的DNS指向自建的DNS服务器
&lt;ul&gt;
&lt;li&gt;问题: 需要考虑到DNS的高可用以及故障容灾难&lt;/li&gt;
&lt;li&gt;优势: 集中化,便于统一维护管理更新&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在主机配置Hosts文件
&lt;ul&gt;
&lt;li&gt;问题: 主机较多，维护成本上涨&lt;/li&gt;
&lt;li&gt;优势: 操作简单，技术成本较低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;K8s容器集群内CoreDNS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubernetes本身具有集群DNS组件，此处使用的为CoreDNS，工作负载的DNS默认策略为&lt;code&gt;ClusterFirst&lt;/code&gt;,此时Pods内程序解析DNS会优先查询集群的DNS组件，所以此时可以在集群DNS层面进行解析拦截覆盖。&lt;/p&gt;
&lt;p&gt;CoreDNS的配置使用的ConfigMap,而ConfigMap支持热更新,修改ConfigMap后CoreDNS自动生效。配置如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.:5353 {
cache 30
errors
health
kubernetes cluster.local in-addr.arpa ip6.arpa {
pods insecure
upstream /etc/resolv.conf
fallthrough in-addr.arpa ip6.arpa
}
loadbalance round_robin
hosts {
122.212.222.111 aaa.bbb.com
fallthrough
}
prometheus 0.0.0.0:9153
proxy . /etc/resolv.conf
reload
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把需要的DNS规格写入Hosts节点下，即可进行集群层面的解析配置。&lt;/p&gt;
">阿里云K8s实践笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/shi-yong-nc-jian-ce-tcpudp-duan-kou-kai-fang/"" data-c="
          &lt;h1 id=&#34;telnet-检测tcp端口&#34;&gt;Telnet 检测TCP端口&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@localhost ~]# telnet 127.0.0.1 8080
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is &#39;^]&#39;.
^CConnection closed by foreign host.
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;nc-检测tcp端口&#34;&gt;NC 检测TCP端口&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@localhost ~]# nc -vz 127.0.0.1 8906
Connection to 127.0.0.1 8906 port [tcp/*] succeeded!
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;nc-检测udp端口&#34;&gt;NC 检测UDP端口&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;检测udp端口的时候不会立即返回测试结果，可能需要等待几秒钟&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@apexsoft ~]# nc -uz 127.0.0.1 8907
Connection to 127.0.0.1 8907 port [udp/*] succeeded!
&lt;/code&gt;&lt;/pre&gt;
">使用nc检测TCP/UDP端口开放</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/nginx-gen-ju-ua-guo-lu-qing-qiu/"" data-c="
          &lt;p&gt;有需求一个系统只允许微信和钉钉访问，所以配置Nginx规则过滤UA&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;配置文件&#34;&gt;配置文件&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
    listen       80;
    server_name  localhost;
    set $flag 0;
    if ($http_user_agent !~ &amp;quot;MicroMessenger&amp;quot; ){
        set $flag &amp;quot;${flag}1&amp;quot;;
    }
    if ( $http_user_agent !~ &amp;quot;DingTalk&amp;quot; ){
        set $flag &amp;quot;${flag}2&amp;quot;;
    }
    if ($flag = &amp;quot;012&amp;quot;) {
        return 403;
    }
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }
    #error_page  404              /404.html;
    # redirect server error pages to the static page /50x.html
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;踩过的坑&#34;&gt;踩过的坑&lt;/h1&gt;
&lt;h2 id=&#34;一-nginx多条件判断&#34;&gt;一. Nginx多条件判断&lt;/h2&gt;
&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;nginx的配置中不支持if条件的逻辑与、逻辑或运算 ，并且不支持if的嵌套语法&lt;/em&gt;*&lt;/p&gt;
&lt;h2 id=&#34;解法&#34;&gt;解法&lt;/h2&gt;
&lt;p&gt;定义变量,判断变量状态。&lt;/p&gt;
">Nginx根据UA过滤请求</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/reactreact-shi-zhan-1-ant-design-pro-xiang-mu-history-mo-shi-xia-xiang-guan-pei-zhi/"" data-c="
          &lt;h1 id=&#34;相关链接&#34;&gt;相关链接&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://pro.ant.design/docs/deploy-cn&#34;&gt;AntDesign文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;nginx-配置文件修改&#34;&gt;Nginx 配置文件修改&lt;/h1&gt;
&lt;h2 id=&#34;完整配置&#34;&gt;完整配置&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
    listen       80;
    server_name  localhost;
    location / { 
    proxy_pass http://localhost:8000;
    }
  location /active {
      try_files $uri $uri/ /healthy/index.html;
  }

  location /healthy/api {
       proxy_pass   http://localhost:8888/;
  }
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8000端口下nginx配置&#34;&gt;8000端口下nginx配置&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
    listen  8000;
    server_name   localhost;
    location / {
        root   /usr/project/;
        try_files $uri $uri/ /index.html;  #配合react项目的history模式去除#时用到
        index index.html;
        client_max_body_size    8m;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;配置文件说明&#34;&gt;配置文件说明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用try_files方式的前提是服务器安装nginx的时候需要安装相应的模块，我是通过yarn源的方式安装的，包含了所有模块，所以可以直接使用&lt;/li&gt;
&lt;li&gt;80端口下根目录会指向8000端口（习惯把项目都放在8000端口下指向的project目录下），同时添加/active访问拦截指向healthy目录下index.html，同时添加/healthy/api是为了拦截接口访问&lt;/li&gt;
&lt;li&gt;8000端口下root指向的是/usr/project/，此目录放置所有前端项目文件夹，一些node服务端项目也可以放进去&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ant-design-pro项目中相关配置&#34;&gt;Ant Design Pro项目中相关配置&lt;/h1&gt;
&lt;h2 id=&#34;修改config文件&#34;&gt;修改config文件&lt;/h2&gt;
&lt;p&gt;项目目录下config/config.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export default {
  plugins,
  proxy,
  block: {
    defaultGitUrl: &#39;https://github.com/ant-design/pro-blocks&#39;,
  },
  hash: false, // browser 模式下为false, hash 模式下为true
  history: &#39;browser&#39;, // 默认是 browser ， hash
  base: &#39;/healthy/&#39;, // browser 模式下为 /healthy/ ， hash模式下为 /
  publicPath: &#39;/healthy/&#39;, // 模式下为 /healthy/ ， hash模式下为 ./
  targets: {
    ie: 11,
  },
  devtool: isAntDesignProPreview ? &#39;source-map&#39; : false,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;引用外部文件&#34;&gt;引用外部文件&lt;/h2&gt;
&lt;p&gt;pages/document.ejs中引用的外部文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link rel=&amp;quot;shortcut icon&amp;quot; href=&amp;quot;./favicon.ico&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;接口调用配置&#34;&gt;接口调用配置&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// config/config.js配置文件
global.api = &#39;/healthy/api&#39;
// 调用接口页面
let response = await axios.get(`${global.api}/dtea-service/user/result?examId=${this.questionId}`);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了本地项目和发布至服务器打包文件保持一致，可以把项目中本地代理修改下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const proxy = {
  &#39;/healthy/api&#39;: {
    target: &#39;http://192.136.12.211:8888&#39;,
    changeOrigin: true,
    pathRewrite: {
      &#39;^/healthy/api&#39;: &#39;&#39;,
    },
  },
};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作者：wayne1125&lt;br&gt;
链接：https://www.jianshu.com/p/16de172d0d45&lt;br&gt;
来源：简书&lt;br&gt;
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
">[React]React实战(1)——Ant Design Pro项目history模式下相关配置</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/diff-make-and-new/"" data-c="
          &lt;p&gt;Go 中经常初始化结构体，对于初始化方式的一些深入理解。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;当我们想要在Go语言中初始化一个结构时，其实会使用到两个完全不同的关键字，也就是 make 和 new，同时出现两个用于初始化的关键字对于初学者来说可能会感到非常困惑，不过它们两者却有着完全不同的作用。&lt;/p&gt;
&lt;p&gt;在Go语言中，make 关键字的主要作用是初始化内置的数据结构，也就是我们在前面提到的数组、切片和 Channel，而当我们想要获取指向某个类型的指针时可以使用 new 关键字，只是知道如何使用 new 的人真的比较少，下面我们就来介绍一下 make 和 new 它们的区别以及实现原理。&lt;/p&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;虽然 make 和 new 都是能够用于初始化数据结构，但是它们两者能够初始化的结构类型却有着较大的不同，make 在Go语言中只能用于初始化语言中的基本类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;slice := make([]int, 0, 100)
hash := make(map[int]bool, 10)
ch := make(chan int, 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些基本类型都是语言为我们提供的，我们在前面已经介绍过了它们初始化的过程以及原理，但是在这里还是需要提醒大家注意的是，这三者返回了不同类型的数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slice 是一个包含 data、cap 和 len 的结构体；&lt;/li&gt;
&lt;li&gt;hash 是一个指向 hmap 结构体的指针；&lt;/li&gt;
&lt;li&gt;ch 是一个指向 hchan 结构体的指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而另一个用于初始化数据结构的关键字 new 的作用其实就非常简单了，它只是接收一个类型作为参数然后返回一个指向这个类型的指针：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;i := new(int)
var v int
i := &amp;amp;v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码片段中的两种不同初始化方法其实是等价的，它们都会创建一个指向 int 零值的指针。&lt;br&gt;
&lt;img src=&#34;https://stardemo.github.io/post-images/1590031666594.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
到了这里我们对Go语言中这两种不同关键字的使用也有了一定的了解：&lt;code&gt;make 用于创建切片、哈希表和管道等内置数据结构，new 用于分配并创建一个指向对应类型的指针&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&#34;实现原理&#34;&gt;实现原理&lt;/h1&gt;
&lt;p&gt;接下来我们将分别介绍 make 和 new 在初始化不同数据结构时的具体过程，我们会从编译期间和运行时两个不同的阶段理解这两个关键字的原理。&lt;/p&gt;
&lt;h2 id=&#34;make&#34;&gt;make&lt;/h2&gt;
&lt;p&gt;我们已经了解了 make 在创建数组和切片、哈希表和 Channel 的具体过程，所以在这里我们也只是会简单提及 make 相关的数据结构初始化原理。&lt;br&gt;
&lt;img src=&#34;https://stardemo.github.io/post-images/1590031718876.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在编译期间的类型检查阶段，Go语言其实就将代表 make 关键字的 OMAKE 节点根据参数类型的不同转换成了 OMAKESLICE、OMAKEMAP 和 OMAKECHAN 三种不同类型的节点，这些节点最终也会调用不同的运行时函数来初始化数据结构。&lt;/p&gt;
&lt;h2 id=&#34;new&#34;&gt;new&lt;/h2&gt;
&lt;p&gt;内置函数 new 会在编译期间的 SSA 代码生成阶段经过 callnew 函数的处理，如果请求创建的类型大小是 0，那么就会返回一个表示空指针的 zerobase 变量，在遇到其他情况时会将关键字转换成 newobject：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func callnew(t *types.Type) *Node {
    if t.NotInHeap() {
        yyerror(&amp;quot;%v is go:notinheap; heap allocation disallowed&amp;quot;, t)
    }
    dowidth(t)
 
    if t.Size() == 0 {
        z := newname(Runtimepkg.Lookup(&amp;quot;zerobase&amp;quot;))
        z.SetClass(PEXTERN)
        z.Type = t
        return typecheck(nod(OADDR, z, nil), ctxExpr)
    }
 
    fn := syslook(&amp;quot;newobject&amp;quot;)
    fn = substArgTypes(fn, t)
    v := mkcall1(fn, types.NewPtr(t), nil, typename(t))
    v.SetNonNil(true)
    return v
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要提到的是，哪怕当前变量是使用 var 进行初始化，在这一阶段也可能会被转换成 newobject 的函数调用并在堆上申请内存：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func walkstmt(n *Node) *Node {
    switch n.Op {
    case ODCL:
        v := n.Left
        if v.Class() == PAUTOHEAP {
            if prealloc[v] == nil {
                prealloc[v] = callnew(v.Type)
            }
            nn := nod(OAS, v.Name.Param.Heapaddr, prealloc[v])
            nn.SetColas(true)
            nn = typecheck(nn, ctxStmt)
            return walkstmt(nn)
        }
    case ONEW:
        if n.Esc == EscNone {
            r := temp(n.Type.Elem())
            r = nod(OAS, r, nil)
            r = typecheck(r, ctxStmt)
            init.Append(r)
            r = nod(OADDR, r.Left, nil)
            r = typecheck(r, ctxExpr)
            n = r
        } else {
            n = callnew(n.Type.Elem())
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然这也不是绝对的，如果当前声明的变量或者参数不需要在当前作用域外生存，那么其实就不会被初始化在堆上，而是会初始化在当前函数的栈中并随着函数调用的结束而被销毁。&lt;/p&gt;
&lt;p&gt;newobject 函数的工作就是获取传入类型的大小并调用 mallocgc 在堆上申请一片大小合适的内存空间并返回指向这片内存空间的指针：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func newobject(typ *_type) unsafe.Pointer {
    return mallocgc(typ.size, typ, true)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;最后，简单总结一下Go语言中 make 和 new 关键字的实现原理，make 关键字的主要作用是创建切片、哈希表和 Channel 等内置的数据结构，而 new 的主要作用是为类型申请一片内存空间，并返回指向这片内存的指针。&lt;/p&gt;
&lt;p&gt;————————————————&lt;br&gt;
版权声明：本文为CSDN博主「浅汐王」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br&gt;
原文链接：https://blog.csdn.net/qq_32252917/java/article/details/102953438&lt;/p&gt;
">[Go]make和new关键字的区别及实现原理</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/kubernetes-ri-zhi-cai-ji-sidecar-mo-shi-jie-shao/"" data-c="
          &lt;h2 id=&#34;日志采集方式&#34;&gt;日志采集方式&lt;/h2&gt;
&lt;p&gt;日志作为任一系统不可或缺的部分，在K8S的官方文档中也介绍了多种的日志采集形式，总结起来主要有下述3种：原生方式、DaemonSet方式和Sidecar方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原生方式：使用 kubectl logs 直接在查看本地保留的日志，或者通过docker engine的 log driver 把日志重定向到文件、syslog、fluentd等系统中。&lt;/li&gt;
&lt;li&gt;DaemonSet方式：在K8S的每个node上部署日志agent，由agent采集所有容器的日志到服务端。&lt;/li&gt;
&lt;li&gt;Sidecar方式：一个POD中运行一个sidecar的日志agent容器，用于采集该POD主容器产生的日志。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://stardemo.github.io/post-images/1589181137428.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;采集方式对比&#34;&gt;采集方式对比&lt;/h2&gt;
&lt;p&gt;每种采集方式都有一定的优劣势，这里我们进行简单的对比：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://stardemo.github.io/post-images/1589180900695.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;从上述表格中可以看出：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原生方式相对功能太弱，一般不建议在生产系统中使用，否则问题调查、数据统计等工作很难完成；&lt;/li&gt;
&lt;li&gt;DaemonSet方式在每个节点只允许一个日志agent，相对资源占用要小很多，但扩展性、租户隔离性受限，比较适用于功能单一或业务不是很多的集群；&lt;/li&gt;
&lt;li&gt;Sidecar方式为每个POD单独部署日志agent，相对资源占用较多，但灵活性以及多租户隔离性较强，建议大型的K8S集群或作为PAAS平台为多个业务方服务的集群使用该方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;作者：阿里云云栖号
链接：https://www.jianshu.com/p/72f34de4dd35
来源：简书
&lt;/code&gt;&lt;/pre&gt;
">Kubernetes日志采集Sidecar模式介绍</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/hello-gridea-blog/"" data-c="
          &lt;p&gt;👏  博客搬家啦  &lt;strong&gt;Github Pages&lt;/strong&gt; ！&lt;br&gt;
👏  文章逐渐迁移整理中🙏 ！&lt;br&gt;
👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意...&lt;br&gt;
&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/linux-chang-yong-ming-ling-dig/"" data-c="
          &lt;h1 id=&#34;一-安装&#34;&gt;一. 安装&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;1.Ubuntu/Debian安装&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install dnsutils
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;2.CentOs/RedHat安装&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;yum install bind-utils -y
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二-使用&#34;&gt;二. 使用&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;1.简单查询&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dig DOMAIN　
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;2.按记录类型查询，默认为A记录&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dig DOMAIN cname
dig DOMAIN mx
dig DOMAIN AAAA
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;3.指定DNS服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dig  DOMAIN MX  8.8.8.8
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;4.从根域逐步查询的过程：+trace&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dig DOMAIN +trace
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;5.返回简洁的查询结果&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dig DOMAIN +short
&lt;/code&gt;&lt;/pre&gt;
">Linux 常用命令dig</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/prometheus-shi-yong-ji-lu/"" data-c="
          &lt;h2 id=&#34;prometheus四种数据类型&#34;&gt;Prometheus四种数据类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Counter&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Counter&lt;/code&gt;用于累计值，例如记录请求次数、任务完成数、错误发生次数。一直增加，不会减少。重启进程后，会被重置。&lt;/p&gt;
&lt;p&gt;例如：&lt;br&gt;
&lt;code&gt;http_response_total{method=”GET”,endpoint=”/api/tracks”} 100&lt;/code&gt;&lt;br&gt;
10秒后抓取&lt;br&gt;
&lt;code&gt;http_response_total{method=”GET”,endpoint=”/api/tracks”} 100&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gauge&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Gauge&lt;/code&gt;常规数值，例如 温度变化、内存使用变化。可变大，可变小。重启进程后，会被重置。&lt;/p&gt;
&lt;p&gt;例如：&lt;br&gt;
&lt;code&gt;memory_usage_bytes{host=”master-01″} 100 &amp;lt; 抓取值&lt;/code&gt;&lt;br&gt;
&lt;code&gt;memory_usage_bytes{host=”master-01″} 30&lt;/code&gt;&lt;br&gt;
&lt;code&gt;memory_usage_bytes{host=”master-01″} 50&lt;/code&gt;&lt;br&gt;
&lt;code&gt;memory_usage_bytes{host=”master-01″} 80 &amp;lt; 抓取值&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Histogram&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Histogram&lt;/code&gt;（直方图）可以理解为柱状图的意思，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。它特别之处是可以对记录的内容进行分组，提供&lt;code&gt;count&lt;/code&gt;和&lt;code&gt;sum&lt;/code&gt;全部值的功能。&lt;/p&gt;
&lt;p&gt;例如：&lt;br&gt;
&lt;code&gt;{小于10=5次，小于20=1次，小于30=2次}&lt;/code&gt;&lt;br&gt;
count=7次，sum=7次的求和值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Summary&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Summary&lt;/code&gt;和&lt;code&gt;Histogram&lt;/code&gt;十分相似，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。同样提供 count 和 sum 全部值的功能。&lt;/p&gt;
&lt;p&gt;例如：count=7次，sum=7次的值求值。&lt;/p&gt;
&lt;p&gt;它提供一个quantiles的功能，可以按%比划分跟踪的结果。例如：quantile取值0.95，表示取采样值里面的95%数据。&lt;/p&gt;
">Prometheus使用记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/gitlab-runner-shi-yong-ji-lu/"" data-c="
          &lt;h2 id=&#34;基于现有的docker凭证文件创建secret&#34;&gt;基于现有的Docker凭证文件创建Secret&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/&#34;&gt;refrence: kubernetes-pull image private registry &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A Kubernetes cluster uses the Secret of &lt;code&gt;docker-registry&lt;/code&gt; type to authenticate with a container registry to pull a private image.&lt;/p&gt;
&lt;p&gt;If you already ran &lt;code&gt;docker login&lt;/code&gt;, you can copy that credential into Kubernetes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl create secret generic regcred \
    --from-file=.dockerconfigjson=&amp;lt;path/to/.docker/config.json&amp;gt; \
    --type=kubernetes.io/dockerconfigjson
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you need more control (for example, to set a namespace or a label on the new secret) then you can customise the Secret before storing it. Be sure to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;set the name of the data item to &lt;code&gt;.dockerconfigjson&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;base64 encode the docker file and paste that string, unbroken as the value for field &lt;code&gt;data[&amp;quot;.dockerconfigjson&amp;quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;set type to &lt;code&gt;kubernetes.io/dockerconfigjson&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you get the error message&lt;br&gt;
&lt;code&gt;error: no objects passed to create&lt;/code&gt;, it may mean the base64 encoded string is invalid. If you get an error message like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Secret &amp;quot;myregistrykey&amp;quot; is invalid: 
data[.dockerconfigjson]: invalid value ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;, it means the base64 encoded string in the data was successfully decoded, but could not be parsed as a &lt;code&gt;.docker/config.json&lt;/code&gt; file.&lt;/p&gt;
">Gitlab-runner使用记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/icloud-drive-tong-bu-wen-jian-shi-hu-lue-zhi-ding-mu-lu/"" data-c="
          &lt;h1 id=&#34;动机&#34;&gt;动机：&lt;/h1&gt;
&lt;p&gt;使用&lt;code&gt;Gridea&lt;/code&gt;书写博客使用iCloud Drive进行目录同步，将数据目录设置到&lt;code&gt;iCloud Drive&lt;/code&gt;下，但是并不想每次同步渲染结果的&lt;code&gt;output&lt;/code&gt;目录。&lt;/p&gt;
&lt;h1 id=&#34;解法&#34;&gt;解法&lt;/h1&gt;
&lt;p&gt;查询自 - 知乎 &lt;a href=&#34;%22https://www.zhihu.com/question/300993426/answer/539337720%22&#34;&gt;iCloud Drive同步文件时，如何忽略指定目录？&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;原文描述&#34;&gt;原文描述&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# it is okay to delete the target folder since it will be rebuilt by maven
rm -r target
# create a nosync folder which will not be in iCloud
mkdir target.nosync
# create a symbolic link named &amp;quot;target&amp;quot; so that maven can find the target.nosync folder
ln -s `pwd`/target.nosync target
# rebuild the project
mvn package
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实践&#34;&gt;实践&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; ~/Library/Mobile Documents/com~apple~CloudDocs/Gridea : rm -rf output
 ~/Library/Mobile Documents/com~apple~CloudDocs/Gridea : mkdir output.nosync
 ~/Library/Mobile Documents/com~apple~CloudDocs/Gridea : ln -s output.nosync output
&lt;/code&gt;&lt;/pre&gt;
">iCloud Drive同步文件时，忽略指定目录</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/toolbox/"" data-c="
          &lt;h1 id=&#34;i-classfa-fa-archive-aria-hiddentruei-常用的一堆小工具&#34;&gt;&lt;i class=&#34;fa fa-archive&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;  常用的一堆小工具&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;i class=&#34;fa fa-internet-explorer&#34;&gt;&lt;/i&gt; 获取出口IP地址 &lt;a href=&#34;http://tool.istarboy.site/getIP&#34;&gt;http://tool.istarboy.site/getIP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
">工具箱</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/repost-oauth2-get-start/"" data-c="
          &lt;p&gt;最近在看Gitlab的OAouth2 文档，计划使运维平台接入Gitlab的授权认证。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;em&gt;转载自&lt;a href=&#34;https://www.cnblogs.com/Wddpct/p/8976480.html#3-oauth-2-%E7%9A%84%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B&#34;&gt;cnblog-白细胞-oauth2深入介绍&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;1-前言&#34;&gt;1. 前言&lt;/h1&gt;
&lt;p&gt;OAuth 2 是一个授权框架，或称授权标准，它可以使第三方应用程序或客户端获得对HTTP服务上（例如 Google，GitHub ）用户帐户信息的有限访问权限。OAuth 2 通过将用户身份验证委派给托管用户帐户的服务以及授权客户端访问用户帐户进行工作。综上，OAuth 2 可以为 Web 应用 和桌面应用以及移动应用提供授权流程。&lt;/p&gt;
&lt;p&gt;本文将从OAuth 2 角色，授权许可类型，授权流程等几方面进行讲解。&lt;/p&gt;
&lt;p&gt;在正式讲解之前，这里先引入一段应用场景，用以与后文的角色讲解对应。&lt;/p&gt;
&lt;p&gt;开发者A注册某IT论坛后，发现可以在信息栏中填写自己的 Github 个人信息和仓库项目，但是他又觉得手工填写十分麻烦，直接提供 Github 账户和密码给论坛管理员帮忙处理更是十分智障。&lt;br&gt;
不过该论坛似乎和 Github 有不可告人的秘密，开发者A可以点击“导入”按钮，授权该论坛访问自己的 Github 账户并限制其只具备读权限。这样一来， Github 中的所有仓库和相关信息就可以很方便地被导入到信息栏中，账户隐私信息也不会泄露。&lt;br&gt;
这背后，便是 OAuth 2 在大显神威。&lt;/p&gt;
&lt;h1 id=&#34;2-oauth2-角色&#34;&gt;2. OAuth2 角色&lt;/h1&gt;
&lt;p&gt;OAuth 2 标准中定义了以下几种角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源所有者（Resource Owner）&lt;/li&gt;
&lt;li&gt;资源服务器（Resource Server）&lt;/li&gt;
&lt;li&gt;授权服务器（Authorization Server）&lt;/li&gt;
&lt;li&gt;客户端（Client）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;21-资源所有者resource-owner&#34;&gt;2.1 资源所有者（Resource Owner）&lt;/h2&gt;
&lt;p&gt;资源所有者是 OAuth 2 四大基本角色之一，在 OAuth 2 标准中，资源所有者即代表授权客户端访问本身资源信息的用户（User），也就是应用场景中的“开发者A”。客户端访问用户帐户的权限仅限于用户授权的“范围”（aka. scope，例如读取或写入权限）。&lt;/p&gt;
&lt;p&gt;如果没有特别说明，下文中出现的&amp;quot;用户&amp;quot;将统一代表资源所有者。&lt;/p&gt;
&lt;h2 id=&#34;22-资源授权服务器resourceauthorization-server&#34;&gt;2.2 资源/授权服务器（Resource/Authorization Server）&lt;/h2&gt;
&lt;p&gt;资源服务器托管了受保护的用户账号信息，而授权服务器验证用户身份然后为客户端派发资源访问令牌。&lt;/p&gt;
&lt;p&gt;在上述应用场景中，Github 既是授权服务器也是资源服务器，个人信息和仓库信息即为资源（Resource）。而在实际工程中，不同的服务器应用往往独立部署，协同保护用户账户信息资源。&lt;/p&gt;
&lt;h2 id=&#34;23-客户端client&#34;&gt;2.3 客户端（Client）&lt;/h2&gt;
&lt;p&gt;在 OAuth 2 中，客户端即代表意图访问受限资源的第三方应用。在访问实现之前，它必须先经过用户者授权，并且获得的授权凭证将进一步由授权服务器进行验证。&lt;/p&gt;
&lt;p&gt;如果没有特别说明，下文中将不对&amp;quot;应用&amp;quot;，“第三方应用”，“客户端”做出区分。&lt;/p&gt;
&lt;h1 id=&#34;3-oauth-2-的授权流程&#34;&gt;3. OAuth 2 的授权流程&lt;/h1&gt;
&lt;p&gt;目前为止你应该对 OAuth 2 的角色有了些概念，接下来让我们来看看这几个角色之间的抽象授权流程图和相关解释。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，实际的授权流程图会因为用户返回授权许可类型的不同而不同。但是下图大体上能反映一次完整抽象的授权流程。&lt;br&gt;
*&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://stardemo.github.io/post-images/1587209819481.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Authrization Request&lt;/p&gt;
&lt;p&gt;客户端向用户请求对资源服务器的&lt;code&gt;authorization grant&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Authorization Grant（Get)&lt;/p&gt;
&lt;p&gt;如果用户授权该次请求，客户端将收到一个&lt;code&gt;authorization grant&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Authorization Grant（Post）&lt;/p&gt;
&lt;p&gt;客户端向授权服务器发送它自己的客户端身份标识和上一步中的&lt;code&gt;authorization grant&lt;/code&gt;，请求访问令牌。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Access Token（Get）&lt;/p&gt;
&lt;p&gt;如果客户端身份被认证，并且&lt;code&gt;authorization grant&lt;/code&gt;也被验证通过，授权服务器将为客户端派发&lt;code&gt;access token&lt;/code&gt;。授权阶段至此全部结束。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Access Token（Post &amp;amp;&amp;amp; Validate）&lt;/p&gt;
&lt;p&gt;客户端向资源服务器发送&lt;code&gt;access token&lt;/code&gt;用于验证并请求资源信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Protected Resource（Get）&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;access token&lt;/code&gt;验证通过，资源服务器将向客户端返回资源信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4-客户端应用注册&#34;&gt;4. 客户端应用注册&lt;/h1&gt;
&lt;p&gt;在应用 OAuth 2 之前，你必须在授权方服务中注册你的应用。如 Google Identity Platform 或者 Github OAuth Setting，诸如此类 OAuth 实现平台中一般都要求开发者提供如下所示的授权设置项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用名称&lt;/li&gt;
&lt;li&gt;应用网站&lt;/li&gt;
&lt;li&gt;重定向URI或回调URL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重定向URI是授权方服务在用户授权（或拒绝）应用程序之后重定向供用户访问的地址，因此也是用于处理授权码或访问令牌的应用程序的一部分。&lt;/p&gt;
&lt;h2 id=&#34;41-client-id-和-client-secret&#34;&gt;4.1 Client ID 和 Client Secret&lt;/h2&gt;
&lt;p&gt;一旦你的应用注册成功，授权方服务将以&lt;code&gt;client id&lt;/code&gt;和&lt;code&gt;client secret&lt;/code&gt;的形式为应用发布&lt;code&gt;client credentials&lt;/code&gt;（客户端凭证）。&lt;code&gt;client id&lt;/code&gt;是公开透明的字符串，授权方服务使用该字符串来标识应用程序，并且还用于构建呈现给用户的授权 &lt;code&gt;url&lt;/code&gt; 。当应用请求访问用户的帐户时，&lt;code&gt;client secret&lt;/code&gt;用于验证应用身份，并且必须在客户端和服务之间保持私有性。&lt;/p&gt;
&lt;h1 id=&#34;5-授权许可authorization-grant&#34;&gt;5. 授权许可（Authorization Grant）&lt;/h1&gt;
&lt;p&gt;如上文的抽象授权流程图所示，前四个阶段包含了获取&lt;code&gt;authorization grant&lt;/code&gt;和&lt;code&gt;access token&lt;/code&gt;的动作。授权许可类型取决于应用请求授权的方式和授权方服务支持的 Grant Type。OAuth 2 定义了四种 Grant Type，每一种都有适用的应用场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Authorization Code&lt;/p&gt;
&lt;p&gt;结合普通服务器端应用使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Implicit&lt;/p&gt;
&lt;p&gt;结合移动应用或 Web App 使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Resource Owner Password Credentials&lt;/p&gt;
&lt;p&gt;适用于受信任客户端应用，例如同个组织的内部或外部应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Client Credentials&lt;/p&gt;
&lt;p&gt;适用于客户端调用主服务API型应用（比如百度API Store）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下将分别介绍这四种许可类型的相关授权流程。&lt;/p&gt;
&lt;h2 id=&#34;51-authorization-code-flow&#34;&gt;5.1 Authorization Code Flow&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Authorization Code&lt;/code&gt; 是最常使用的一种授权许可类型，它适用于第三方应用类型为&lt;code&gt;server-side&lt;/code&gt;型应用的场景。&lt;code&gt;Authorization Code&lt;/code&gt;授权流程基于重定向跳转，客户端必须能够与&lt;code&gt;User-agent&lt;/code&gt;（即用户的 Web 浏览器）交互并接收通过&lt;code&gt;User-agent&lt;/code&gt;路由发送的实际&lt;code&gt;authorization code&lt;/code&gt;值。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://stardemo.github.io/post-images/1587210133819.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-user-authorization-request&#34;&gt;1. User Authorization Request&lt;/h3&gt;
&lt;p&gt;首先，客户端构造了一个用于请求authorization code的URL并引导User-agent跳转访问。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://authorization-server.com/auth
 ?response_type=code
 &amp;amp;client_id=29352915982374239857
 &amp;amp;redirect_uri=https%3A%2F%2Fexample-client.com%2Fcallback
 &amp;amp;scope=create+delete
 &amp;amp;state=xcoiv98y2kd22vusuye3kch
response_type=code
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此参数和参数值用于提示授权服务器当前客户端正在进行&lt;code&gt;Authorization Code&lt;/code&gt;授权流程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;client_id 客户端身份标识。&lt;/li&gt;
&lt;li&gt;redirect_uri 标识授权服务器接收客户端请求后返回给&lt;code&gt;User-agent&lt;/code&gt;的跳转访问地址。&lt;/li&gt;
&lt;li&gt;scope 指定客户端请求的访问级别。&lt;/li&gt;
&lt;li&gt;state 由客户端生成的随机字符串，步骤2中用户进行授权客户端的请求时也会携带此字符串用于比较，这是为了防止CSRF攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-user-authorizes-applcation&#34;&gt;2. User Authorizes Applcation&lt;/h3&gt;
&lt;p&gt;当用户点击上文中的示例链接时，用户必须已经在授权服务中进行登录（否则将会跳转到登录界面，不过 OAuth 2 并不关心认证过程），然后授权服务会提示用户授权或拒绝应用程序访问其帐户。以下是授权应用程序的示例：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://stardemo.github.io/post-images/1587210161632.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-authorization-code-grant&#34;&gt;3. Authorization Code Grant&lt;/h3&gt;
&lt;p&gt;如果用户确认授权，授权服务器将重定向&lt;code&gt;User-agent&lt;/code&gt;至之前客户端提供的指向客户端的&lt;code&gt;redirect_uri&lt;/code&gt;地址，并附带&lt;code&gt;code&lt;/code&gt;和&lt;code&gt;state&lt;/code&gt;参数（由之前客户端提供），于是客户端便能直接读取到&lt;code&gt;authorization code&lt;/code&gt;值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://example-client.com/redirect
?code=g0ZGZmNjVmOWIjNTk2NTk4ZTYyZGI3
&amp;amp;state=xcoiv98y2kd22vusuye3kch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;state&lt;/code&gt;值将与客户端在请求中最初设置的值相同。客户端将检查重定向中的状态值是否与最初设置的状态值相匹配。这可以防止CSRF和其他相关攻击。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;code&lt;/code&gt;是授权服务器生成的&lt;code&gt;authorization code&lt;/code&gt;值。&lt;code&gt;code&lt;/code&gt;相对较短，通常持续1到10分钟，具体取决于授权服务器设置。&lt;/p&gt;
&lt;h3 id=&#34;4-access-token-request&#34;&gt;4. Access Token Request&lt;/h3&gt;
&lt;p&gt;现在客户端已经拥有了服务器派发的authorization code，接下来便可以使用authorization code和其他参数向服务器请求access token（POST方式）。其他相关参数如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;grant_type=authorization_code - 这告诉服务器当前客户端正在使用Authorization Code授权流程。&lt;/li&gt;
&lt;li&gt;code - 应用程序包含它在重定向中给出的授权码。&lt;/li&gt;
&lt;li&gt;redirect_uri - 与请求authorization code时使用的redirect_uri相同。某些资源（API）不需要此参数。&lt;/li&gt;
&lt;li&gt;client_id - 客户端标识。&lt;/li&gt;
&lt;li&gt;client_secret - 应用程序的客户端密钥。这确保了获取access token的请求只能从客户端发出，而不能从可能截获authorization code的攻击者发出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-access-token-grant&#34;&gt;5. Access Token Grant&lt;/h3&gt;
&lt;p&gt;服务器将会验证第4步中的请求参数，当验证通过后（校验&lt;code&gt;authorization code&lt;/code&gt;是否过期，&lt;code&gt;client id&lt;/code&gt;和&lt;code&gt;client secret&lt;/code&gt;是否匹配等），服务器将向客户端返回&lt;code&gt;access token&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;access_token&amp;quot;:&amp;quot;MTQ0NjJkZmQ5OTM2NDE1ZTZjNGZmZjI3&amp;quot;,
  &amp;quot;token_type&amp;quot;:&amp;quot;bearer&amp;quot;,
  &amp;quot;expires_in&amp;quot;:3600,
  &amp;quot;refresh_token&amp;quot;:&amp;quot;IwOGYzYTlmM2YxOTQ5MGE3YmNmMDFkNTVk&amp;quot;,
  &amp;quot;scope&amp;quot;:&amp;quot;create delete&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，授权流程全部结束。直到access token 过期或失效之前，客户端可以通过资源服务器API访问用户的帐户，并具备scope中给定的操作权限。&lt;/p&gt;
&lt;h2 id=&#34;52-implicit-flow&#34;&gt;5.2 Implicit Flow&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Implicit&lt;/code&gt;授权流程和&lt;code&gt;Authorization Code&lt;/code&gt;基于重定向跳转的授权流程十分相似，但它适用于移动应用和 &lt;code&gt;Web App&lt;/code&gt;，这些应用与普通服务器端应用相比有个特点，即&lt;code&gt;client secret&lt;/code&gt;不能有效保存和信任。&lt;/p&gt;
&lt;p&gt;相比&lt;code&gt;Authorization Code&lt;/code&gt;授权流程，&lt;code&gt;Implicit&lt;/code&gt;去除了请求和获得&lt;code&gt;authorization code&lt;/code&gt;的过程，而用户点击授权后，授权服务器也会直接把&lt;code&gt;access token&lt;/code&gt;放在&lt;code&gt;redirect_uri&lt;/code&gt;中发送给&lt;code&gt;User-agent&lt;/code&gt;（浏览器）。 同时第1步构造请求用户授权 &lt;code&gt;url&lt;/code&gt; 中的&lt;code&gt;response_type&lt;/code&gt;参数值也由 &lt;code&gt;code&lt;/code&gt; 更改为 &lt;code&gt;token&lt;/code&gt; 或 &lt;code&gt;id_token&lt;/code&gt; 。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://stardemo.github.io/post-images/1587210216686.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-user-authorization-request-2&#34;&gt;1. User Authorization Request&lt;/h3&gt;
&lt;p&gt;客户端构造的URL如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://{yourOktaDomain}.com/oauth2/default/v1/authorize?client_id=0oabv6kx4qq6
h1U5l0h7&amp;amp;response_type=token&amp;amp;redirect_uri=http%3A%2F%2Flocalhost%3
A8080&amp;amp;state=state-296bc9a0-a2a2-4a57-be1a-d0e2fd9bb601&amp;amp;nonce=foo&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;response_type的response_type参数值为 token 或 id_token 。&lt;/p&gt;
&lt;p&gt;其他请求参数与Authorization Code授权流程相比没有并什么变化。&lt;/p&gt;
&lt;h3 id=&#34;2-user-authorizes-application略&#34;&gt;2. User Authorizes Application（略）&lt;/h3&gt;
&lt;h3 id=&#34;3-redirect-uri-with-access-token-in-fragment&#34;&gt;3. Redirect URI With Access Token In Fragment&lt;/h3&gt;
&lt;p&gt;假设用户授予访问权限，授权服务器将User-agent（浏览器） 重定向回客户端使用之前提供的redirect_uri。并在 uri 的 #fragment 部分添加access_token键值对。如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:8080/#access_token=eyJhb[...]erw&amp;amp;token_type=Bearer&amp;amp;expires_in=3600&amp;amp;scope=openid&amp;amp;state=state-296bc9a0-a2a2-4a57-be1a-d0e2fd9bb601
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;token_type - 当且仅当response_type设置为 token 时返回，值恒为 Bearer。&lt;/p&gt;
&lt;p&gt;注意在Implicit流程中，access_token值放在了 URI 的 #fragment 部分，而不是作为 ?query 参数。&lt;/p&gt;
&lt;h3 id=&#34;4-user-agent-follows-the-redirect-uri&#34;&gt;4. User-agent Follows the Redirect URI&lt;/h3&gt;
&lt;p&gt;User-agent（浏览器）遵循重定向指令，请求redirect_uri标识的客户端地址，并在本地保留 uri 的 #fragment 部分的access_token信息。&lt;/p&gt;
&lt;h3 id=&#34;5-application-sends-access-token-extraction-script&#34;&gt;5. Application Sends Access Token Extraction Script&lt;/h3&gt;
&lt;p&gt;客户端生成一个包含 token 解构脚本的 Html 页面，这个页面被发送给User-agent（浏览器），执行脚本解构完整的redirect_uri并提取其中的access_token（access token信息在第4步中已经被User-agent保存）。&lt;/p&gt;
&lt;h3 id=&#34;6-access-token-passed-to-application&#34;&gt;6. Access Token Passed to Application&lt;/h3&gt;
&lt;p&gt;User-agent（浏览器）向客户端发送解构提取的access token。&lt;/p&gt;
&lt;p&gt;至此，授权流程全部结束。直到access token 过期或失效之前，客户端可以通过资源服务器API访问用户的帐户，并具备scope中给定的操作权限。&lt;/p&gt;
&lt;h2 id=&#34;53-resource-owner-password-credentials-flow&#34;&gt;5.3 Resource Owner Password Credentials Flow&lt;/h2&gt;
&lt;p&gt;Resource Owner Password Credentials授权流程适用于用户与客户端具有信任关系的情况，例如设备操作系统或同一组织的内部及外部应用。用户与应用交互表现形式往往体现为客户端能够直接获取用户凭据（用户名和密码，通常使用交互表单）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://stardemo.github.io/post-images/1587210225887.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-resource-owner-password-credentials-from-user-input&#34;&gt;1. Resource Owner Password Credentials From User Input&lt;/h3&gt;
&lt;p&gt;用户向客户端提供用户名与密码作为授权凭据。&lt;/p&gt;
&lt;h3 id=&#34;2-resource-owner-password-credentials-from-client-to-server&#34;&gt;2. Resource Owner Password Credentials From Client To Server&lt;/h3&gt;
&lt;p&gt;客户端向授权服务器发送用户输入的授权凭据以请求 access token。客户端必须已经在服务器端进行注册。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=password&amp;amp;username=johndoe&amp;amp;password=A3ddj3w
grant_type - 必选项，值恒为 password
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-access-token-passed-to-application&#34;&gt;3. Access Token Passed to Application&lt;/h3&gt;
&lt;p&gt;授权服务器对客户端进行认证并检验用户凭据的合法性，如果检验通过，将向客户端派发 access token&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;access_token&amp;quot;:&amp;quot;2YotnFZFEjr1zCsicMWpAA&amp;quot;,
  &amp;quot;token_type&amp;quot;:&amp;quot;example&amp;quot;,
  &amp;quot;expires_in&amp;quot;:3600,
  &amp;quot;refresh_token&amp;quot;:&amp;quot;tGzv3JOkF0XG5Qx2TlKWIA&amp;quot;,
  &amp;quot;example_parameter&amp;quot;:&amp;quot;example_value&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;54-client-credentials-flow&#34;&gt;5.4 Client Credentials Flow&lt;/h2&gt;
&lt;p&gt;Client Credential是最简单的一种授权流程。客户端可以直接使用它的client credentials或其他有效认证信息向授权服务器发起获取access token的请求。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://stardemo.github.io/post-images/1587210349251.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;两步中的请求体和返回体分别如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
grant_type - 必选项，值恒为 client_credentials
{
       &amp;quot;access_token&amp;quot;:&amp;quot;2YotnFZFEjr1zCsicMWpAA&amp;quot;,
       &amp;quot;token_type&amp;quot;:&amp;quot;example&amp;quot;,
       &amp;quot;expires_in&amp;quot;:3600,
       &amp;quot;example_parameter&amp;quot;:&amp;quot;example_value&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-总结&#34;&gt;6. 总结&lt;/h1&gt;
&lt;p&gt;说实在的，笔者已经有很长一段时间没有好好地分享心得，发表博客，这固然有工作繁忙，学习充实的原因，但确实也是有些懒，既然认识到了，自然就不希望再堕落下去了。&lt;/p&gt;
&lt;p&gt;这一年里读了很多书，做了很多事，虽然自觉在大学时期便接触了部分项目管理和开发的知识，但是工作后的收获仍然十分动心。微服务也好，DDD也好，或是具体的数据库理论和运维工程实践上笔者也有了更深的认识。而时至今日，笔者觉得自己是又到了重新积淀，重新迈向下一个阶段的时候。鉴权服务作为构建健壮微服务必不可少的一环（甚至可以说是第一个工程），所以以 OAuth 2 作为重启的第一篇。当然 OAuth 2 也仍然只是鉴权体系中的授权理论，更基础的认证（Authentication）理论还没有引出，希望在之后的日子里能带来更多关于鉴权相关的博文，如认证体系和功能权限设计在工程上的应用，共勉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习和编程都是快乐的。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;参考资料及文献&#34;&gt;参考资料及文献&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6749&#34;&gt;The OAuth 2.0 Authorization Framework&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.okta.com/blog/2018/04/10/oauth-authorization-code-grant-type&#34;&gt;What is the OAuth 2.0 Authorization Code Grant Type?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2#grant-type-implicit&#34;&gt;An Introduction to OAuth 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.okta.com/authentication-guide/implementing-authentication/implicit&#34;&gt;Implicit Flow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.okta.com/docs/api/resources/oidc#authorize&#34;&gt;Response Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/linianhui/p/oauth2-authorization.html&#34;&gt;认证授权 OAuth2授权&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;名词中英文对照&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;英文&lt;/th&gt;
&lt;th&gt;中文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Authorization Grant&lt;/td&gt;
&lt;td&gt;授权许可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Authorization Code&lt;/td&gt;
&lt;td&gt;授权码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Access Token&lt;/td&gt;
&lt;td&gt;访问令牌&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Authorization&lt;/td&gt;
&lt;td&gt;授权&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Authentication&lt;/td&gt;
&lt;td&gt;认证&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">[转]OAuth2 入门</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/golang--docker-remote-debug/"" data-c="
          &lt;p&gt;满脑子骚操作之 --  VSCode远程调试--- Docker篇&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;配置vscode连接远程docker&#34;&gt;配置VSCode连接远程Docker&lt;/h3&gt;
&lt;h4 id=&#34;1-远程docker调试开启api访问&#34;&gt;1. 远程Docker调试,开启api访问&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;修改&lt;code&gt;systemd&lt;/code&gt;配置&lt;code&gt;vim /lib/systemd/system/docker.service&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;ExecStart&lt;/code&gt;操作后增加 &lt;code&gt; -H tcp://0.0.0.0:2375&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-配置vscode连接远程docker&#34;&gt;2. 配置VSCode连接远程Docker&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;VSCode安装插件 Docker &amp;amp;&amp;amp; 远程调试工具&lt;/li&gt;
&lt;li&gt;配置VSCode DOCKER_HOST配置 &lt;code&gt;tcp://ip:2375&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-注意事项&#34;&gt;3. 注意事项&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;DockerAPI端口注意使用&lt;code&gt;2375&lt;/code&gt;端口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;远程调试docker内的golang程序&#34;&gt;远程调试Docker内的Golang程序&lt;/h3&gt;
&lt;h4 id=&#34;1备注&#34;&gt;1.备注&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Q: 遇到&lt;code&gt;dlv&lt;/code&gt;调试程序&lt;code&gt;could not launch process: fork/exec ./debug: operation not permitted&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A: docker run 过程中增加&lt;code&gt;--security-opt=seccomp:unconfined&lt;/code&gt;参数&lt;br&gt;
&lt;a href=&#34;https://github.com/go-delve/delve/issues/515&#34;&gt;delve issue 515&lt;/a&gt; or&lt;br&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/35827819/fork-exec-debug-operation-not-permitted&#34;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;todo补充&#34;&gt;TODO补充&lt;/h3&gt;
"> Docker远程调试Golang</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/frontend-router-hash/"" data-c="
          &lt;p&gt;最近学习goframe框架时涉及到一个前端框架整合，以静态文件模式加载，前后端分离模式运行的，结果遇到了路由问题，其中涉及到前端路由中的hash使用。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&#34;url中的hash&#34;&gt;url中的&lt;code&gt;hash(#)&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;1-hash的含义&#34;&gt;1. &lt;code&gt;hash(#)&lt;/code&gt;的含义&lt;/h3&gt;
&lt;p&gt;#代表网页中的一个位置，其右边的字符，就是该位置的标识符。比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://loaclhost/index.html#user
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2http请求不包含&#34;&gt;2.HTTP请求不包含#&lt;/h3&gt;
&lt;h3 id=&#34;3后面的字符&#34;&gt;3.&lt;code&gt;#&lt;/code&gt;后面的字符&lt;/h3&gt;
&lt;h3 id=&#34;4改变不触发网页重载&#34;&gt;4.改变&lt;code&gt;#&lt;/code&gt;不触发网页重载&lt;/h3&gt;
&lt;h3 id=&#34;5改变会改变浏览器的访问历史&#34;&gt;5.改变&lt;code&gt;#&lt;/code&gt;会改变浏览器的访问历史&lt;/h3&gt;
&lt;h3 id=&#34;6windowlocationhash-读取值&#34;&gt;6.&lt;code&gt;window.location.hash&lt;/code&gt; 读取#值&lt;/h3&gt;
&lt;h3 id=&#34;7onhashchange事件&#34;&gt;7.&lt;code&gt;onhashchange&lt;/code&gt;事件&lt;/h3&gt;
">前端路由-Hash</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/record-mysql-config-settings/"" data-c="
          &lt;p&gt;公司运维基础架构迭代过程中，MYSQL由5.6升级至5.7过程中遇到5.7的强规范限制导致的不兼容老系统，修改参数以适应原有系统。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h1 id=&#34;mysql的参数调整&#34;&gt;MySQL的参数调整&lt;/h1&gt;
&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;p&gt;因为业务老旧sql原因需要禁用&lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询MYSQL版本&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select version();
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;sql_mode查询&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; select @@GLOBAL.sql_mode;
+-------------------------------------------------------------------------------------------------------------------------------------------+
| @@GLOBAL.sql_mode                                                                                                                         |
+-------------------------------------------------------------------------------------------------------------------------------------------+
| ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |
+-------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set

mysql&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解决办法&#34;&gt;解决办法&lt;/h2&gt;
&lt;p&gt;重新设置sql_mode，来关闭这个选项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.临时禁用&lt;br&gt;
在sql终端中执行如下&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql&amp;gt; set @@GLOBAL.sql_mode = &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;
mysql&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;2.永久修改&lt;br&gt;
在mysql配置文件的mysqld节点下增加如下内容&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sql_mode=&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;k8s模式configmap注入&#34;&gt;k8s模式configmap注入&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1.原理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;永久修改mysqld节点下参数，使用k8s的&lt;code&gt;volumeMounts&lt;/code&gt;挂入路径&lt;code&gt;/etc/mysql/mysql.conf.d/mysqld.cnf&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2.ConfigMap内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
data:
  mysqld.cnf: |-
    # Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
    #
    # This program is free software; you can redistribute it and/or modify
    # it under the terms of the GNU General Public License as published by
    # the Free Software Foundation; version 2 of the License.
    #
    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU General Public License for more details.
    #
    # You should have received a copy of the GNU General Public License
    # along with this program; if not, write to the Free Software
    # Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

    #
    # The MySQL  Server configuration file.
    #
    # For explanations see
    # http://dev.mysql.com/doc/mysql/en/server-system-variables.html

    [mysqld]
    pid-file        = /var/run/mysqld/mysqld.pid
    socket          = /var/run/mysqld/mysqld.sock
    datadir         = /var/lib/mysql
    log-error       = /var/log/mysql/error.log
    # Disabling symbolic-links is recommended to prevent assorted security risks
    symbolic-links=0
    sql_mode=&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;
kind: ConfigMap
metadata:
  name: mysql-config-add
  namespace: cb-common

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
">记录一次MYSQL参数调整</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/linux-dd-shellcmd/"" data-c="
          &lt;p&gt;dd命令用于读取、转换并输出数据。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&#34;dd指令使用&#34;&gt;dd指令使用&lt;/h2&gt;
&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;dd   [option]
# dd指令选项详解
if=file：输入文件名，缺省为标准输入
of=file：输出文件名，缺省为标准输出
ibs=bytes：一次读入 bytes 个字节（即一个块大小为 bytes 个字节）
obs=bytes：一次写 bytes 个字节（即一个块大小为 bytes 个字节）
bs=bytes：同时设置读写块的大小为 bytes ，可代替 ibs 和 obs
cbs=bytes：一次转换 bytes 个字节，即转换缓冲区大小
skip=blocks：从输入文件开头跳过 blocks 个块后再开始复制
seek=blocks：从输出文件开头跳过 blocks 个块后再开始复制。（通常只有当输出文件是磁盘或磁带时才有效）
count=blocks：仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数
conv=ASCII：把EBCDIC码转换为ASCIl码。
conv=ebcdic：把ASCIl码转换为EBCDIC码。
conv=ibm：把ASCIl码转换为alternate EBCDIC码。
conv=block：把变动位转换成固定字符。
conv=ublock：把固定位转换成变动位。
conv=ucase：把字母由小写转换为大写。
conv=lcase：把字母由大写转换为小写。
conv=notrunc：不截短输出文件。
conv=swab：交换每一对输入字节。
conv=noerror：出错时不停止处理。
conv=sync：把每个输入记录的大小都调到ibs的大小（用NUL填充）。

注意：指定数字的地方若以下列字符结尾乘以相应的数字：b=512, c=1, k=1024, w=2, xm=number m，kB=1000，K=1024，MB=1000*1000，M=1024*1024，GB=1000*1000*1000，G=1024*1024*1024
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dd使用实例&#34;&gt;dd使用实例&lt;/h3&gt;
&lt;h4 id=&#34;假设了如下的情况&#34;&gt;假设了如下的情况：&lt;/h4&gt;
&lt;p&gt;要备份的数据文件：30720KB  &lt;code&gt;block 0 =8 KB.&lt;/code&gt; &lt;code&gt; raw offset 64 KB.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设定 bs=8k&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、从raw设备备份到raw设备&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dd if=/dev/rsd1b of=/dev/rsd2b bs=8k skip=8 seek=8 count=3841
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;2、裸设备到文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dd if=/dev/rsd1b of=/backup/df1.dbf bs=8k skip=8 count=3841
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;3、文件系统到裸设备&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dd if=/backup/df1.dbf of=/dev/rsd2b bs=8k seek=8
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;4、文件系统到文件系统，你可以为了提升I/O把bs设为较高的数值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dd if=/oracle/dbs/df1.dbf of=/backup/df1.dbf bs=1024k
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;5、备份/dev/hdx全盘数据，并利用gzip工具进行压缩，保存到指定路径（bzip2工具也一样可使用）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dd  if=/dev/hdx  |  gzip &amp;gt; /path/to/image.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;6、生成1G的虚拟块设备Sparse File(稀疏文件)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dd if=/dev/zero of=1G.img bs=1M seek=1000 count=0
# Sparse File是什么，稀疏文件，也就是说，是一个拥有空的空间的文件，磁盘块将并没分配给这些文件。如果这些空的空间填满ASCII的NULL字符，那么文件才会是实际的大小。
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;7、拷贝光盘数据到backup文件夹下，并保存为cd.iso文件，再进行刻录&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dd  if=/dev/cdrom  of=/backup/cd.iso
cdrecord -v cd.iso
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;8、将内存里的数据拷贝到backup目录下的mem.bin文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dd if=/dev/mem of=/backup/mem.bin bs=1024
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;9、将软驱数据备份到当前目录的disk.img文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dd if=/dev/fd0 of=disk.img count=1 bs=1440k
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;10、将备份文件恢复到指定盘&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dd if=/backup/df1.dbf of=/dev/rsd1b
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;11、将压缩的备份文件恢复到指定盘&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;gzip -dc /path/to/image.gz | dd of=/dev/hdx
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;12、测试磁盘写能力&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;time dd if=/dev/zero of=/test.dbf bs=8k count=300000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为/dev/zero是一个伪设备，它只产生空字符流，对它不会产生IO，所以，IO都会集中在of文件中，of文件只用于写，所以这个命令相当于测试磁盘的写能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;13、测试磁盘读能力&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;time dd if=/dev/sdb1 of=/dev/null bs=8k
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为/dev/sdb1是一个物理分区，对它的读取会产生IO，/dev/null是伪设备，相当于黑洞，of到该设备不会产生IO，所以，这个命令的IO只发生在/dev/sdb1上，也相当于测试磁盘的读能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;14、测试同时读写能力&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;time dd if=/dev/sdb1 of=/test1.dbf bs=8k
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令下，一个是物理分区，一个是实际的文件，对它们的读写都会产生IO（对/dev/sdb1是读，对/test1.dbf是写），假设他们都在一个磁盘中，这个命令就相当于测试磁盘的同时读写能力&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;15、备份磁盘开始的512Byte大小的MBR信息到指定文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dd  if=/dev/hdx  of=/path/to/image  count=1  bs=512
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;16、恢复MBR&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dd if=/mnt/windows/linux.lnx of=/dev/hda bs=512 count=1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;17、得到最恰当的block size。通过比较dd指令输出中所显示的命令执行时间（选时间最少的那个），即可确定系统最佳的block size大小&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file
dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file
dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file
dd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file
&lt;/code&gt;&lt;/pre&gt;
">Linux dd实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/docker-cleanup/"" data-c="
          &lt;p&gt;docker，kubernetes使用过程中镜像越来越多 清理镜像以缓解磁盘压力&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;strong&gt;为了以防万一（线上环境一定要谨慎谨慎再谨慎&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、先使用&lt;code&gt;kubectl get po –namespace &lt;/code&gt;命名空间，查看该命名空间已有的pod&lt;/li&gt;
&lt;li&gt;2、重新部署pod，在该node节点上产生多余的images镜像&lt;/li&gt;
&lt;li&gt;3、使用&lt;code&gt;docker system df&lt;/code&gt;命令，在执行清除镜像之前先查看镜像和容器的数量。&lt;br&gt;
注：类似于Linux上的df命令，用于查看Docker的磁盘使用情况。这条命令可以查看到node节点中镜像和容器的数量&lt;/li&gt;
&lt;li&gt;4、使用&lt;code&gt;docker system prune –a&lt;/code&gt;。清除无用的镜像&lt;br&gt;
注：&lt;code&gt;docker system prune&lt;/code&gt;命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像(即无tag的镜像)。&lt;code&gt;docker system prune -a&lt;/code&gt;命令清理得更加彻底，可以将没有容器使用Docker镜像都删掉。注意，这两个命令会把你暂时关闭的容器，以及暂时没有用到的Docker镜像都删掉了…所以使用之前一定要想清楚吶。&lt;/li&gt;
&lt;li&gt;5、使用&lt;code&gt;docker system df&lt;/code&gt;命令，查看镜像和容器的数量；是否成功&lt;/li&gt;
&lt;/ul&gt;
">Docker清理无用镜像</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/sudowith-touchid/"" data-c="
          &lt;p&gt;macos 使用touchid代替sudo&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&#34;操作方法&#34;&gt;操作方法&lt;/h2&gt;
&lt;p&gt;打开“终端”，执行以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo sed -i &amp;quot;.bak&amp;quot; &#39;2s/^/auth       sufficient     pam_tid.so\&#39;$&#39;\n/g&#39; /etc/pam.d/sudo
sudo sed -i &amp;quot;.bak&amp;quot; &#39;2s/^/auth       sufficient     pam_tid.so\&#39;$&#39;\n/g&#39; /etc/pam.d/sudo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后输入您的管理员密码，回车，大功告成了！不用重启哦～&lt;/p&gt;
&lt;h2 id=&#34;命令说明&#34;&gt;命令说明&lt;/h2&gt;
&lt;p&gt;该命令的作用是把 &lt;code&gt;/etc/pam.d/sudo &lt;/code&gt;备份为 &lt;code&gt;/etc/pam.d/sudo.bak&lt;/code&gt;，然后在 &lt;code&gt;/etc/pam.d/sudo&lt;/code&gt; 的第二行前面加入 &lt;code&gt;uth sufficient pam_tid.so &lt;/code&gt;这个字符串。&lt;br&gt;
修改该文件的目的是在 sudo 程序的认证过程前面插入 Touch ID 验证的模块。感兴趣的小伙伴可以去了解一下 PAM 架构。&lt;br&gt;
如果需要恢复原文件，请执行：&lt;code&gt;sudo mv /etc/pam.d/sudo.bak /etc/pam.d/sudo&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;作者：hptuchief
链接：https://hacpai.com/article/1512017120360
来源：黑客派
协议：CC BY-SA 4.0 https://creativecommons.org/licenses/by-sa/4.0/
&lt;/code&gt;&lt;/pre&gt;
">MBP13 使用TouchID调用sudo</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/shell-skills/"" data-c="
          &lt;p&gt;记录一些使用Shell的技巧&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&#34;shell中的文字处理&#34;&gt;Shell中的文字处理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JSON&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# jq是一个Shell中的常用json对象化工具
# 安装
yum install -y jq
# 使用Demo Data见后文 如下命令获取
kubectl get secrets -n test test -ojson
########Data##########################
kubectl get secrets -n test test -ojson|jq &#39;.data.passwd&#39;
&amp;quot;aGVsbG8=&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;# JSON Data
{
    &amp;quot;apiVersion&amp;quot;: &amp;quot;v1&amp;quot;,
    &amp;quot;data&amp;quot;: {
        &amp;quot;passwd&amp;quot;: &amp;quot;aGVsbG8=&amp;quot;
    },
    &amp;quot;kind&amp;quot;: &amp;quot;Secret&amp;quot;,
    &amp;quot;metadata&amp;quot;: {
        &amp;quot;annotations&amp;quot;: {
            &amp;quot;field.cattle.io/creatorId&amp;quot;: &amp;quot;u-9hs5v&amp;quot;,
            &amp;quot;field.cattle.io/projectId&amp;quot;: &amp;quot;c-6hbc7:p-l8wp7&amp;quot;,
            &amp;quot;lifecycle.cattle.io/create.secretsController_c-6hbc7&amp;quot;: &amp;quot;true&amp;quot;,
            &amp;quot;secret.user.cattle.io/secret&amp;quot;: &amp;quot;true&amp;quot;
        },
        &amp;quot;creationTimestamp&amp;quot;: &amp;quot;2019-04-22T05:29:28Z&amp;quot;,
        &amp;quot;name&amp;quot;: &amp;quot;test&amp;quot;,
        &amp;quot;namespace&amp;quot;: &amp;quot;test&amp;quot;,
        &amp;quot;resourceVersion&amp;quot;: &amp;quot;472498492&amp;quot;,
        &amp;quot;selfLink&amp;quot;: &amp;quot;/api/v1/namespaces/cms3/secrets/test&amp;quot;,
        &amp;quot;uid&amp;quot;: &amp;quot;9985b4ea-64bf-11e9-9da9-06976d75b572&amp;quot;
    },
    &amp;quot;type&amp;quot;: &amp;quot;Opaque&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;String 字符串处理去除引号&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl get secrets -n test test -ojson|jq &#39;.data.passwd&#39;
&amp;quot;aGVsbG8=&amp;quot;
kubectl get secrets -n cms3 test -ojson|jq &#39;.data.passwd&#39;|sed &#39;s/\&amp;quot;//g&#39;
aGVsbG8=
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;环境变量注入配置文件&lt;br&gt;
&lt;code&gt;使用envsubst&lt;/code&gt;&lt;br&gt;
安装&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Ubuntu/Debian 
apt-get install gettext
# Centos
yum install gettext
&lt;/code&gt;&lt;/pre&gt;
使用&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export TEST_INJECT_VAR=&amp;quot;test-data-2020&amp;quot;
envsubst &amp;lt; input.file  &amp;gt; output.file
cat input.file
${TEST_INJECT_VAR}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Shell使用技巧合辑</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/vscode-shi-yong-ji-qiao-ji-lu/"" data-c="
          &lt;p&gt;记录日常使用中的一些技巧&lt;/p&gt;
&lt;!--more--&gt;
&lt;h1 id=&#34;vscode使用技巧记录&#34;&gt;VSCode使用技巧记录&lt;/h1&gt;
&lt;h2 id=&#34;代码折叠&#34;&gt;代码折叠&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;折叠所有区域代码：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ctrl + k&lt;/code&gt; +&lt;code&gt;ctrl + 0&lt;/code&gt;  ( 注意这个是零，不是字母O)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;展开所有折叠区域代码：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ctrl +k&lt;/code&gt;+ &lt;code&gt; ctrl + J&lt;/code&gt; ;&lt;/p&gt;
&lt;h2 id=&#34;删除多行&#34;&gt;删除多行&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1.移动到要删除的行字符&lt;/li&gt;
&lt;li&gt;2.按下快捷键&lt;code&gt;ctrl + shift +l&lt;/code&gt; ,或者从&lt;code&gt;selection菜单&lt;/code&gt;中选择&lt;code&gt;select all occurrences&lt;/code&gt;(选择所有出现的单词)&lt;/li&gt;
&lt;li&gt;3.此时点击 键盘上的 &lt;code&gt;delete&lt;/code&gt;,就会把所有的选中字符全部删除&lt;/li&gt;
&lt;li&gt;4.最后按下&lt;code&gt;shift + delete&lt;/code&gt; ,则会把光标所在的行整行删除掉&lt;/li&gt;
&lt;/ul&gt;
">VSCode使用技巧记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/nginx10mgao-bing-fa-nei-he-you-hua-xiang-jie/"" data-c="
          &lt;p&gt;Nginx 高并发情况下对内核的性能调参&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&#34;何为高并发&#34;&gt;何为高并发&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;默认的Linux内核参数考虑的是最通用场景，不符合用于支持高并发访问的Web服务器，所以需要修改Linux内核参数，这样可以让Nginx拥有更高的性能；&lt;/li&gt;
&lt;li&gt;在优化内核时，可以做的事情很多，不过，我们通常会根据业务特点来进行调整，当Nginx作为静态web内容服务器、反向代理或者提供压缩服务器的服务器时，期内核参数的调整都是不同的，这里针对最通用的、使Nginx支持更多并发请求的TCP网络参数做简单的配置；&lt;/li&gt;
&lt;li&gt;这些需要修改/etc/sysctl.conf来更改内核参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置详析&#34;&gt;配置详析&lt;/h2&gt;
&lt;p&gt;表示单个进程较大可以打开的句柄数；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fs.file-max = 999999
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数设置为 1 ，表示允许将TIME_WAIT状态的socket重新用于新的TCP链接，这对于服务器来说意义重大，因为总有大量TIME_WAIT状态的链接存在；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_tw_reuse = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当keepalive启动时，TCP发送keepalive消息的频度；默认是2小时，将其设置为10分钟，可以更快的清理无效链接。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ner.ipv4.tcp_keepalive_time = 600
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当服务器主动关闭链接时，socket保持在FIN_WAIT_2状态的较大时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_fin_timeout = 30
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个参数表示操作系统允许TIME_WAIT套接字数量的较大值，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。&lt;/p&gt;
&lt;p&gt;该参数默认为180000，过多的TIME_WAIT套接字会使Web服务器变慢。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_max_tw_buckets = 5000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义UDP和TCP链接的本地端口的取值范围。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.ipv4.ip_local_port_range = 1024 65000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义了TCP接受缓存的最小值、默认值、较大值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_rmem = 10240 87380 12582912
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义TCP发送缓存的最小值、默认值、较大值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_wmem = 10240 87380 12582912
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当网卡接收数据包的速度大于内核处理速度时，会有一个列队保存这些数据包。这个参数表示该列队的较大值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.core.netdev_max_backlog = 8096
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示内核套接字接受缓存区默认大小。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.core.rmem_default = 6291456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示内核套接字发送缓存区默认大小。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.core.wmem_default = 6291456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示内核套接字接受缓存区较大大小。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.core.rmem_max = 12582912
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示内核套接字发送缓存区较大大小。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.core.wmem_max = 12582912
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：以上的四条配置，需要根据业务逻辑和实际的硬件成本来综合考虑；&lt;/p&gt;
&lt;p&gt;与性能无关。用于解决TCP的SYN***。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_syncookies = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个参数表示TCP三次握手建立阶段接受SYN请求列队的较大长度，默认1024，将其设置的大一些可以使出现Nginx繁忙来不及accept新连接的情况时，Linux不至于丢失客户端发起的链接请求。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_max_syn_backlog = 8192
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个参数用于设置启用timewait快速回收。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_tw_recycle = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选项默认值是128，这个参数用于调节系统同时发起的TCP连接数，在高并发的请求中，默认的值可能会导致链接超时或者重传，因此需要结合高并发请求数来调节此值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.core.somaxconn=262114
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选项用于设定系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤立链接将立即被复位并输出警告信息。这个限制指示为了防止简单的DOS***，不用过分依靠这个限制甚至认为的减小这个值，更多的情况是增加这个值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_max_orphans=262114
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了方便使用，下方可以直接复制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_tw_reuse = 1
fs.file-max = 999999
net.ipv4.tcp_fin_timeout = 30
ner.ipv4.tcp_keepalive_time = 600
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;©著作权归作者所有：来自51CTO博客作者喵来个鱼的&lt;a href=&#34;https://blog.51cto.com/m51cto/2363354&#34;&gt;原创作品&lt;/a&gt;&lt;/p&gt;
">Nginx10m+高并发内核优化详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/fu-wu-qi-ssh-jia-gu/"" data-c="
          &lt;p&gt;多次失败登录即封掉IP，防止暴力破解&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/panblack/p/secure_ssh_auto_block.html&#34;&gt;参考Blog&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;一-系统&#34;&gt;一、系统：&lt;/h2&gt;
&lt;p&gt;Centos7 64位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rpm -qa | grep tcp
yum  –y  install  tcp_wrappers  
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二-方法&#34;&gt;二、方法：&lt;/h2&gt;
&lt;p&gt;读取/var/log/secure，查找关键字 Failed，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Jan 21 22:14:36 gitlab sshd[1631]: Failed password for invalid user admin from 193.201.224.199 port 34257 ssh2
Jan 21 22:14:39 gitlab sshd[1631]: Failed password for invalid user admin from 193.201.224.199 port 34257 ssh2
Jan 21 22:14:40 gitlab sshd[1641]: Failed password for invalid user deploy5 from 139.59.93.89 port 36812 ssh2
Jan 21 22:14:46 gitlab sshd[1664]: Failed password for invalid user router from 193.201.224.199 port 4674 ssh2
Jan 21 22:14:52 gitlab sshd[1675]: Failed password for invalid user root from 193.201.224.199 port 11127 ssh2
Jan 21 22:14:59 gitlab sshd[1692]: Failed password for invalid user admin from 193.201.224.199 port 24144 ssh2
Jan 21 22:15:01 gitlab sshd[1692]: Failed password for invalid user admin from 193.201.224.199 port 24144 ssh2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从这些行中提取IP地址，如果次数达到10次(脚本中判断次数字符长度是否大于1)则将该IP写到 /etc/hosts.deny中。&lt;/p&gt;
&lt;h2 id=&#34;三步骤&#34;&gt;三.步骤：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;1、先把始终允许的IP填入 /etc/hosts.allow ，&lt;mark&gt;这很重要&lt;/mark&gt;！比如：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sshd:19.16.18.1:allow
sshd:19.16.18.2:allow
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;脚本 /usr/local/bin/secure_ssh.sh&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#! /bin/bash
cat /var/log/secure|awk &#39;/Failed/{print $(NF-3)}&#39;|sort|uniq -c|awk &#39;{print $2&amp;quot;=&amp;quot;$1;}&#39; &amp;gt; /usr/local/bin/black.list
for i in `cat  /usr/local/bin/black.list`
do
  IP=`echo $i |awk -F= &#39;{print $1}&#39;`
  NUM=`echo $i|awk -F= &#39;{print $2}&#39;`
  if [ ${#NUM} -gt 1 ]; then
    grep $IP /etc/hosts.deny &amp;gt; /dev/null
    if [ $? -gt 0 ];then
      echo &amp;quot;sshd:$IP:deny&amp;quot; &amp;gt;&amp;gt; /etc/hosts.deny
    fi
  fi
done
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;将secure_ssh.sh脚本放入cron计划任务，每1分钟执行一次。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# crontab -e
*/1 * * * *  sh /usr/local/bin/secure_ssh.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四-测试&#34;&gt;四、测试：&lt;/h2&gt;
">服务器SSH加固</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/shell-tong-ji-ip-chu-xian-pin-ci/"" data-c="
          &lt;p&gt;统计文件或者系统内IP出现频率&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&#34;统计文件里的ip&#34;&gt;统计文件里的IP&lt;/h2&gt;
&lt;h3 id=&#34;准备文件&#34;&gt;准备文件&lt;/h3&gt;
&lt;p&gt;首先准备文件demo.txt，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 192.168.41.20 
2 192.168.41.21 
3 192.168.41.22 
4 192.168.41.23 
5 192.168.41.24 
6 192.168.41.25
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;统计&#34;&gt;统计&lt;/h3&gt;
&lt;p&gt;统计出现次数最多的ip次数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat demo.txt | awk &#39;{print $2}&#39; | sort | uniq -c | sort -n -r | head -n 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;awk &#39;{ print $2}&#39;：取数据的第2域（第2列），第一列是标号（1，2，3...）,第二列是ip地址

sort：对IP部分进行排序。

uniq -c：打印每一重复行出现的次数。（并去掉重复行）

sort -n -r：按照重复行出现的次序倒序排列。

head -n 1：取排在第一位的ip地址
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;统计netstat-ntu命令的结果中出现次数最多的ip地址&#34;&gt;统计&lt;code&gt;netstat -ntu&lt;/code&gt;命令的结果中出现次数最多的ip地址：&lt;/h2&gt;
&lt;p&gt;执行命令 &lt;code&gt;netstat -ntu&lt;/code&gt;，显示结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Active Internet connections (w/o servers) 
Proto Recv-Q Send-Q Local Address Foreign Address State 
tcp 0 0 127.0.0.1:8152 127.0.0.1:4193 TIME_WAIT 
tcp 0 0 127.0.0.1:8152 127.0.0.1:4192 TIME_WAIT 
tcp 0 0 127.0.0.1:8152 127.0.0.1:4196 TIME_WAIT 
tcp 0 0 127.0.0.1:8152 127.0.0.1:4199 TIME_WAIT 
tcp 0 0 127.0.0.1:8152 127.0.0.1:4201 TIME_WAIT 
tcp 0 0 127.0.0.1:8152 127.0.0.1:4204 TIME_WAIT 
tcp 0 0 127.0.0.1:8152 127.0.0.1:4207 TIME_WAIT 
tcp 0 0 127.0.0.1:8152 127.0.0.1:4210 TIME_WAIT 
tcp 0 0 192.168.32.62:41682 192.168.47.27:5431 TIME_WAIT 
tcp 0 0 192.168.32.62:41685 192.168.47.27:5431 TIME_WAIT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用脚本命令进行统计：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;netstat -ntu | tail -n +3|awk &#39;{ print $5}&#39; | cut -d : -f 1 | sort | uniq -c| sort -n -r | head -n 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;统计结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8 127.0.0.1
2 192.168.47.27
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tail -n +3 :去掉上面用红色标明的两行。

awk &#39;{ print $5}&#39;：取数据的第5域（第5列）

cut -d : -f 1 ：取蓝色部分前面的IP部分。

sort：对IP部分进行排序。

uniq -c：打印每一重复行出现的次数。（并去掉重复行）

sort -n -r：按照重复行出现的次序倒序排列。

head -n 5：取排在前5位的IP 
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;作者：Hello_刘&lt;br&gt;
来源：CSDN&lt;br&gt;
原文：https://blog.csdn.net/xiamoyanyulrq/article/details/81570652&lt;/p&gt;
">Shell统计IP出现频次</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/systemd-shi-zhan/"" data-c="
          &lt;p&gt;转载自阮一峰的博客文章&lt;a href=&#34;http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html&#34;&gt;Systemd 入门教程：实战篇 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作为学习摘录&lt;/p&gt;
&lt;!--more--&gt;
&lt;h1 id=&#34;一-开机启动&#34;&gt;一、开机启动&lt;/h1&gt;
&lt;p&gt;对于那些支持 Systemd 的软件，安装的时候，会自动在&lt;code&gt;/usr/lib/systemd/system&lt;/code&gt;目录添加一个配置文件。&lt;/p&gt;
&lt;p&gt;如果你想让该软件开机启动，就执行下面的命令（以&lt;code&gt;httpd.service&lt;/code&gt;为例）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo systemctl enable httpd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的命令相当于在&lt;code&gt;/etc/systemd/system&lt;/code&gt;目录添加一个符号链接，指向&lt;code&gt;/usr/lib/systemd/system&lt;/code&gt;里面的&lt;code&gt;httpd.service&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;这是因为开机时，&lt;code&gt;Systemd&lt;/code&gt;只执行&lt;code&gt;/etc/systemd/system&lt;/code&gt;目录里面的配置文件。这也意味着，如果把修改后的配置文件放在该目录，就可以达到覆盖原始配置的效果。&lt;/p&gt;
&lt;h1 id=&#34;二-启动服务&#34;&gt;二、启动服务&lt;/h1&gt;
&lt;p&gt;设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行&lt;code&gt;systemctl start&lt;/code&gt;命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo systemctl start httpd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行上面的命令以后，有可能启动失败，因此要用&lt;code&gt;systemctl status&lt;/code&gt;命令查看一下该服务的状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo systemctl status httpd

httpd.service - The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled)
   Active: active (running) since 金 2014-12-05 12:18:22 JST; 7min ago
 Main PID: 4349 (httpd)
   Status: &amp;quot;Total requests: 1; Current requests/sec: 0; Current traffic:   0 B/sec&amp;quot;
   CGroup: /system.slice/httpd.service
           ├─4349 /usr/sbin/httpd -DFOREGROUND
           ├─4350 /usr/sbin/httpd -DFOREGROUND
           ├─4351 /usr/sbin/httpd -DFOREGROUND
           ├─4352 /usr/sbin/httpd -DFOREGROUND
           ├─4353 /usr/sbin/httpd -DFOREGROUND
           └─4354 /usr/sbin/httpd -DFOREGROUND

12月 05 12:18:22 localhost.localdomain systemd[1]: Starting The Apache HTTP Server...
12月 05 12:18:22 localhost.localdomain systemd[1]: Started The Apache HTTP Server.
12月 05 12:22:40 localhost.localdomain systemd[1]: Started The Apache HTTP Server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的输出结果含义如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Loaded行：配置文件的位置，是否设为开机启动&lt;/li&gt;
&lt;li&gt;Active行：表示正在运行&lt;/li&gt;
&lt;li&gt;Main PID行：主进程ID&lt;/li&gt;
&lt;li&gt;Status行：由应用本身（这里是 httpd ）提供的软件当前状态&lt;/li&gt;
&lt;li&gt;CGroup块：应用的所有子进程&lt;/li&gt;
&lt;li&gt;日志块：应用的日志&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;三-停止服务&#34;&gt;三、停止服务&lt;/h1&gt;
&lt;p&gt;终止正在运行的服务，需要执行&lt;code&gt;systemctl stop&lt;/code&gt;命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo systemctl stop httpd.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有时候，该命令可能没有响应，服务停不下来。这时候就不得不&amp;quot;杀进程&amp;quot;了，向正在运行的进程发出&lt;code&gt;kill&lt;/code&gt;信号。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo systemctl kill httpd.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外，重启服务要执行&lt;code&gt;systemctl restart&lt;/code&gt;命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo systemctl restart httpd.service
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四-读懂配置文件&#34;&gt;四、读懂配置文件&lt;/h1&gt;
&lt;p&gt;一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。&lt;/p&gt;
&lt;p&gt;前面说过，配置文件主要放在&lt;code&gt;/usr/lib/systemd/system&lt;/code&gt;目录，也可能在&lt;code&gt;/etc/systemd/system&lt;/code&gt;目录。找到配置文件以后，使用文本编辑器打开即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;systemctl cat&lt;/code&gt;命令可以用来查看配置文件，下面以&lt;code&gt;sshd.service&lt;/code&gt;文件为例，它的作用是启动一个 SSH 服务器，供其他用户以 SSH 方式登录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ systemctl cat sshd.service

[Unit]
Description=OpenSSH server daemon
Documentation=man:sshd(8) man:sshd_config(5)
After=network.target sshd-keygen.service
Wants=sshd-keygen.service

[Service]
EnvironmentFile=/etc/sysconfig/sshd
ExecStart=/usr/sbin/sshd -D $OPTIONS
ExecReload=/bin/kill -HUP $MAINPID
Type=simple
KillMode=process
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，配置文件分成几个区块，每个区块包含若干条键值对。&lt;/p&gt;
&lt;p&gt;下面依次解释每个区块的内容。&lt;/p&gt;
&lt;h1 id=&#34;五-unit-区块启动顺序与依赖关系&#34;&gt;五、 [Unit] 区块：启动顺序与依赖关系。&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Unit&lt;/code&gt;区块的&lt;code&gt;Description&lt;/code&gt;字段给出当前服务的简单描述，&lt;code&gt;Documentation&lt;/code&gt;字段给出文档位置。&lt;/p&gt;
&lt;p&gt;接下来的设置是启动顺序和依赖关系，这个比较重要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;After&lt;/code&gt;字段：表示如果&lt;code&gt;network.target&lt;/code&gt;或&lt;code&gt;sshd-keygen.service&lt;/code&gt;需要启动，那么sshd.service应该在它们之后启动。&lt;/li&gt;
&lt;li&gt;相应地，还有一个&lt;code&gt;Before&lt;/code&gt;字段，定义&lt;code&gt;sshd.service&lt;/code&gt;应该在哪些服务之前启动。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，&lt;code&gt;After&lt;/code&gt;和&lt;code&gt;Before&lt;/code&gt;字段只涉及启动顺序，不涉及依赖关系。&lt;/p&gt;
&lt;p&gt;举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。&lt;/p&gt;
&lt;p&gt;设置依赖关系，需要使用&lt;code&gt;Wants&lt;/code&gt;字段和&lt;code&gt;Requires&lt;/code&gt;字段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Wants字段：表示sshd.service与sshd-keygen.service之间存在&amp;quot;弱依赖&amp;quot;关系，即如果&amp;quot;sshd-keygen.service&amp;quot;启动失败或停止运行，不影响sshd.service继续执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Requires字段则表示&amp;quot;强依赖&amp;quot;关系，即如果该服务启动失败或异常退出，那么sshd.service也必须退出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，Wants字段与Requires字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。&lt;/p&gt;
&lt;h1 id=&#34;六-service-区块启动行为&#34;&gt;六、[Service] 区块：启动行为&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Service&lt;/code&gt;区块定义如何启动当前服务。&lt;/p&gt;
&lt;h2 id=&#34;61-启动命令&#34;&gt;6.1 启动命令&lt;/h2&gt;
&lt;p&gt;许多软件都有自己的环境参数文件，该文件可以用&lt;code&gt;EnvironmentFile&lt;/code&gt;字段读取。&lt;/p&gt;
&lt;h3 id=&#34;environmentfile字段&#34;&gt;&lt;code&gt;EnvironmentFile&lt;/code&gt;字段：&lt;/h3&gt;
&lt;p&gt;指定当前服务的环境参数文件。该文件内部的&lt;code&gt;key=value&lt;/code&gt;键值对，可以用&lt;code&gt;$key&lt;/code&gt;的形式，在当前配置文件中获取。&lt;/p&gt;
&lt;p&gt;上面的例子中，&lt;code&gt;sshd&lt;/code&gt; 的环境参数文件是&lt;code&gt;/etc/sysconfig/sshd&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;配置文件里面最重要的字段是ExecStart。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ExecStart字段：定义启动进程时执行的命令。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的例子中，启动&lt;code&gt;sshd&lt;/code&gt;，执行的命令是&lt;code&gt;/usr/sbin/sshd -D $OPTIONS&lt;/code&gt;，其中的变量&lt;code&gt;$OPTIONS&lt;/code&gt;就来自&lt;code&gt;EnvironmentFile&lt;/code&gt;字段指定的环境参数文件。&lt;/p&gt;
&lt;p&gt;与之作用相似的，还有如下这些字段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ExecReload字段：重启服务时执行的命令&lt;/li&gt;
&lt;li&gt;ExecStop字段：停止服务时执行的命令&lt;/li&gt;
&lt;li&gt;ExecStartPre字段：启动服务之前执行的命令&lt;/li&gt;
&lt;li&gt;ExecStartPost字段：启动服务之后执行的命令&lt;/li&gt;
&lt;li&gt;ExecStopPost字段：停止服务之后执行的命令&lt;br&gt;
请看下面的例子。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;[Service]
ExecStart=/bin/echo execstart1
ExecStart=
ExecStart=/bin/echo execstart2
ExecStartPost=/bin/echo post1
ExecStartPost=/bin/echo post2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这个配置文件，第二行&lt;code&gt;ExecStart&lt;/code&gt;设为空值，等于取消了第一行的设置，运行结果如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
execstart2
post1
post2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有的启动设置之前，都可以加上一个连词号（-），表示&amp;quot;抑制错误&amp;quot;，即发生错误的时候，不影响其他命令的执行。比如，&lt;code&gt;EnvironmentFile=-/etc/sysconfig/sshd&lt;/code&gt;（注意等号后面的那个连词号），就表示即使&lt;code&gt;/etc/sysconfig/sshd&lt;/code&gt;文件不存在，也不会抛出错误。&lt;/p&gt;
&lt;h2 id=&#34;62-启动类型&#34;&gt;6.2 启动类型&lt;/h2&gt;
&lt;p&gt;Type字段定义启动类型。它可以设置的值如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;simple（默认值）：ExecStart字段启动的进程为主进程&lt;/li&gt;
&lt;li&gt;forking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程&lt;/li&gt;
&lt;li&gt;oneshot：类似于simple，但只执行一次，Systemd 会等它执行完，才启动其他服务&lt;/li&gt;
&lt;li&gt;dbus：类似于simple，但会等待 D-Bus 信号后启动&lt;/li&gt;
&lt;li&gt;notify：类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务&lt;/li&gt;
&lt;li&gt;idle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是一个oneshot的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
[Unit]
Description=Switch-off Touchpad

[Service]
Type=oneshot
ExecStart=/usr/bin/touchpad-off

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的配置文件，启动类型设为&lt;code&gt;oneshot&lt;/code&gt;，就表明这个服务只要运行一次就够了，不需要长期运行。&lt;/p&gt;
&lt;p&gt;如果关闭以后，将来某个时候还想打开，配置文件修改如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Unit]
Description=Switch-off Touchpad

[Service]
Type=oneshot
ExecStart=/usr/bin/touchpad-off start
ExecStop=/usr/bin/touchpad-off stop
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面配置文件中，&lt;code&gt;RemainAfterExit&lt;/code&gt;字段设为&lt;code&gt;yes&lt;/code&gt;，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用&lt;code&gt;systemctl stop&lt;/code&gt;命令停止服务，&lt;code&gt;ExecStop&lt;/code&gt;指定的命令就会执行，从而重新开启触摸板。&lt;/p&gt;
&lt;h2 id=&#34;63-重启行为&#34;&gt;6.3 重启行为&lt;/h2&gt;
&lt;p&gt;Service区块有一些字段，定义了重启行为。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KillMode字段：定义 Systemd 如何停止 sshd 服务。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这个例子中，将&lt;code&gt;KillMode&lt;/code&gt;设为&lt;code&gt;process&lt;/code&gt;，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对 sshd 很重要，否则你停止服务的时候，会连自己打开的 SSH session 一起杀掉。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;KillMode&lt;/code&gt;字段可以设置的值如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉&lt;/li&gt;
&lt;li&gt;process：只杀主进程&lt;/li&gt;
&lt;li&gt;mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号&lt;/li&gt;
&lt;li&gt;none：没有进程会被杀掉，只是执行服务的 stop 命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来是Restart字段。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Restart字段：定义了 sshd 退出后，Systemd 的重启方式。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的例子中，&lt;code&gt;Restart&lt;/code&gt;设为&lt;code&gt;on-failure&lt;/code&gt;，表示任何意外的失败，就将重启sshd。如果 sshd 正常停止（比如执行&lt;code&gt;systemctl stop&lt;/code&gt;命令），它就不会重启。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Restart&lt;/code&gt;字段可以设置的值如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no（默认值）：退出后不会重启&lt;/li&gt;
&lt;li&gt;on-success：只有正常退出时（退出状态码为0），才会重启&lt;/li&gt;
&lt;li&gt;on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启&lt;/li&gt;
&lt;li&gt;on-abnormal：只有被信号终止和超时，才会重启&lt;/li&gt;
&lt;li&gt;on-abort：只有在收到没有捕捉到的信号终止时，才会重启&lt;/li&gt;
&lt;li&gt;on-watchdog：超时退出，才会重启&lt;/li&gt;
&lt;li&gt;always：不管是什么退出原因，总是重启&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于守护进程，推荐设为&lt;code&gt;on-failure&lt;/code&gt;。对于那些允许发生错误退出的服务，可以设&lt;code&gt;为on-abnormal&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后是&lt;code&gt;RestartSec&lt;/code&gt;字段。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RestartSec字段：表示 Systemd 重启服务之前，需要等待的秒数。上面的例子设为等待42秒。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;七-install-区块&#34;&gt;七、[Install] 区块&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Install&lt;/code&gt;区块，定义如何安装这个配置文件，即怎样做到开机启动。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WantedBy&lt;/code&gt;字段：表示该服务所在的 Target。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Target&lt;/code&gt;的含义是服务组，表示一组服务。&lt;code&gt;WantedBy=multi-user.target&lt;/code&gt;指的是，sshd 所在的 &lt;code&gt;Target&lt;/code&gt; 是&lt;code&gt;multi-user.target&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个设置非常重要，因为执行&lt;code&gt;systemctl enable sshd.service&lt;/code&gt;命令时，&lt;code&gt;sshd.service&lt;/code&gt;的一个符号链接，就会放在&lt;code&gt;/etc/systemd/system&lt;/code&gt;目录下面的&lt;code&gt;multi-user.target.wants&lt;/code&gt;子目录之中。&lt;/p&gt;
&lt;p&gt;Systemd 有默认的启动 Target。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ systemctl get-default
multi-user.target
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的结果表示，默认的启动 Target 是&lt;code&gt;multi-user.target&lt;/code&gt;。在这个组里的所有服务，都将开机启动。这就是为什么&lt;code&gt;systemctl enable&lt;/code&gt;命令能设置开机启动的原因。&lt;/p&gt;
&lt;p&gt;使用 Target 的时候，&lt;code&gt;systemctl list-dependencies&lt;/code&gt;命令和&lt;code&gt;systemctl isolate&lt;/code&gt;命令也很有用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 查看 multi-user.target 包含的所有服务
$ systemctl list-dependencies multi-user.target

# 切换到另一个 target
# shutdown.target 就是关机状态
$ sudo systemctl isolate shutdown.target
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般来说，常用的 Target 有两个：一个是&lt;code&gt;multi-user.target&lt;/code&gt;，表示多用户命令行状态；另一个是&lt;code&gt;graphical.target&lt;/code&gt;，表示图形用户状态，它依赖于&lt;code&gt;multi-user.target&lt;/code&gt;。官方文档有一张非常清晰的&lt;a href=&#34;https://www.freedesktop.org/software/systemd/man/bootup.html#System%20Manager%20Bootup&#34;&gt; Target 依赖关系图&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;八-target-的配置文件&#34;&gt;八、Target 的配置文件&lt;/h1&gt;
&lt;p&gt;Target 也有自己的配置文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
$ systemctl cat multi-user.target

[Unit]
Description=Multi-User System
Documentation=man:systemd.special(7)
Requires=basic.target
Conflicts=rescue.service rescue.target
After=basic.target rescue.service rescue.target
AllowIsolate=yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，Target 配置文件里面没有启动命令。&lt;/p&gt;
&lt;p&gt;上面输出结果中，主要字段含义如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Requires字段：要求basic.target一起运行。

Conflicts字段：冲突字段。如果rescue.service或rescue.target正在运行，multi-user.target就不能运行，反之亦然。

After：表示multi-user.target在basic.target 、 rescue.service、 rescue.target之后启动，如果它们有启动的话。

AllowIsolate：允许使用systemctl isolate命令切换到multi-user.target。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;九-修改配置文件后重启&#34;&gt;九、修改配置文件后重启&lt;/h1&gt;
&lt;p&gt;修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 重新加载配置文件
$ sudo systemctl daemon-reload

# 重启相关服务
$ sudo systemctl restart foobar
&lt;/code&gt;&lt;/pre&gt;
">systemd实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;此处捕获一只快乐的野生技术宅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;宅？不宅？宅？Orz~&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;关注&#34;&gt;👀关注&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;DevOps技术&lt;/li&gt;
&lt;li&gt;Service Mesh &amp;amp;&amp;amp; Micro Service&lt;/li&gt;
&lt;li&gt;Iot &amp;amp;&amp;amp; Hardware Security &amp;amp;&amp;amp; Edge Computing&lt;/li&gt;
&lt;li&gt;Kubernetes&lt;/li&gt;
&lt;li&gt;Golang&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;折腾&#34;&gt;🔧折腾&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;各种嵌入式(RaspberryPi，BeagleBone，ESP8266，STM32~~~)&lt;/li&gt;
&lt;li&gt;拆拆拆~~~(常游走于&lt;a href=&#34;https://www.mydigit.cn/&#34;&gt;数码之家&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;黑苹果Hackintosh (常游走于&lt;a href=&#34;http://bbs.pcbeta.com/&#34;&gt;远景论坛&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;喜欢&#34;&gt;⛹ 喜欢&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;旅行 (哪儿都想去~)&lt;/li&gt;
&lt;li&gt;吃吃吃(baes成都~~~)&lt;/li&gt;
&lt;li&gt;数码周边~~~(带电的都玩)(弱电！ =_=  被自动化专业支配的恐惧)&lt;/li&gt;
&lt;li&gt;各种开源新工具 （人送外号小叮当）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;不喜欢&#34;&gt;不喜欢&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;选择 (选择困难啊~~)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/httpd-kai-qi-rewrite-gong-neng/"" data-c="
          &lt;p&gt;帮公司打包业务Docker images时发现rewrire规则默认没有打开，查询解法如下&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&#34;apache开启rewrite重写&#34;&gt;apache开启rewrite重写&lt;/h2&gt;
&lt;h3 id=&#34;命令开启&#34;&gt;命令开启&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo a2enmod rewrite
sudo /etc/init.d/apache2 restart
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;文件修改启动&#34;&gt;文件修改启动&lt;/h3&gt;
&lt;p&gt;在终端输入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo a2enmod rewrite  #开启Rewrite模块（停用模块，使用 a2dismod）

sudo gedit /etc/apache2/sites-available/default 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改下面的地方&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-apache&#34;&gt;&amp;lt;Directory /&amp;gt;

Options FollowSymLinks

AllowOverride None（修改为AllowOverride All）

&amp;lt;/Directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-apache&#34;&gt;&amp;lt;Directory &amp;quot;/var/orioner&amp;quot;&amp;gt;

Options Indexes FollowSymLinks MultiViews

AllowOverride None（修改为AllowOverride All）

Order allow,deny

allow from all

&amp;lt;/Directory&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo /etc/init.d/apache2 restart。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;建立htaccess&#34;&gt;建立htaccess&lt;/h3&gt;
&lt;p&gt;在网站下面建立.htaccess文件&lt;/p&gt;
&lt;p&gt;修改.htaccess文件属性  chmod -R 777 .htaccess&lt;/p&gt;
">Httpd开启rewrite功能</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/nginx-tcp-si-ceng-zhuan-fa-https/"" data-c="
          &lt;p&gt;奇怪的使用场景用到了nginx的四层代理转发&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&#34;配置nginx转发tcp&#34;&gt;配置nginx转发tcp&lt;/h2&gt;
&lt;h3 id=&#34;1查看版本以及原始编译参数&#34;&gt;1.查看版本以及原始编译参数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;nginx -V
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;nginx version: nginx/1.12.2
built by gcc 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) 
built with OpenSSL 1.0.2k-fips  26 Jan 2017
TLS SNI support enabled
configure arguments: --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx \
--modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf \
--error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log \
--http-client-body-temp-path=/var/lib/nginx/tmp/client_body \
--http-proxy-temp-path=/var/lib/nginx/tmp/proxy \
--http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi \
--http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi \
--http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid \
--lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-file-aio \
--with-http_auth_request_module --with-http_ssl_module --with-http_v2_module \
--with-http_realip_module --with-http_addition_module --with-http_xslt_module=dynamic \
--with-http_image_filter_module=dynamic --with-http_geoip_module=dynamic \
--with-http_sub_module --with-http_dav_module --with-http_flv_module \
--with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module \
--with-http_random_index_module --with-http_secure_link_module \
--with-http_degradation_module --with-http_slice_module --with-http_stub_status_module \
--with-http_perl_module=dynamic --with-mail=dynamic --with-mail_ssl_module --with-pcre \
--with-pcre-jit --with-debug --with-stream=dynamic --with-cc-opt=&#39;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic&#39; 
--with-ld-opt=&#39;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&#39; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处参考自己当前使用的nginx编译参数&lt;/p&gt;
&lt;h3 id=&#34;2编译配置&#34;&gt;2.编译，配置&lt;/h3&gt;
&lt;p&gt;在configure里增加如下参数启用模块&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./configure --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx \
--modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf \
--error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log \
--http-client-body-temp-path=/var/lib/nginx/tmp/client_body \
--http-proxy-temp-path=/var/lib/nginx/tmp/proxy \
--http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi \
--http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi \
--http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid \
--lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-file-aio \
--with-http_auth_request_module --with-http_ssl_module --with-http_v2_module \
--with-http_realip_module --with-http_addition_module --with-http_xslt_module=dynamic \
--with-http_image_filter_module=dynamic --with-http_geoip_module=dynamic \
--with-http_sub_module --with-http_dav_module --with-http_flv_module \
--with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module \
--with-http_random_index_module --with-http_secure_link_module \
--with-http_degradation_module --with-http_slice_module --with-http_stub_status_module \
--with-http_perl_module=dynamic --with-mail=dynamic --with-mail_ssl_module --with-pcre \
--with-pcre-jit --with-stream --with-stream=dynamic --with-stream_ssl_preread_module \
--with-stream_ssl_module --with-debug --with-cc-opt=&#39;-O2 -g -pipe -Wall \
-Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 \
-grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic&#39; \
--with-ld-opt=&#39;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&#39; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最主要的使用&lt;code&gt;--with-stream --with-stream_ssl_preread_module --with-stream_ssl_module&lt;/code&gt; 这几个模块，有需要可以添加其它的模块；然后编译安装make &amp;amp;&amp;amp; make install。&lt;/p&gt;
&lt;h3 id=&#34;3配置&#34;&gt;3.配置&lt;/h3&gt;
&lt;p&gt;具体配置命令参考pread module和stream module，启动的时候指定下面的配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;user  root;
worker_processes  auto;
error_log  logs/error.log;
pid        logs/nginx.pid;
worker_rlimit_core   2G;
worker_rlimit_nofile 65535;
events {
    worker_connections  81920;
}
stream {
    log_format  main  &#39;$remote_addr - [$time_local] $connection &#39;
                      &#39;$status $proxy_protocol_addr $server_addr &#39;;
    access_log  logs/access.log  main;
    resolver 114.114.114.114;
    resolver_timeout 60s;
    variables_hash_bucket_size 512;
    server {
        listen       443;
        ssl_preread on;
        proxy_pass $ssl_preread_server_name:443;
        #大致看了一下源码，这里为什么需要配置端口也没有研究明白，求解释？
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处我使用的的是另一套配置,可以时间根据域名转发https(这段配置丢到stream配置块内)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;map $ssl_preread_server_name $backend_pool {
    a.com    a;
    b.com    b;
}
upstream aaa{
    server 192.168.166.3:443;
}
upstream bbb{
    server 192.168.166.4:443;
}
server {
    listen 443;
    ssl_preread on;
    resolver 223.5.5.5; 
    proxy_pass $backend_pool;
    proxy_connect_timeout 15s;
    proxy_timeout 15s;
    proxy_next_upstream_timeout 15s;
    error_log /var/log/nginx/tcp_a.com.log warn;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就可以给&lt;code&gt;https://a.com&lt;/code&gt; 和&lt;code&gt;https://b.com&lt;/code&gt;两个域名做tcp层的代理了，其他域名如果也绑host过来就会被403掉。&lt;br&gt;
这里其实是利用了NGINX的TCP转发做了SNI 反代，与普通的http/http的区别在于，TCP转发只是四层转发不需要证书&lt;/p&gt;
&lt;h3 id=&#34;4遇到的问题&#34;&gt;4.遇到的问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;编译错误1&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;./configure: error: the invalid value in --with-ld-opt=&amp;quot;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&amp;quot;
#解决方案
yum install redhat-rpm-config
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;缺少依赖库&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#根据缺少内容进行安装
yum install perl-ExtUtils-Embed gd-devel gperftools-devel
yum install gcc 
yum install pcre-devel  openssl-devel
&lt;/code&gt;&lt;/pre&gt;
">Nginx TCP四层转发HTTPS</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/mac-osx-1014-wang-qia-pei-zhi-cuo-wu/"" data-c="
          &lt;p&gt;RT Hackintosh是一个好东西，但是苹果这bug不修就很不爽了&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&#34;症状&#34;&gt;症状&lt;/h2&gt;
&lt;p&gt;无效的服务器地址 BasicIPv6ValidationError错误解决方法&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案：&lt;/h2&gt;
&lt;p&gt;思路是这样的：先关闭IPv6，然后设置IPv4，再重新开启IPv6。&lt;/p&gt;
&lt;p&gt;update 2018.08.08  我发现其实可以直接用命令行修改IPv4，不用管IPv6，如果它没报错的话&lt;/p&gt;
&lt;h3 id=&#34;1-关闭-ipv6&#34;&gt;1. 关闭 IPv6&lt;/h3&gt;
&lt;p&gt;显然 ”高级“ &amp;gt; &amp;quot;TCP/IP&amp;quot; 下 IPv6 没有提供关闭选项，所以需要用终端命令&lt;/p&gt;
&lt;p&gt;终端输入：&lt;code&gt;networksetup -setv6off Ethernet&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-设置ipv4地址&#34;&gt;2. 设置IPv4地址&lt;/h3&gt;
&lt;p&gt;终端输入：&lt;code&gt;networksetup -setmanual Ethernet 192.168.31.2 255.255.255.0 192.168.1.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对应IP地址、子网掩码、路由器&lt;/p&gt;
&lt;p&gt;设置完成后，可以看到，以太网显示状态是：已连接&lt;/p&gt;
">mac osx 10.14网卡配置错误</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/da-kai-win10-1803-de-yu-yan-mian-ban/"" data-c="
          &lt;p&gt;最近东西都整理到了有道云笔记里了，一直没空发，还是搬过来些吧，不用显得那么凄凉～&lt;/p&gt;
&lt;!--more---&gt;
&lt;h2 id=&#34;一-文件夹式&#34;&gt;一、文件夹式&lt;/h2&gt;
&lt;p&gt;任意位置新建文件夹，输入（任意名称）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;.{BF782CC9-5A52-4A17-806C-2A894FFEEAC5}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（包括小数点和大括号）&lt;br&gt;
例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;lang.{BF782CC9-5A52-4A17-806C-2A894FFEEAC5}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;便可直接进入语言设置&lt;/p&gt;
&lt;h2 id=&#34;二-快捷方式&#34;&gt;二、快捷方式&lt;/h2&gt;
&lt;p&gt;任意位置新建快捷方式，输入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;explorer shell:::{BF782CC9-5A52-4A17-806C-2A894FFEEAC5}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自己指定名称，也可更改图标。例如语言设置的默认图标位于&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;%SystemRoot%\System32\UserLanguagesCpl.dll
&lt;/code&gt;&lt;/pre&gt;
">打开Win10 1803的语言面板</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/vim-shi-yong-guo-cheng-zhong-de-yi-xie-keng/"" data-c="
          &lt;p&gt;主要记录了使用vim编辑器过程中踩的一些坑以及一些技巧～&lt;/p&gt;
&lt;!--more--&gt;
&lt;h1 id=&#34;vim的一些使用备忘&#34;&gt;VIM的一些使用备忘&lt;/h1&gt;
&lt;h2 id=&#34;vim粘贴代码时自动缩进造成的错误&#34;&gt;vim粘贴代码时自动缩进造成的错误&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;:set paste
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;退出粘贴模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set nopaste
&lt;/code&gt;&lt;/pre&gt;
">vim使用过程中的一些坑</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/ruan-jian-ban-ben-dai-hao-de-jie-shi/"" data-c="
          &lt;h1 id=&#34;alpha-beta-rc-ga版本的区别&#34;&gt;Alpha、Beta、RC、GA版本的区别&lt;/h1&gt;
&lt;!--more--&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Alpha：是内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Beta：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RC：(Release　Candidate) 顾名思义么 ! 用在软件上就是候选版本。系统平台上就是发行候选版本。RC版不会再加入新的功能了，主要着重于除错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GA:General Availability,正式发布的版本，在国外都是用GA来说明release版本的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RTM：(Release to Manufacture)是给工厂大量压片的版本，内容跟正式版是一样的，不过RTM版也有出限制、评估版的。但是和正式版本的主要程序代码都是一样的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OEM：是给计算机厂商随着计算机贩卖的，也就是随机版。只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面CD和说明书(授权书)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RVL：号称是正式版，其实RVL根本不是版本的名称。它是中文版/英文版文档破解出来的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EVAL：而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RTL：Retail(零售版)是真正的正式版，正式上架零售版。在安装盘的i386文件夹里有一个eula.txt，最后有一行EULAID，就是你的版本。比如简体中文正式版是EULAID:WX.4_PRO_RTL_CN，繁体中文正式版是WX.4_PRO_RTL_TW。其中：如果是WX.开头是正式版，WB.开头是测试版。_PRE，代表家庭版；_PRO，代表专业版。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;α、β、λ常用来表示软件测试过程中的三个阶段，α是第一阶段，一般只供内部测试使用；β是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用；λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。&lt;/p&gt;
">软件版本代号的解释</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/bo-ke-zheng-shi-ban-jia-liao-~/"" data-c="
          &lt;p&gt;经过几天的测试，博客稳定了～功能可用。&lt;br&gt;
之前日志的博客内容找时间会做排版上的修复以及调整。&lt;br&gt;
今后不定期同步有道云写的markdown文章过来。&lt;br&gt;
下边是本次博客迁移过程中的一些东西。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h1 id=&#34;博客迁移笔记&#34;&gt;博客迁移笔记&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;原博客方案wordpress-docker&#34;&gt;原博客方案:Wordpress + Docker&lt;/h2&gt;
&lt;h2 id=&#34;新博客方案hexohexo-adminpm2&#34;&gt;新博客方案:Hexo+Hexo admin+PM2&lt;/h2&gt;
&lt;h2 id=&#34;迁移原因&#34;&gt;迁移原因&lt;/h2&gt;
&lt;p&gt;新的VPS配置太低，wordpress无法扛住压力，资源消耗太多。&lt;/p&gt;
&lt;h2 id=&#34;部署hexo-博客系统&#34;&gt;部署hexo 博客系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Requirement: nodejs&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;安装nodejs&#34;&gt;安装Nodejs&lt;/h3&gt;
&lt;h3 id=&#34;安装hexo&#34;&gt;安装hexo&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install -g hexo-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装pm2&#34;&gt;安装pm2&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install -g pm2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;初始化hexo博客&#34;&gt;初始化hexo博客&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cd /home/
hexo init hexo_blog
cd hexo_blog
#运行hexo
hexo server 
#Ctrl+c 退出
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装hexo-admin-wordpress迁移工具&#34;&gt;安装hexo admin &amp;amp; wordpress迁移工具&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cd /home/hexo_blog
npm install hexo-migrator-wordpress --save
npm install --save hexo-admin
#导入wordpress的备份文件
hexo migrate wordpress *.wordpress.*.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;几款hexo的插件&#34;&gt;几款Hexo的插件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;npm install hexo-generator-feed --save #RSS支持
npm install hexo-generator-baidu-sitemap --save #Baidu站点地图

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考&lt;a href=&#34;https://www.jianshu.com/p/739bf1305e66&#34;&gt;简书&lt;/a&gt;的优化方案&lt;/p&gt;
&lt;h3 id=&#34;hexo使用pm2进行进程守护&#34;&gt;Hexo使用PM2进行进程守护&lt;/h3&gt;
&lt;p&gt;在blog的项目目录下边创建daemon.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var spawn = require(&#39;child_process&#39;).spawn;
free = spawn(&#39;hexo&#39;, [&#39;server&#39;,&#39;-p 18868&#39;]);/* 其实就是等于执行hexo server -p 18868*/
free.stdout.on(&#39;data&#39;, function (data) {
    console.log(&#39;standard output:\n&#39; + data);
});
free.stderr.on(&#39;data&#39;, function (data) {
    console.log(&#39;standard error output:\n&#39; + data);
});
free.on(&#39;exit&#39;, function (code, signal) {
    console.log(&#39;child process eixt ,exit:&#39; + code);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用pm2启动守护进程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pm2 start daemon.js --name=&amp;quot;hexo_blog&amp;quot; #以hexo_blog名字启动hexo
pm2 save    #保存pm2任务列表
pm2 startup #添加pm2开机启动服务
systemctl enable pm2-root.service   #启动pm2开机服务
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;添加nginx转发&#34;&gt;添加Nginx转发&lt;/h3&gt;
&lt;p&gt;配置文件，本文使用的是HTTPS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    listen      443 ssl;
    server_name  blog.istarboy.cc;
    ssl on;
    ssl_certificate   cert/blog.pem;
    ssl_certificate_key  cert/blog.key;
    ssl_session_timeout 5m;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers on;

    #charset koi8-r;
    #access_log  /var/log/nginx/host.access.log  main;
    location / {
        proxy_pass   http://127.0.0.1:18868;
    }

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    # deny access to .htaccess files, if Apache&#39;s document root
    # concurs with nginx&#39;s one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过nginx将请求转发至18868端口，原因是通过httpd ab工具进行压力测试，测试结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@aliyun ~]# ab -c 1000 -n 1000  https://blog.istarboy.cc/2018/11/05/nginx-https中的一些经验/
This is ApacheBench, Version 2.3 &amp;lt;$Revision: 1430300 $&amp;gt;
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking blog.istarboy.cc (be patient)
Completed 100 requests
Completed 200 requests
Completed 300 requests
Completed 400 requests
Completed 500 requests
Completed 600 requests
Completed 700 requests
Completed 800 requests
Completed 900 requests
Completed 1000 requests
Finished 1000 requests


Server Software:        nginx/1.14.0
Server Hostname:        blog.istarboy.cc
Server Port:            443
SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128

Document Path:          /2018/11/05/nginx-https中的一些经验/
Document Length:        270 bytes

Concurrency Level:      1000
Time taken for tests:   12.559 seconds
Complete requests:      1000
Failed requests:        0
Write errors:           0
Non-2xx responses:      1000
Total transferred:      533000 bytes
HTML transferred:       270000 bytes
Requests per second:    79.63 [#/sec] (mean)
Time per request:       12558.737 [ms] (mean)
Time per request:       12.559 [ms] (mean, across all concurrent requests)
Transfer rate:          41.45 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:      401 1060 1153.4    500   10212
Processing:   134  237 256.4    162    2214
Waiting:      134  236 255.7    162    2214
Total:        538 1297 1162.3    951   10359

Percentage of the requests served within a certain time (ms)
  50%    951
  66%   1093
  75%   1383
  80%   1648
  90%   2614
  95%   4220
  98%   4507
  99%   5107
 100%  10359 (longest request)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试1000并发1000请求，因为服务器是使用的加利福尼亚的乞丐配置VPS（贫穷Orz），所以延迟尚可接受，下边是未经过nginx转发的ab测试结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@aliyun ~]# ab -c 1000 -n 1000  http://istarboy.cc:4000/
This is ApacheBench, Version 2.3 &amp;lt;$Revision: 1430300 $&amp;gt;
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking istarboy.cc (be patient)
Completed 100 requests
apr_socket_recv: Connection reset by peer (104)
Total of 151 requests completed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Connection reset by peer!! 服务就崩了，gg，hexo自带的web server扛不住连接数啊。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@aliyun ~]# ab -c 100 -n 1000  http://istarboy.cc:4000/
This is ApacheBench, Version 2.3 &amp;lt;$Revision: 1430300 $&amp;gt;
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking istarboy.cc (be patient)
Completed 100 requests
Completed 200 requests
Completed 300 requests
Completed 400 requests
Completed 500 requests
Completed 600 requests
Completed 700 requests
Completed 800 requests
Completed 900 requests
apr_pollset_poll: The timeout specified has expired (70007)
Total of 999 requests completed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;降低并发到100，依然惨不忍睹，且htop中现实服务器进入高负载的状态，完全不像Nginx转发后的结果，资源占用百分之30 -_-!!  。应该是和nginx的缓存机制有关（Nginx下的负载还和HTTPS有关系）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;++所以博客还是使用Nginx作为前级负载啦～++&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;安全相关配置&#34;&gt;安全相关配置&lt;/h3&gt;
&lt;p&gt;因为博客系统使用的https，同时hexo监听了本地的18868端口，并使用nginx转发了blog二级域名下的http，和https请求到本地的博客系统端口。（http使用了rewrite进行永久重定向到https）但是出现一个安全问题，通过域名/ip直接访问18868端口也是可以直接访问到非https非nginx负载的blog页面的！&lt;em&gt;Orz&lt;/em&gt;、加iptables规则！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;iptables -I INPUT -p tcp --dport 18868 -j DROP  #禁止所有的TCP连接进入18868端口
iptables -I INPUT -p udp --dport 18868 -j DROP  #禁止所有的UDP连接进入18868端口
iptables -I INPUT -s 127.0.0.1 -ptcp --dport 18868 -j ACCEPT    #允许本地TCP访问18868端口
iptables -I INPUT -s 127.0.0.1 -pudp --dport 18868 -j ACCEPT    #允许本地UDP访问18868端口
service iptables save   #保存iptables规则
# 别问我为什么web只需要加tcp就好，我为什么加udp规则，任性。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;规则设置好浏览器打开端口页面超时，服务器测试telnet连接端口超时，规则设置成功。&lt;/p&gt;
&lt;h1 id=&#34;cdn优化方案&#34;&gt;CDN优化方案&lt;/h1&gt;
&lt;p&gt;使用Nginx的GeoIP模块判断ip来源，如果来源为CN，则proxy_pass到CDN的域名上，如果非CN IP则转发至https的本地服务器上。 判断处理在HTTP监听层设计。&lt;/p&gt;
">博客正式搬家了～</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/kubernets-112-install/"" data-c="
          &lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;
&lt;h3 id=&#34;系统要求&#34;&gt;系统要求&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;selinux关闭&lt;/li&gt;
&lt;li&gt;关闭swap&lt;/li&gt;
&lt;li&gt;各主机，节点之间ip和主机名加入/etc/hosts解析&lt;/li&gt;
&lt;li&gt;停用Firewalld&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;安装docker&#34;&gt;安装Docker&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用Docker官网自动化脚本通过阿里云镜像安装&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;手动部署 (Ubuntu)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common
curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository &amp;quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&amp;quot;
sudo apt-get -y update
sudo apt-get -y install docker-ce
# 安装指定版本的Docker-CE:
# Step 1: 查找Docker-CE的版本:
# apt-cache madison docker-ce
#   docker-ce | 17.03.1~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages
#   docker-ce | 17.03.0~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages
# Step 2: 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.1~ce-0~ubuntu-xenial)
# sudo apt-get -y install docker-ce=[VERSION]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;手动部署(Centos)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# step 1: 安装必要的一些系统工具
sudo yum install -y yum-utils device-mapper-persistent-data lvm2
# Step 2: 添加软件源信息
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# Step 3: 更新并安装 Docker-CE
sudo yum makecache fast
sudo yum -y install docker-ce
# Step 4: 开启Docker服务
sudo service docker start

# 注意：
# 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。
# vim /etc/yum.repos.d/docker-ce.repo
#   将 [docker-ce-test] 下方的 enabled=0 修改为 enabled=1
#
# 安装指定版本的Docker-CE:
# Step 1: 查找Docker-CE的版本:
# yum list docker-ce.x86_64 --showduplicates | sort -r
#   Loading mirror speeds from cached hostfile
#   Loaded plugins: branch, fastestmirror, langpacks
#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable
#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable
#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable
#   Available Packages
# Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)
# sudo yum -y install docker-ce-[VERSION]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装指定版本&#34;&gt;安装指定版本&lt;/h2&gt;
&lt;h3 id=&#34;查看docker版本&#34;&gt;查看Docker版本：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;yum list docker-ce --showduplicates&lt;/code&gt;&lt;br&gt;
安装较旧版本（比如Docker 17.03.2) 时需要指定完整的rpm包的包名，并且加上--setopt=obsoletes=0 参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Install docker
# on a new system with yum repo defined, forcing older version and ignoring obsoletes introduced by 17.06.0
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;yum install -y --setopt=obsoletes=0 \
   docker-ce-17.03.2.ce-1.el7.centos.x86_64 \
   docker-ce-selinux-17.03.2.ce-1.el7.centos.noarch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或安装Docker较新版本（比如Docker 18.03.0)时加上rpm包名的版本号部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo yum install docker-ce-18.03.0.ce
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或安装Docker最新版本，无需加版本号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo yum install docker-ce
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置docker加速镜像源-此处为七牛&#34;&gt;配置docker加速镜像源 （此处为七牛）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat &amp;lt;&amp;lt;EOF&amp;gt; /etc/docker/daemon.json
{
    &amp;quot;registry-mirrors&amp;quot;:[&amp;quot;https://reg-mirror.qiniu.com&amp;quot;,&amp;quot;https://gcr-mirror.qiniu.com&amp;quot;,&amp;quot;https://quay-mirror.qiniu.com&amp;quot;]
}
EOF
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;阿里云&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&#39;EOF&#39;
{
  &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://3me95jt4.mirror.aliyuncs.com&amp;quot;]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装kubelet-kubeadm-kubectl&#34;&gt;安装kubelet kubeadm kubectl&lt;/h3&gt;
&lt;h5 id=&#34;k8s部署过程中的三大工具&#34;&gt;k8s部署过程中的三大工具&lt;/h5&gt;
&lt;p&gt;kubelet： k8s的服务程序&lt;/p&gt;
&lt;p&gt;kubeadm:  k8s集群创建以及部署工具&lt;/p&gt;
&lt;p&gt;kubectl:  k8s集群的控制交互程序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Debian/Ubuntu&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;apt-get update &amp;amp;&amp;amp; apt-get install -y apt-transport-https
curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - 
cat &amp;lt;&amp;lt;EOF &amp;gt;/etc/apt/sources.list.d/kubernetes.list
deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main
EOF  
apt-get update
apt-get install -y kubelet kubeadm kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Centos/RHEL/Fedora&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
setenforce 0
yum install -y kubelet kubeadm kubectl
systemctl enable kubelet &amp;amp;&amp;amp; systemctl start kubelet
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;部署k8s集群&#34;&gt;部署k8s集群&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;kubeadm init --kubernetes-version=v1.12.1 --pod-network-cidr=10.244.0.0/16
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
kubectl apply -f https://docs.projectcalico.org/v3.0/getting-started/kubernetes/installation/hosted/kubeadm/1.7/calico.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意网络插件的使用，整理这篇文章&lt;/p&gt;
&lt;p&gt;http://www.cnblogs.com/RainingNight/p/using-kubeadm-to-create-a-cluster-1-12.html&lt;/p&gt;
">Kubernets 1.12的安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/mysqlmariadbji-qun-ce-shi/"" data-c="
          &lt;p&gt;测试MariaDB搭建集群&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;测试环境：Vmware （Centos 7 x3）&lt;/p&gt;
&lt;h3 id=&#34;1修改centos的软件源添加mariadb的软件源并安装mariadb-galera-server&#34;&gt;1.修改Centos的软件源，添加MariaDB的软件源，并安装MariaDB-Galera-server&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@www ~]# vi /etc/yum.repos.d/mariadb.repo
# MariaDB 10.0 CentOS repository list
# http://mariadb.org/mariadb/repositories/
[mariadb]
name = MariaDB
baseurl = http://yum.mariadb.org/10.0/centos7-amd64
gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB
gpgcheck=1
enabled=0
[root@www ~\]# yum --enablerepo=mariadb -y install MariaDB-Galera-server
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2修改主控节点&#34;&gt;2.修改主控节点&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/my.cnf.d/server.cnf
[galera]
# Mandatory settings
wsrep_provider=/usr/lib64/galera/libgalera_smm.so
# specify all nodes in cluster
wsrep_cluster_address=&amp;quot;gcomm://10.0.0.31,10.0.0.51&amp;quot;
# uncomment all
binlog_format=row
default_storage_engine=InnoDB
innodb_autoinc_lock_mode=2
bind-address=0.0.0.0
# add follows
# cluster name
wsrep_cluster_name=&amp;quot;MariaDB_Cluster&amp;quot;
# own IP address
wsrep_node_address=&amp;quot;10.0.0.31&amp;quot;
# replication provider
wsrep_sst_method=rsync
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动数据库集群主控端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; [root@www ~]# /etc/rc.d/init.d/mysql bootstrap
Bootstrapping the cluster.. Starting MySQL.. SUCCESS!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初始化数据库(只需要在主控端进行）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@www ~]# mysql_secure_installation
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3配置数据节点依次配置每个节点&#34;&gt;3.配置数据节点(依次配置每个节点）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;vim /etc/my.cnf.d/server.cnf
\[galera\]
\# Mandatory settings
wsrep\_provider=/usr/lib64/galera/libgalera\_smm.so
\# specify all nodes in cluster
wsrep\_cluster\_address=&amp;quot;gcomm://10.0.0.31,10.0.0.51&amp;quot;
\# uncomment all
binlog_format=row
default\_storage\_engine=InnoDB
innodb\_autoinc\_lock_mode=2
bind-address=0.0.0.0
\# add follows
\# cluster name
wsrep\_cluster\_name=&amp;quot;MariaDB_Cluster&amp;quot;
\# own IP address
wsrep\_node\_address=&amp;quot;10.0.0.51&amp;quot;
\# replication provider
wsrep\_sst\_method=rsync
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动节点数据库服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\[root@node01 ~\]# systemctl start mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.集群搭建基本完成 下面进行测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\[root@node01 ~\]# mysql -u root -p
Enter password:
Welcome to the MariaDB monitor.  Commands end with ; or \\g.
Your MariaDB connection id is 6
Server version: 10.0.20-MariaDB-wsrep MariaDB Server, wsrep_25.10.r4144
Copyright (c) 2000, 2015, Oracle, MariaDB Corporation Ab and others.
Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.
MariaDB \[(none)\]&amp;gt; show status like &#39;wsrep_%&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据库回显：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MariaDB \[(none)\]&amp;gt; show status like &#39;wsrep_%&#39;;
+------------------------------+--------------------------------------+
| Variable_name                | Value                                |
+------------------------------+--------------------------------------+
| wsrep\_local\_state_uuid       | 20329169-3414-11e5-9285-cab5ed757f81 |
| wsrep\_protocol\_version       | 7                                    |
| wsrep\_last\_committed         | 3                                    |
| wsrep_replicated             | 0                                    |
| wsrep\_replicated\_bytes       | 0                                    |
| wsrep\_repl\_keys              | 0                                    |
| wsrep\_repl\_keys_bytes        | 0                                    |
| wsrep\_repl\_data_bytes        | 0                                    |
| wsrep\_repl\_other_bytes       | 0                                    |
| wsrep_received               | 3                                    |
| wsrep\_received\_bytes         | 237                                  |
| wsrep\_local\_commits          | 0                                    |
| wsrep\_local\_cert_failures    | 0                                    |
| wsrep\_local\_replays          | 0                                    |
| wsrep\_local\_send_queue       | 0                                    |
| wsrep\_local\_send\_queue\_max   | 2                                    |
| wsrep\_local\_send\_queue\_min   | 0                                    |
| wsrep\_local\_send\_queue\_avg   | 0.333333                             |
| wsrep\_local\_recv_queue       | 0                                    |
| wsrep\_local\_recv\_queue\_max   | 1                                    |
| wsrep\_local\_recv\_queue\_min   | 0                                    |
| wsrep\_local\_recv\_queue\_avg   | 0.000000                             |
| wsrep\_local\_cached_downto    | 18446744073709551615                 |
| wsrep\_flow\_control\_paused\_ns | 0                                    |
| wsrep\_flow\_control_paused    | 0.000000                             |
| wsrep\_flow\_control_sent      | 0                                    |
| wsrep\_flow\_control_recv      | 0                                    |
| wsrep\_cert\_deps_distance     | 0.000000                             |
| wsrep\_apply\_oooe             | 0.000000                             |
| wsrep\_apply\_oool             | 0.000000                             |
| wsrep\_apply\_window           | 0.000000                             |
| wsrep\_commit\_oooe            | 0.000000                             |
| wsrep\_commit\_oool            | 0.000000                             |
| wsrep\_commit\_window          | 0.000000                             |
| wsrep\_local\_state            | 4                                    |
| wsrep\_local\_state_comment    | Synced                               |
| wsrep\_cert\_index_size        | 0                                    |
| wsrep\_causal\_reads           | 0                                    |
| wsrep\_cert\_interval          | 0.000000                             |
| wsrep\_incoming\_addresses     | 10.0.0.31:3306,10.0.0.51:3306        |
| wsrep\_evs\_delayed            |                                      |
| wsrep\_evs\_evict_list         |                                      |
| wsrep\_evs\_repl_latency       | 0/0/0/0/0                            |
| wsrep\_evs\_state              | OPERATIONAL                          |
| wsrep\_gcomm\_uuid             | 69d7b95d-3415-11e5-9666-7be9d4b6159d |
| wsrep\_cluster\_conf_id        | 2                                    |
| wsrep\_cluster\_size           | 2                                    |
| wsrep\_cluster\_state_uuid     | 20329169-3414-11e5-9285-cab5ed757f81 |
| wsrep\_cluster\_status         | Primary                              |
| wsrep_connected              | ON                                   |
| wsrep\_local\_bf_aborts        | 0                                    |
| wsrep\_local\_index            | 1                                    |
| wsrep\_provider\_name          | Galera                               |
| wsrep\_provider\_vendor        | Codership Oy &amp;lt;info@codership.com&amp;gt;    |
| wsrep\_provider\_version       | 25.3.9(r3387)                        |
| wsrep_ready                  | ON                                   |
| wsrep\_thread\_count           | 2                                    |
+------------------------------+--------------------------------------+
57 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;*wsrep_local_state_comment | Synced *&lt;br&gt;
表示数据库同步正常&lt;br&gt;
可以对其中的一个节点数据库进行增删改 然后经由其他节点进行查看 同步正常&lt;/p&gt;
&lt;h3 id=&#34;写在最后&#34;&gt;写在最后：&lt;/h3&gt;
&lt;p&gt;本次Blog是经过测试&lt;/p&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;http://www.server-world.info/en/note?os=CentOS_7&amp;amp;p=mariadb&amp;amp;f=4 https://v2ex.com/t/202975 http://galeracluster.com/documentation-webpages/?id=mysql_galera_configuration&lt;/p&gt;
&lt;h3 id=&#34;ps&#34;&gt;PS：&lt;/h3&gt;
&lt;p&gt;v2ex教材待测试 同时尝试将集群做到Docker内作为应用打包方案 以及Debian的尝试部署&lt;/p&gt;
">Mysql（mariadb）集群测试</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/chu-xue-python-o_o/"" data-c="
          &lt;p&gt;Python练习一波&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;练习之前应该知道的&#34;&gt;练习之前应该知道的&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Linux命令行将以 \$ 开始，比如 \$ls, $python&lt;/li&gt;
&lt;li&gt;Python命令行将以 &amp;gt;&amp;gt;&amp;gt; 开始，比如 &amp;gt;&amp;gt;&amp;gt;print &#39;Hello World!&#39;&lt;/li&gt;
&lt;li&gt;注释会以 # 开始&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一shell界面输入python可以进入python执行状态&#34;&gt;一.Shell界面输入python可以进入python执行状态&lt;/h3&gt;
&lt;h5 id=&#34;&#34;&gt;&lt;img src=&#34;http://blog.istarboy.cc/wp-content/uploads/2016/02/mm-300x51.png&#34; alt=&#34;mm&#34; loading=&#34;lazy&#34;&gt;&lt;/h5&gt;
&lt;p&gt;然后可以执行相关内容。&lt;/p&gt;
&lt;h3 id=&#34;二printhello-world&#34;&gt;二.&amp;gt;&amp;gt;&amp;gt;print(&#39;Hello World!&#39;)&lt;/h3&gt;
&lt;p&gt;print是一个常用函数，其功能就是输出括号中得字符串。 直接在python解释器状态运行会输出Hello World! 也可以写入py文件使用python *.py运行程序，在py文件头加上 #!/usr/bin/env python  可以直接进行chmod +x &lt;em&gt;.py ./&lt;/em&gt;.py执行测试脚本。&lt;/p&gt;
&lt;h3 id=&#34;三变量&#34;&gt;三.变量&lt;/h3&gt;
&lt;p&gt;Python的变量不需要声明，你可以直接输入：a = 10 那么内存里就有了一个变量a， 它的值是10，它的类型是integer (整数)。无需声明，数据类型是Python自动决定的。print type(a)可以显示a变量的数据类型。&lt;/p&gt;
&lt;h3 id=&#34;四数据类型&#34;&gt;四.数据类型&lt;/h3&gt;
&lt;p&gt;变量&lt;/p&gt;
&lt;p&gt;数据类型&lt;/p&gt;
&lt;p&gt;a=10&lt;/p&gt;
&lt;p&gt;int 整数&lt;/p&gt;
&lt;p&gt;a=1.3&lt;/p&gt;
&lt;p&gt;float 浮点数&lt;/p&gt;
&lt;p&gt;a=True&lt;/p&gt;
&lt;p&gt;真值(True/False)&lt;/p&gt;
&lt;p&gt;a=&#39;Hello!&#39;&lt;/p&gt;
&lt;p&gt;字符串&lt;/p&gt;
&lt;h3 id=&#34;五序列&#34;&gt;五.序列&lt;/h3&gt;
&lt;p&gt;sequence(序列)是一组&lt;strong&gt;有顺序&lt;/strong&gt;的&lt;strong&gt;元素&lt;/strong&gt;的&lt;strong&gt;集合&lt;/strong&gt; (严格的说，是对象的集合，但鉴于我们还没有引入“对象”概念，暂时说元素) 序列可以包含一个或多个&lt;strong&gt;元素&lt;/strong&gt;，也可以没有任何元素。 我们之前所说的基本数据类型，都可以作为序列的元素。元素还可以是另一个序列，以及我们以后要介绍的其他对象。 序列有两种：tuple（&lt;strong&gt;定值表&lt;/strong&gt;； 也有翻译为&lt;strong&gt;元组&lt;/strong&gt;） 和 list (&lt;strong&gt;表&lt;/strong&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;s1 = (2, 1.3, &#39;love&#39;, 5.6, 9, 12, False)         # s1是一个tuple
&amp;gt;&amp;gt;&amp;gt;s2 = [True, 5, &#39;smile&#39;]                          # s2是一个list
&amp;gt;&amp;gt;&amp;gt;print s1,type(s1)
&amp;gt;&amp;gt;&amp;gt;print s2,type(s2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tuple和list的主要区别在于，一旦建立，&lt;strong&gt;tuple的各个元素不可再变更，而list的各个元素可以再变更&lt;/strong&gt;。 一个序列作为另一个序列的元素：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;s3 = [1,[3,4,5]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;空序列：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;s4 = []
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;1-元素的引用&#34;&gt;1、元素的引用&lt;/h3&gt;
&lt;p&gt;序列元素的下标从0开始：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;print s1[0]
&amp;gt;&amp;gt;&amp;gt;print s2[2]
&amp;gt;&amp;gt;&amp;gt;print s3[1][2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于list的元素可变更，你可以对list的某个元素赋值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;s2[1] = 3.0
&amp;gt;&amp;gt;&amp;gt;print s2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你对tuple做这样的操作，会得到错误提示。 所以，可以看到，序列的引用通过s[int]实现，(int为下标)。&lt;/p&gt;
&lt;h3 id=&#34;2-其他引用方式&#34;&gt;2、其他引用方式&lt;/h3&gt;
&lt;p&gt;范围引用： 基本样式 &lt;strong&gt;[下限:上限:步长]&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;print s1[:5]             # 从开始到下标4 （下标5的元素 不包括在内）
&amp;gt;&amp;gt;&amp;gt;print s1[2:]             # 从下标2到最后
&amp;gt;&amp;gt;&amp;gt;print s1[0:5:2]          # 从下标0到下标4 (下标5不包括在内)，每隔2取一个元素 （下标为0，2，4的元素）
&amp;gt;&amp;gt;&amp;gt;print s1[2:0:-1]         # 从下标2到下标1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面可以看到，在范围引用的时候，如果写明上限，那么&lt;strong&gt;这个上限本身不包括在内&lt;/strong&gt;。 尾部元素引用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;print s1[-1]             # 序列最后一个元素
&amp;gt;&amp;gt;&amp;gt;print s1[-3]             # 序列倒数第三个元素
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样，如果s1[0:-1], 那么最后一个元素不会被引用 （再一次，&lt;strong&gt;不包括上限元素本身&lt;/strong&gt;）。&lt;/p&gt;
&lt;h3 id=&#34;3-字符串是元组&#34;&gt;3、字符串是元组&lt;/h3&gt;
&lt;p&gt;字符串是一种特殊的元素，因此可以执行元组的相关操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;str = &#39;abcdef&#39;
&amp;gt;&amp;gt;&amp;gt;print str[2:4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;六-运算&#34;&gt;六、运算&lt;/h2&gt;
&lt;h3 id=&#34;1-数学运算&#34;&gt;1、数学运算&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;print 1+9        # 加法
&amp;gt;&amp;gt;&amp;gt;print 1.3-4      # 减法
&amp;gt;&amp;gt;&amp;gt;print 3*5        # 乘法
&amp;gt;&amp;gt;&amp;gt;print 4.5/1.5    # 除法
&amp;gt;&amp;gt;&amp;gt;print 3**2       # 乘方     
&amp;gt;&amp;gt;&amp;gt;print 10%3       # 求余数
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-判断&#34;&gt;2、判断&lt;/h3&gt;
&lt;p&gt;判断是真还是假，返回True/False:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;print 5==6               # =， 相等
&amp;gt;&amp;gt;&amp;gt;print 8.0!=8.0           # !=, 不等
&amp;gt;&amp;gt;&amp;gt;print 3&amp;lt;3, 3&amp;lt;=3          # &amp;lt;, 小于; &amp;lt;=, 小于等于
&amp;gt;&amp;gt;&amp;gt;print 4&amp;gt;5, 4&amp;gt;=0          # &amp;gt;, 大于; &amp;gt;=, 大于等于
&amp;gt;&amp;gt;&amp;gt;print 5 in [1,3,5]       # 5是list [1,3,5]的一个元素
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;还有is, is not等, 暂时不深入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-逻辑运算&#34;&gt;3、逻辑运算&lt;/h3&gt;
&lt;p&gt;True/False之间的运算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;print True and True, True and False      # and, “与”运算， 两者都为真才是真
&amp;gt;&amp;gt;&amp;gt;print True or False                      # or, &amp;quot;或&amp;quot;运算， 其中之一为真即为真
&amp;gt;&amp;gt;&amp;gt;print not True                           # not, “非”运算， 取反
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以和上一部分结合做一些练习，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;print 5==6 or 3&amp;gt;=3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;七-缩进和选择&#34;&gt;七、缩进和选择&lt;/h2&gt;
&lt;h3 id=&#34;1-缩进&#34;&gt;1、缩进&lt;/h3&gt;
&lt;p&gt;Python最具特色的是用缩进来标明成块的代码。我下面以if选择结构来举例。if后面跟随条件，如果条件成立，则执行归属于 if 的一个代码块。 先看C语言的表达方式（注意，&lt;strong&gt;这是C，不是Python!&lt;/strong&gt;）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if ( i &amp;gt; 0 )
{
    x = 1;
    y = 2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果i &amp;gt; 0的话，我们将进行括号中所包括的两个赋值操作。括号中包含的就是块操作，它隶属于if。 在Python中，同样的目的，这段话是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if i &amp;gt; 0:
    x = 1
    y = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在Python中， 去掉了i &amp;gt; 0周围的括号，去除了每个语句句尾的分号，表示块的花括号也消失了。 多出来了if ...之后的 &lt;strong&gt;:(冒号)&lt;/strong&gt;, 还有就是x = 1 和 y =2前面有&lt;strong&gt;四个空格的缩进&lt;/strong&gt;。通过缩进，Python识别出这两个语句是隶属于if。 Python这样设计的理由纯粹是为了程序好看。&lt;/p&gt;
&lt;h3 id=&#34;2-if语句&#34;&gt;2、if语句&lt;/h3&gt;
&lt;p&gt;写一个完整的程序，命名为ifDemo.py。这个程序用于实现if结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i = 1
x = 1
if i &amp;gt; 0:
    x = x+1
print x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用cd命令进入该文件所在目录，然后输入命令运行它：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$python ifDemo.py  # 运行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;程序运行到 if 的时候，条件为True，因此执行&lt;strong&gt;x = x+1&lt;/strong&gt;。 &lt;strong&gt;print x&lt;/strong&gt;语句没有缩进，那么就是if之外。 如果将第一句改成i = -1，那么 if 遇到假值 (False), &lt;strong&gt;x = x+1&lt;/strong&gt;隶属于 if , 这一句跳过。&lt;strong&gt;print x&lt;/strong&gt;没有缩进，是 if 之外，不跳过，继续执行。 这种以&lt;strong&gt;四个空格&lt;/strong&gt;的缩进来表示&lt;strong&gt;隶属关系&lt;/strong&gt;的书写方式，以后还会看到。强制缩进增强了程序的&lt;strong&gt;可读性&lt;/strong&gt;。 复杂一些的 if 选择：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i = 1
if i &amp;gt; 0:
    print &#39;positive i&#39;
    i = i + 1
elif i == 0:
    print &#39;i is 0&#39;
    i = i * 10
else:
    print &#39;negative i&#39;
    i = i - 1
print &#39;new i:&#39;,i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有三个块，分别属于&lt;strong&gt;if，elif，else&lt;/strong&gt;引领。 Python检测条件，如果发现 if 的条件为假，那么跳过后面紧跟的块，检测下一个 elif 的条件； 如果还是假，那么执行else块。 通过上面的结构将程序分出三个分支。程序根据条件，只执行三个分支中的一个。 整个 if 可以放在另一个 if 语句中，也就是 if 结构的嵌套使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i  = 5
if i &amp;gt; 1:
    print &#39;i bigger than 1&#39;
    print &#39;good&#39;
    if i &amp;gt; 2:
        print &#39;i bigger than 2&#39;
        print &#39;even better&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if i &amp;gt; 2 后面的块相对于该 if 缩进了四个空格，以表明其隶属于该 if ，而不是外层的 if 。&lt;/p&gt;
">初学Python o(∩_∩)o 、</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/ubuntu-an-zhuang-hou-de-you-hua-blabla/"" data-c="
          &lt;p&gt;记一次Ubuntu安装后的决心总结&lt;/p&gt;
&lt;!--more--&gt;
&lt;h4 id=&#34;各种发行版的ubuntu-应该执行的优化操作-备忘记录&#34;&gt;各种发行版的Ubuntu 应该执行的优化操作  备忘记录&lt;/h4&gt;
&lt;p&gt;PS：为了避免官方源的不定期大姨妈 可以换软件源为CQU或者Ali-OSM&lt;/p&gt;
&lt;h1 id=&#34;1删除libreoffice&#34;&gt;1.删除libreoffice&lt;/h1&gt;
&lt;p&gt;libreoffice虽然是开源的，但是Java写出来的office执行效率实在不敢恭维，装完系统后果断删掉&lt;/p&gt;
&lt;p&gt;sudo apt-get remove libreoffice-common&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h1 id=&#34;2删除amazon的链接&#34;&gt;2.删除Amazon的链接&lt;/h1&gt;
&lt;p&gt;sudo apt-get remove unity-webapps-common&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h1 id=&#34;3删掉基本不用的自带软件用的时候再装也来得及&#34;&gt;3.删掉基本不用的自带软件（用的时候再装也来得及）&lt;/h1&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku  landscape-client-ui-install&lt;/p&gt;
&lt;p&gt;sudo apt-get remove onboard deja-dup&lt;/p&gt;
&lt;p&gt;这样系统就基本上干净了。&lt;/p&gt;
&lt;h1 id=&#34;4安装vim&#34;&gt;4.安装Vim&lt;/h1&gt;
&lt;p&gt;居然默认没有集成Vim神器，只能手动安装了。&lt;/p&gt;
&lt;p&gt;sudo apt-get install vim&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h1 id=&#34;5设置时间使用utc&#34;&gt;5.设置时间使用UTC&lt;/h1&gt;
&lt;p&gt;sudo vim /etc/default/rcS&lt;/p&gt;
&lt;p&gt;将UTC=no改为UTC=yes&lt;/p&gt;
&lt;h1 id=&#34;6安装chrome&#34;&gt;6.安装Chrome&lt;/h1&gt;
&lt;p&gt;到 https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 下载最新的安装文件。 然后&lt;/p&gt;
&lt;p&gt;sudo apt-get install libappindicator1 libindicator7&lt;br&gt;
sudo dpkg -i google-chrome-stable_current_amd64.deb&lt;br&gt;
sudo apt-get -f install&lt;/p&gt;
&lt;p&gt;这样以后就可以apt安装和更新chrome浏览器了。&lt;/p&gt;
&lt;h1 id=&#34;7安装搜狗输入法&#34;&gt;7.安装搜狗输入法&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;//有毒 不要安装&lt;/strong&gt; 在mint的输入法控制台启用fctix 然后安装下边插件 sudo apt-get install fcitx-googlepinyin 可以使用谷歌拼音 vim /etc/apt/sources.list.d/ubuntukylin.list文件，加入ubuntu kylin的apt源&lt;/p&gt;
&lt;p&gt;deb http://archive.ubuntukylin.com:10006/ubuntukylin trusty main&lt;/p&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;p&gt;//sudo apt-get update&lt;br&gt;
//sudo apt-get install sogoupinyin&lt;/p&gt;
&lt;p&gt;这样就可以apt安装和更新搜狗输入法了。&lt;/p&gt;
&lt;h1 id=&#34;8安装wps-office&#34;&gt;8.安装WPS Office&lt;/h1&gt;
&lt;p&gt;目前MS一直不出Linux版的Office，只能凑合着用WPS了&lt;/p&gt;
&lt;p&gt;sudo apt-get install wps-office&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h1 id=&#34;9安装oracle-java&#34;&gt;9.安装Oracle Java&lt;/h1&gt;
&lt;p&gt;sudo add-apt-repository ppa:webupd8team/java&lt;br&gt;
sudo apt-get update&lt;br&gt;
sudo apt-get install oracle-java8-installer&lt;/p&gt;
&lt;p&gt;由于系统自带的是OpenJDK，卸载OpenJDK之后会带有残留，导致运行&lt;/p&gt;
&lt;p&gt;java -version&lt;/p&gt;
&lt;p&gt;时第一行不是java的版本号，会是Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar这个提示，导致很多检测java版本号的脚本会运行出错，因此需要手动清除残留。&lt;/p&gt;
&lt;p&gt;sudo rm /usr/share/upstart/sessions/jayatana.conf&lt;/p&gt;
&lt;p&gt;删除/usr/share/upstart/sessions/jayatana.conf文件，重启之后再运行java -version就不会再有Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar提示了。&lt;/p&gt;
&lt;h1 id=&#34;10安装sublime-text-3&#34;&gt;10.安装Sublime Text 3&lt;/h1&gt;
&lt;p&gt;sudo add-apt-repository ppa:webupd8team/sublime-text-3&lt;br&gt;
sudo apt-get update&lt;br&gt;
sudo apt-get install sublime-text&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h1 id=&#34;11安装git和vpnc&#34;&gt;11.安装git和vpnc&lt;/h1&gt;
&lt;p&gt;git和vpn大家都懂的，程序员的好工具。&lt;/p&gt;
&lt;p&gt;sudo apt-get install vpnc git&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h1 id=&#34;12安装axel&#34;&gt;12.安装axel&lt;/h1&gt;
&lt;p&gt;axel是Linux命令行界面的多线程下载工具，比wget的好处就是可以指定多个线程同时在命令行终端里下载文件。&lt;/p&gt;
&lt;p&gt;sudo apt-get install axel&lt;/p&gt;
&lt;p&gt;安装之后，就可以代替wget用多线程下载了。&lt;/p&gt;
&lt;h1 id=&#34;13安装openssh-server&#34;&gt;13.安装openssh-server&lt;/h1&gt;
&lt;p&gt;sudo apt-get install openssh-server&lt;/p&gt;
&lt;p&gt;安装之后，就可以在Win下用ssh工具远程登陆了，当然也多了一个安全隐患，如果不想远程登陆本机的话，可以不装openssh-server。&lt;/p&gt;
&lt;h1 id=&#34;14安装cmake和qt-creator&#34;&gt;14.安装CMake和Qt Creator&lt;/h1&gt;
&lt;p&gt;CMake和Qt Creator是Linux下开发C++程序的神器，Ubuntu 15.04已经集成了最新版的Qt Creator （3.1.1）。&lt;/p&gt;
&lt;p&gt;sudo apt-get install cmake qtcreator&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h1 id=&#34;15安装exfat文件系统驱动&#34;&gt;15.安装ExFat文件系统驱动&lt;/h1&gt;
&lt;p&gt;Ubuntu默认不支持exFat文件系统的挂载，需要手动安装exfat的支持&lt;/p&gt;
&lt;p&gt;sudo apt-get install exfat-fuse&lt;/p&gt;
&lt;p&gt;装上exfat-fuse之后就可以挂载exfat分区的磁盘了。&lt;/p&gt;
&lt;h1 id=&#34;16安装lnav&#34;&gt;16.安装lnav&lt;/h1&gt;
&lt;p&gt;lnav工具是在终端界面看日志的神器&lt;/p&gt;
&lt;p&gt;sudo apt-get install lnav&lt;/p&gt;
&lt;p&gt;装上之后在终端里就可以用lnav彩色显示日志了。&lt;/p&gt;
&lt;h1 id=&#34;17安装unrar&#34;&gt;17.安装unrar&lt;/h1&gt;
&lt;p&gt;系统默认不带解压缩rar文件的功能，手动安装unrar程序&lt;/p&gt;
&lt;p&gt;sudo apt-get install unrar&lt;/p&gt;
&lt;p&gt;装上之后就可以用命令解压缩rar文件了。 使用如下命令解压缩文件到当前目录。&lt;/p&gt;
&lt;p&gt;unrar x test.rar&lt;/p&gt;
&lt;h1 id=&#34;18php环境配置&#34;&gt;18.PHP环境配置&lt;/h1&gt;
&lt;p&gt;sudo apt-get intstall php5 php5-dev php5-xdebug php5-cli php-pear  libpcre3-dev libpcre3 curl gcc g++ -y sudo pecl install swoole&lt;/p&gt;
">Ubuntu安装后的优化blabla···</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/guan-yu-ping-mu-na-xie-shi/"" data-c="
          &lt;p&gt;屏幕的参数的一篇爬文 ，无意义&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;今天闲来无事又开始乱看51nb，然后看了某DC2屏幕与普通IPS的对比，感觉已经中毒。&lt;/p&gt;
&lt;p&gt;开始详细了解 √&lt;/p&gt;
&lt;p&gt;DC1是8BIT的屏幕，DC2是10BIT的屏，与普通屏幕就是色域上的区别。&lt;/p&gt;
&lt;p&gt;以下色域的资料：&lt;/p&gt;
&lt;p&gt;色域（Color Space)，又被称为色彩空间，它代表了一个色彩影像所能表现RGB色彩空间的色彩具体情况。&lt;/p&gt;
&lt;p&gt;我们经常用到的色彩空间主要有RGB、CMYK、Lab等，而RGB色彩空间又有AdobeRGB、AppleRGB、sRGB等几种，这些RGB色彩空间大多与显示设备、输入设备（数码相机、扫描仪）相关联。&lt;/p&gt;
&lt;p&gt;Adobe RGB与sRGB则是我们最为常见的，也是目前数码相机中重要的设置。 Adobe RGB是由Adobe公司推出的色域标准，sRGB是由惠普与微软公司于1977年共同开发的，其中“S”可解释为“标准”（Standard)。&lt;/p&gt;
&lt;p&gt;Adobe RGB较之sRGB有更宽广的色彩空间，它包含了sRGB所没有的CMYK色域，层次较丰富，但色彩饱和较低。如果希望在最终的摄影作品中精细调整色彩饱和度，可选择Adobe RGB模式。&lt;/p&gt;
&lt;p&gt;若将由Adobe RGB模式拍摄的图像更改为sRGB模式的，影像的色彩会有所损失。但由于其色域较广，所以影像的色彩还会真实地反应出来。若将sRGB模式拍摄的影像转换为Adobe RGB模式的，由于sRGB本身色域较窄，实际上并没有什么变化，而我们所见到的色彩改变，其实只是输出装置的模拟色彩。 因为sRGB拥有较小的色域空间，所以不建议专业的印前用户使用，它主要应用在网页浏览等。&lt;/p&gt;
&lt;p&gt;目前，微软与惠普发表了sRGB64，这样在色彩调整及转换时会保存信息以备以后使用。而Adobe RGB具备非常大的色域空间，对以后在输出及分色有极大的优势和便利性，应用更为广泛。 普通消费级数码相机中多以sRGB做为相机内的色域标准，从而使所拍图像在不需要加工的情况下能在显示器或打印机等输出装置中展示其本来面目。&lt;/p&gt;
&lt;p&gt;而高档或单反数码相机则提供了Adobe RGB和sRGB两种色域选择。如佳能EOS 20D、柯尼卡美能达DiMAGEA2/A1等，而尼康D70则设有Ia（sRGB）、II（Adobe RGB）、IIIa（sRGB）三种选择，其中Ia（sRGB）适合拍摄人像使用，可表现较自然的肤色；而IIIa（sRGB）适合拍摄风景及花卉，调校更真实的艳丽色彩。 作为类比，你可以试想三个颜色（红绿蓝）被投射到一堵白色的墙上，当这些同样密度的光叠加在一起就产生了白色，而当你只投射绿色和红色时，你会看到墙变成了黄色。把这三种颜色的光按不同的方法叠加会生成各种不同颜色的光，再举一个例子，当你在墙上投射红色和绿色时，墙就会变成桔黄色。 一句话，我们所看到的各种颜色的光就是由这三种颜色叠合而成的，所有可能的颜色的集合就是我们所说的“色域”。&lt;/p&gt;
&lt;p&gt;不同的人识别“RGB色彩空间”里的颜色和光线的能力是很相似的，但并不完全一致。“RGB色彩空间”中也有各种模式，我们最常见的有sRGB和Adobe RGB，这两者中sRGB应用的更广一点，它在过去的一个世纪中被广泛的使用在数码相机，高清相机，高清视频和电脑显示中，换句话说就是它就是电子产品采用或支持的色彩模式。它在上个世纪90年代由Hewlett Packard同微软公司一起制定这种模式的相关规则，其中“s”就代表了“标准”，它至今还是我们现在通用的标准。&lt;/p&gt;
&lt;p&gt;sRGB最主要的缺点就是色域很有限（它所能包容的颜色虽然已然我们所能识别的范围之外，但是在有些时候，它还是太小了-译者），在这个时候Adobe就推出了自己的RGB模式标准–Adobe RGB，它在色域上超过sRGB很多，相当于在给sRGB套上了一个外套，Adobe甚至后来又推出了Adobe Wide gamut RGB，它包含的颜色更多，然而我们平时并不需要这么多颜色，通常我们只会在平面设计和中高档数码相机里才用到它们。&lt;/p&gt;
&lt;p&gt;下面，我再来说一下NTSC是什么。 人眼所能看到的光线称之为可见光，在光谱图上可以知道可见光谱是波长从380nm到780nm之间的光线，而通过R红、G绿、B蓝这三种颜色的混合，可以得到近似于全部可见光谱范围内的光线，目前所使用绝大多数彩色显示器，不管是LEDT、CRT、LCD、PDP、DLP还是其他什么，都是基于三原色成像。而NTSC制式，是1952年12月由美国国家电视标准委员会（National Television System Committee，缩写为NTSC）制定的彩色电视广播标准。一般电视色域是72%，广色域的92%即达广色域标准，因为他牌的计算方式为92%除以72%等于127%，因而号称广色域达130%，其实就是92%。 彩色影像是由蓝、绿、红三原色依不同比例及加上亮度混合而成，10位之影像是由蓝绿红各1024阶层组合而成，可产生1024×1024×1024＝10.7亿之颜色组合，比起8位256×256×256＝16.7百万色，足足多出了64倍之颜色组合。&lt;/p&gt;
&lt;p&gt;10位之色彩加上灰阶，在影像分辨率比8位之分辨率至少好上4倍。 今日的显示器的色域归类为三种类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;AdobeRGB 色域&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;sRGB 色域&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;和 sRGB 色域相同或更高但低于AdobeRGB 色域 红色的三角锥为AdobeRGB的色域空间，蓝色三角锥为sRGB的色域空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第三个类型的色域为 NTSC 的标准色域,它被使用在影音、TV和其他设备。绿色的三角锥涵盖了92% NTSC 的色域。在图像里显示的 JMPA 色域为典型的CMYK 色域。颜色色域必须跟使用者的目的和环境相互一致。尤其， 为了完整呈现AdobeRGB 和 CMYK 色域的再现性，显示器需要对应 AdobeRGB 的色域 。即使显示器只涵盖了NTSC 92%的色域无法正确地显示出AdobeRGB的鲜绿色和CMYK特别的黄色。&lt;/p&gt;
&lt;p&gt;所以所谓广色域技术是最近显示器的热点，广色域顾名思意就是比一般的显示器能显示更多的颜色。现在一般提升色域的手段是采用LED背光模组，相比现在广泛采用的使用CCFL光源的背光模组，LED光源的白光更纯，所以透过CF彩色滤光片能表现更丰富的颜色。&lt;/p&gt;
&lt;p&gt;一般使用LED背光的显示器的色域能超过100%NTSC色域。一般使用CCFL背光的显示器只能达到一般sRGB色域，色域越高，显示器所能显示的图片就越接近自然。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.RGB是RED（红），Green（绿），Blue（蓝）这三 种基色的首字母缩写。&lt;/li&gt;
&lt;li&gt;2.“RGB色彩空间”是泛指在硬件和软件里用到的“所有颜色”&lt;/li&gt;
&lt;li&gt;3.sRGB 是RGB是一种的一种特定类型。&lt;/li&gt;
&lt;li&gt;4.sRGB很流行，但它的色域很有限&lt;/li&gt;
&lt;li&gt;5.色域越高越好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PS 以上资料，来源于网络，本人只是摘录总结了一下，如有不对，欢迎指正，请轻拍砖&lt;/strong&gt;&lt;/p&gt;
">关于屏幕那些事···</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/kai-fa-zhe-ji-ben-su-yang/"" data-c="
          &lt;p&gt;开发者三条要诀&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;使用开发者系统的时候时刻牢记：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a.命令行优于图形界面&lt;/li&gt;
&lt;li&gt;b.键盘优于鼠标&lt;/li&gt;
&lt;li&gt;c.搜索优于导航&lt;/li&gt;
&lt;/ul&gt;
">开发者基本素养√</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/docker-de-chang-yong-ming-ling/"" data-c="
          &lt;p&gt;常用命令的备忘记录&lt;/p&gt;
&lt;!--more--&gt;
&lt;h4 id=&#34;在进行docker学习过程中通过查询发现如下命令使用频率较高故作此备忘&#34;&gt;在进行docker学习过程中通过查询发现如下命令使用频率较高，故作此备忘&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看容器的root用户密码&lt;/p&gt;
&lt;p&gt;docker logs &amp;lt;容器名orID&amp;gt; 2&amp;gt;&amp;amp;1 | grep &#39;^User: &#39; | tail -n1&lt;/p&gt;
&lt;p&gt;因为docker容器启动时的root用户的密码是随机分配的。所以，通过这种方式就可以得到redmine容器的root用户的密码了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看容器日志&lt;/p&gt;
&lt;p&gt;docker logs -f &amp;lt;容器名orID&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看正在运行的容器&lt;/p&gt;
&lt;p&gt;docker ps&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker ps -a&lt;/code&gt;为查看所有的容器，包括已经停止的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除所有容器&lt;/p&gt;
&lt;p&gt;docker rm $(docker ps -a -q)&lt;/p&gt;
&lt;p&gt;删除单个容器&lt;code&gt;docker rm &amp;lt;容器名orID&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;停止、启动、杀死一个容器&lt;/p&gt;
&lt;p&gt;docker stop &amp;lt;容器名orID&amp;gt;&lt;br&gt;
docker start &amp;lt;容器名orID&amp;gt;&lt;br&gt;
docker kill &amp;lt;容器名orID&amp;gt;&lt;/p&gt;
&lt;p&gt;可以搭配$(docker ps -a -q) 对所有容器操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看所有镜像&lt;/p&gt;
&lt;p&gt;docker images&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除所有镜像&lt;/p&gt;
&lt;p&gt;docker rmi $(docker images | grep none | awk &#39;{print $3}&#39; | sort -r)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行一个新容器，同时为它命名、端口映射、文件夹映射。以redmine镜像为例&lt;/p&gt;
&lt;p&gt;docker run --name redmine -p 9003:80 -p 9023:22 -d -v /var/redmine/files:/redmine/files -v     /var/redmine/mysql:/var/lib/mysql sameersbn/redmine&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个容器连接到另一个容器&lt;/p&gt;
&lt;p&gt;docker run -i -t --name sonar -d -link mmysql:db   tpires/sonar-server&lt;/p&gt;
&lt;p&gt;sonar容器连接到mmysql容器，并将mmysql容器重命名为db。这样，sonar容器就可以使用db的相关的环境变量了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拉取镜像&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;docker pull &amp;lt;镜像名:tag&amp;gt;

如`docker pull sameersbn/redmine:latest`
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。机器a&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;docker save busybox-1 &amp;gt; /home/save.tar

使用scp将save.tar拷到机器b上，然后：

docker load &amp;lt; /home/save.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;构建自己的镜像&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;docker build -t &amp;lt;镜像名&amp;gt; &amp;lt;Dockerfile路径&amp;gt;

如Dockerfile在当前路径：`docker build -t xx/gitlab .`
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;
&lt;p&gt;将容器固化为镜像&lt;/p&gt;
&lt;p&gt;docker commit [容器ID]  tag/name&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">Docker的常用命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://stardemo.github.io/post/guan-yu-ru-he-shi-yong-docker-gou-jian-php-de-kai-fa-huan-jing/"" data-c="
          &lt;p&gt;使用Docker 构建PHP运行开发环境 （碳素云实习期间实践）&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;本文作者是Geoffrey，他是一个PHP的Web开发者，喜欢DevOps和Docker。本文主要介绍了如何使用Docker构建PHP的开发环境，文中作者也探讨了构建基于Docker的开发环境应该使用单容器还是多容器，各有什么利弊。推荐PHP开发者阅读。   本文由php100.com dockerone翻译，本博属应用转载。&lt;br&gt;
现在很多开发者都使用Vagrant来管理他们的虚拟机开发环境，Vagrant确实很酷， 不过也有不少缺点（最主要的是它占用太多的资源）。在容器技术、Docker和更多类Docker技术出现后，解决这个问题就变得简单了。&lt;/p&gt;
&lt;h2 id=&#34;免责声明&#34;&gt;免责声明&lt;/h2&gt;
&lt;p&gt;由于&lt;code&gt;boot2docker&lt;/code&gt;的工作方式，本文所述的方法在你的环境中可能无法正常运行。如果需要在非Linux环境下共享文件夹到Docker容器，还需要注意更多额外的细节。后续我会写篇文章专门来介绍实际遇到的问题。&lt;/p&gt;
&lt;h2 id=&#34;怎样才算是好的开发环境&#34;&gt;怎样才算是好的开发环境&lt;/h2&gt;
&lt;p&gt;首先，我们得知道什么才是好的开发环境， 对于我而言，一个好的开发环境需要具备以下几个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可随意使用。我必须可以随意删除和创建新的环境。&lt;/li&gt;
&lt;li&gt;快速启动。我想要用它工作时候，它立马就能用。&lt;/li&gt;
&lt;li&gt;易于更新。在我们行业中，事物发展变化非常快，必须能让我很容易将我的开发环境更新到新的软件版本。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而Docker都支持以上这些特点，甚至更多。你几乎可以即时销毁和重建容器，而更新环境只需要重建你当前使用的镜像即可。&lt;/p&gt;
&lt;h2 id=&#34;什么是php开发环境&#34;&gt;什么是PHP开发环境&lt;/h2&gt;
&lt;p&gt;目前Web应用错综复杂，PHP开发环境需要很多的东西，为了保证环境的简单性，需要做各种各样的限制。 我们这次使用Nginx、PHP5-FPM、MySQL来运行Synmfony项目。由于在容器中运行命令行会更复杂，所以这方面的内容我会放到下一篇博客中再说。&lt;/p&gt;
&lt;h2 id=&#34;pet-与-cattle&#34;&gt;Pet 与 Cattle&lt;/h2&gt;
&lt;p&gt;另一个我们要讨论的重点是：我们要把开发环境部署在多容器还是单容器中。 两种方式各有优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单容器易于分发、维护。因为它们是独立的，所有的东西都运行在同一个容器中，这点就像是一个虚拟机。但这也意味着，当你要升级其中的某样东西（比如PHP新版本）的时候， 需要重新构建整个容器。&lt;/li&gt;
&lt;li&gt;多容器可以在添加组件时提供更好的模块化。因为每个容器包含了堆栈的一部分：Web、PHP、MySQL等，这样可以单独扩展每个服务或者添加服务，并且不需要重建所有的东西。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为我比较懒，加上我需要在我的笔记本上放点别的内容，所以，这里我们只介绍单个容器的方法。&lt;/p&gt;
&lt;h2 id=&#34;初始化工程&#34;&gt;初始化工程&lt;/h2&gt;
&lt;p&gt;首先要做的是初始化一个新的Symfony工程. 推荐的方法是用&lt;code&gt;composer&lt;/code&gt;的&lt;code&gt;create-project&lt;/code&gt;命令。本来可以在工作站上安装composer，但是那样太简单了。这次我们通过Docker来使用它。 我之前发过一篇关于Docker命令的文章：&lt;a href=&#34;http://geoffrey.io/making-docker-commands.html&#34;&gt;&lt;code&gt;make docker commands&lt;/code&gt;&lt;/a&gt;（好吧，我说谎了，我本来把它写在这篇文章中了，然后觉得把它独立出来会比较好）。 不管怎么样，你可以读一下。接下来如果还没有&lt;code&gt;composer&lt;/code&gt;命令的话，你可以创建一个属于自己的&lt;code&gt;composer&lt;/code&gt; 别名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ alias composer=&amp;quot;docker run -i -t -v \\$PWD:/srv ubermuda/composer&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在你可以初始化Symfony工程了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ composer create-project symfony/framwork-standard-edition SomeProject
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;帅呆了！下面来点实在的工作。(省略了博主自娱自乐的一堆balabla....原文:Awesome. Give yourself a high-five， get a cup of coffee or whatever is your liquid drug of choice， and get ready for the real work.)&lt;/p&gt;
&lt;h2 id=&#34;容器&#34;&gt;容器&lt;/h2&gt;
&lt;p&gt;构建一个运行标准Symfony项目且自给自足的容器相当容易，只需要安装好常用的Nginx、PHP5-FPM和MySQL-Server即可，然后把预先准备好的Nginx的虚拟主机配置文件扔进去，再复制一些配置文件进去就完事了。 本容器的源代码在GitHub上的 &lt;a href=&#34;https://github.com/ubermuda/docker-symfony&#34;&gt;ubermuda/docker-symfony&lt;/a&gt;仓库中可以找到。 Dockerfile 是Docker构建镜像要用到的配置文件，我们来看一下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM debian:wheezy
ENV DEBIAN_FRONTEND noninteractive
RUN apt-get update -y
RUN apt-get install -y nginx php5-fpm php5-mysqlnd php5-cli mysql-server supervisor
RUN sed -e &#39;s/;daemonize = yes/daemonize = no/&#39; -i /etc/php5/fpm/php-fpm.conf
RUN sed -e &#39;s/;listen\\.owner/listen.owner/&#39; -i /etc/php5/fpm/pool.d/www.conf
RUN sed -e &#39;s/;listen\\.group/listen.group/&#39; -i /etc/php5/fpm/pool.d/www.conf
RUN echo &amp;quot;\\ndaemon off;&amp;quot; &amp;gt;&amp;gt; /etc/nginx/nginx.conf
ADD vhost.conf /etc/nginx/sites-available/default
ADD supervisor.conf /etc/supervisor/conf.d/supervisor.conf
ADD init.sh /init.sh
EXPOSE 80 3306
VOLUME \[&amp;quot;/srv&amp;quot;\]
WORKDIR /srv
CMD \[&amp;quot;/usr/bin/supervisord&amp;quot;\]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们通过扩展 &lt;code&gt;debian:wheezy&lt;/code&gt; 这个基础镜像开始，然后通过一系列的&lt;code&gt;sed&lt;/code&gt;命令来配置Nginx和PHP5-FPM。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;RUN sed -e &#39;s/;daemonize = yes/daemonize = no/&#39; -i /etc/php5/fpm/php-fpm.conf
RUN sed -e &#39;s/;listen\\.owner/listen.owner/&#39; -i /etc/php5/fpm/pool.d/www.conf
RUN sed -e &#39;s/;listen\\.group/listen.group/&#39; -i /etc/php5/fpm/pool.d/www.conf
RUN echo &amp;quot;\\ndaemon off;&amp;quot; &amp;gt;&amp;gt; /etc/nginx/nginx.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们要做两件事。 首先配置PHP5-FPM和Nginx让他们在前台运行以便supervisord可以追踪到他们。 然后，配置PHP5-FPM以指定的用户运行Web-Server，并处理好文件权限。 接下来需要安装一组配置文件，首先是Nginx的虚拟主机配置文件&lt;code&gt;vhost.conf&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;server {
    listen 80;
    server\_name \_;
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;
    root /srv/web;
    index app_dev.php;
    location / {
        try\_files $uri $uri/ /app\_dev.php?$query_string;
    }
    location ~ \[^/\]\\.php(/|$) {
        fastcgi_pass unix:/var/run/php5-fpm.sock;
        include fastcgi_params;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为我们不需要域名，所以把&lt;code&gt;server_name&lt;/code&gt;设成了&lt;code&gt;_&lt;/code&gt;（有点像perl的&lt;code&gt;$_&lt;/code&gt;占位符变量）， 并配置根目录（document root）为/svr/web， 我们会把应用程序部署在&lt;code&gt;/srv&lt;/code&gt;下，剩下的就是标准的Mginx + PHP5-FPM配置. 因为一个容器每次只能运行一个程序， 我们需要supervisord（或者任何别的进程管理器，不过我比较中意supervisord）。幸运的是， 这个进程管理器会产生我们需要的所有进程！下面是一小段supervisord的配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\[supervisord\]
nodaemon=true
\[program:nginx\]
command=/usr/sbin/nginx
\[program:php5-fpm\]
command=/usr/sbin/php5-fpm
\[program:mysql\]
command=/usr/bin/mysqld_safe
\[program:init\]
command=/init.sh
autorestart=false
redirect_stderr=true
redirect_stdout=/srv/app/logs/init.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们需要做的是定义所有的服务， 加上一个特殊的&lt;code&gt;program:init&lt;/code&gt;进程，它不是一个实际的服务，而是一个独创的运行启动脚本的方式。 这个启动脚本的问题在于，它通常需要先启动某些服务。比如，你可能要初始化一些数据库表，但前提是你得先把MySQL跑起来，一个可能的解决办法是，在启动脚本中启动MySQL，然后初始化表，然后为了防止影响到supervisord的进程管理，需要停掉MySQL，最后再启动supervisord。 这样的脚本看起来类似下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/etc/init.d/mysql start
app/console doctrine:schema:update --force
/etc/init.d/mysql stop
exec /usr/bin/supervisord
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起来丑爆了有木有，咱换种方式，让supervisor来运行它并且永不重启。 实际的&lt;code&gt;init.sh&lt;/code&gt;脚本如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash
RET=1
while \[\[ RET -ne 0 \]\]; do
    sleep 1;
    mysql -e &#39;exit&#39; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; RET=$?
done
DB\_NAME=${DB\_NAME:-symfony}
mysqladmin -u root create $DB_NAME
if \[ -n &amp;quot;$INIT&amp;quot; \]; then
    /srv/$INIT
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;脚本先等待MySQL启动，然后根据环境变量&lt;code&gt;DB_NAME&lt;/code&gt;创建DB，默认为&lt;code&gt;symfony&lt;/code&gt;， 然后在INIT环境变量中查找要运行的脚本，并尝试运行它。本文的结尾有说明如何使用这些环境变量。&lt;/p&gt;
&lt;h2 id=&#34;构建并运行镜像&#34;&gt;构建并运行镜像&lt;/h2&gt;
&lt;p&gt;万事俱备只欠东风。我们还要构建Symfony Docker镜像， 使用&lt;code&gt;docker build&lt;/code&gt;命令:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd docker-symfony
$ docker build -t symfony .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，可以使用它来运行你的Symfony工程了:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd SomeProject
$ docker run -i -t -P -v $PWD:/srv symfony
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们来看看这一连串的选项分别是干嘛的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   `-i` 启动_交互_（interactive）模式， 也就是说，`STDIO`（标准输入输出）连接到了你当前的终端上。当你要接收日志或者给进程发送信号时，它很有用。
*   `-t` 为容器创建一个虚拟`TTY`， 它跟`-i`是好基友，通常一起使用。
*   `-P` 告诉Docker守护进程发布所有指定的端口， 本例中为80端口。
*   `-v $PWD:/srv` 把当前目录挂载到容器的/srv目录。挂载一个目录使得目录内容对目标挂载点可用。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在你还记得之前提到的&lt;code&gt;DB_NAME&lt;/code&gt;和&lt;code&gt;INIT&lt;/code&gt;环境变量了吧，干嘛用的呢：用于自定义你的环境。 基本上你可以通过 &lt;code&gt;docker run&lt;/code&gt;的&lt;code&gt;-e&lt;/code&gt;选项在容器中设置环境变量，启动脚本会拿到环境变量，因此，如果你的DB名为&lt;code&gt;some_project_dev&lt;/code&gt;， 你就可以这么运行容器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker run -i -t -P -v $PWD:/srv -e DB\_NAME=some\_project_dev symfony
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;INIT&lt;/code&gt; 环境变量就更强大了，它允许你启动时运行指定的脚本。比如， 你有一个&lt;code&gt;bin/setup&lt;/code&gt;脚本运行&lt;code&gt;composer install&lt;/code&gt;命令并且设置数据库schema:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash
composer install
app/console doctrine:schema:update --force
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用&lt;code&gt;-e&lt;/code&gt;来运行它：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run -i -t -P \
    -v $PWD:/srv \
    -e DB\_NAME=some\_project_dev \
    -e INIT=bin/setup
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，&lt;code&gt;-e&lt;/code&gt;选项可以在&lt;code&gt;docer run&lt;/code&gt;中多次使用，看起来相当酷。另外，你的启动脚本需要可执行权限（&lt;code&gt;chmod +x&lt;/code&gt;）。 现在我们通过&lt;code&gt;curl&lt;/code&gt;发送请求到容器，来检查一下是否所有的东西都像预期一样工作。首先，我们需要取到Docker映射到容器的80端口的公共端口，用&lt;code&gt;docker port&lt;/code&gt;命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker port $(docker ps -aql 1) 80
0.0.0.0:49153
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker ps -aql 1&lt;/code&gt; 是个好用的命令，可以方便的检索到最后一个容器的id， 在我们的例子中，Docker 把容器的80端口映射到了49153端口。我们 curl 一下看看。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl http://localhost:49153
You are not allowed to access this file. Check app_dev.php for more information.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们不从localhost（译者注：容器的localhost）访问dev controller时，得到了Symfony的默认错误消息，这再正常不过了， 因为我们不是从容器内部发送 curl 请求的， 所以，可以安全的从前端控制器&lt;code&gt;web/app_dev.php&lt;/code&gt;中移除这些行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// This check prevents access to debug front controllers that are deployed by accident to production servers.
// Feel free to remove this， extend it， or make something more sophisticated.
if (isset($\_SERVER\[&#39;HTTP\_CLIENT_IP&#39;\])
    || isset($\_SERVER\[&#39;HTTP\_X\_FORWARDED\_FOR&#39;\])
    || !(in\_array(@$\_SERVER\[&#39;REMOTE\_ADDR&#39;\]， array(&#39;127.0.0.1&#39;， &#39;fe80::1&#39;， &#39;::1&#39;)) || php\_sapi_name() === &#39;cli-server&#39;)
) {
    header(&#39;HTTP/1.0 403 Forbidden&#39;);
    exit(&#39;You are not allowed to access this file. Check &#39;.basename(\_\_FILE\_\_).&#39; for more information.&#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些行阻止了任何从localhost以外的地方访问dev controller。 现在再curl的时候就可以正常工作了，或者用浏览器访问 http://localhost:49153/：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;a href=&#34;http://www.php100.com/uploadfile/2015/0105/20150105102412393.png&#34;&gt;&lt;img src=&#34;http://www.php100.com/uploadfile/2015/0105/20150105102412393.png&#34; alt=&#34;result.png&#34; title=&#34;result.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;很容易吧！ 现在我们可以快速的启动、更新环境了，但还是有很多地方需要改进。 （原文链接：&lt;a href=&#34;http://geoffrey.io/a-php-development-environment-with-docker.html&#34;&gt;A PHP development environment with Docker&lt;/a&gt;）&lt;/p&gt;
">关于如何使用Docker构建PHP的开发环境</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;p&gt;原文:  &lt;a href=\&#34;https://zhuanlan.zhihu.com/p/106757502\&#34;&gt;https://zhuanlan.zhihu.com/p/106757502&lt;/a&gt;&lt;/p&gt;\n&lt;!-- more --&gt;\n&#34;,&#34;fileName&#34;:&#34;centos-76-310x-nei-he-xia-chuang-jian-memory-cgroup-shi-bai-yuan-yin-yu-jie-jue-fang-an&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;原文:  &lt;a href=\&#34;https://zhuanlan.zhihu.com/p/106757502\&#34;&gt;https://zhuanlan.zhihu.com/p/106757502&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;CentOS 7.6 3.10.x 内核下创建 memory cgroup 失败原因与解决方案&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2023-04-04 11:24:13&#34;,&#34;dateFormat&#34;:&#34;2023-04-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/centos-76-310x-nei-he-xia-chuang-jian-memory-cgroup-shi-bai-yuan-yin-yu-jie-jue-fang-an/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:2000,&#34;words&#34;:8,&#34;minutes&#34;:1},&#34;description&#34;:&#34;原文:  https://zhuanlan.zhihu.com/p/106757502\n\n&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;!-- more --&gt;\n&lt;p&gt;Cmd:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;kubectl get pods -A |grep ${podStatus} |awk &#39;{printf(&amp;quot;kubectl delete pods %s -n %s\\n&amp;quot;, $2,$1)}&#39; | /bin/bash\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Example:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;kubectl get pods -A |grep UnexpectedAdmissionError |awk &#39;{printf(&amp;quot;kubectl delete pods %s -n %s\\n&amp;quot;, $2,$1)}&#39; | /bin/bash\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;要删除成功的作业:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;kubectl delete jobs --field-selector status.successful=1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;删除失败或长时间运行的作业:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;kubectl delete jobs --field-selector status.successful=0\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;kubectl-gen-ju-pod-zhuang-tai-jin-xing-pi-liang-shan-chu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;kubectl根据Pod状态进行批量删除&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2023-04-04 11:20:11&#34;,&#34;dateFormat&#34;:&#34;2023-04-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/kubectl-gen-ju-pod-zhuang-tai-jin-xing-pi-liang-shan-chu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:26000,&#34;words&#34;:81,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\nCmd:\nkubectl get pods -A |grep ${podStatus} |awk &#39;{printf(&amp;quot;kubectl delete pods %s -n %s\\n&amp;quot;, $2,$1)}&#39; | /bin/b...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;日常排查集群故障问题时会从宿主机上定位到进程PID但是需要定位到具体哪个容器的问题就步骤多了些 这边文章把方法总结一下&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;ul&gt;\n&lt;li&gt;首先定位容器目录&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;pwdx PID\n# pwdx 681978\n# 681978: /\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;具体查询思路&lt;br&gt;\n通过&lt;code&gt;docker ps -q&lt;/code&gt;命令，获取所有的容器&lt;code&gt;id&lt;/code&gt;，再通过&lt;code&gt;xargs&lt;/code&gt;管道，将这些容器&lt;code&gt;id&lt;/code&gt;转交给&lt;code&gt;docker inspect&lt;/code&gt;命令进行处理，通过&lt;code&gt;-f &#39;{{.State.Pid}} {{.Config.Hostname}}&#39;&lt;/code&gt;参数，只打印出来容器当前的&lt;code&gt;pid&lt;/code&gt;和容器&lt;code&gt;id&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;docker ps -q | xargs docker inspect -f &#39;{{.State.Pid}} {{.Config.Hostname}}&#39; | grep PID\n## 回显\n# PID container_ID\n## 查询容器\n# docker ps | grep container_ID\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;ru-he-tong-guo-pid-ding-wei-shi-na-ge-rong-qi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;日常排查集群故障问题时会从宿主机上定位到进程PID但是需要定位到具体哪个容器的问题就步骤多了些 这边文章把方法总结一下&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;如何通过PID定位是哪个容器&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-10-26 10:59:54&#34;,&#34;dateFormat&#34;:&#34;2022-10-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/ru-he-tong-guo-pid-ding-wei-shi-na-ge-rong-qi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:38000,&#34;words&#34;:160,&#34;minutes&#34;:1},&#34;description&#34;:&#34;日常排查集群故障问题时会从宿主机上定位到进程PID但是需要定位到具体哪个容器的问题就步骤多了些 这边文章把方法总结一下\n\n\n首先定位容器目录\n\npwdx PID\n# pwdx 681978\n# 681978: /\n\n\n具体查询思路\n通过do...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;unshare [options] program [arguments]&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;run program with some namespaces unshared from parent(使用与父程序不共享的名称空间运行程序)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;unshare-命令描述\&#34;&gt;unshare 命令描述&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;Unshares the indicated namespaces from the parent process and then executes the specified program. The namespaces to be unshared are indicated via options. &lt;/code&gt;&lt;br&gt;\nUnshare取消共享父进程中指定的命名空间，然后执行指定的程序。要取消共享的命名空间通过选项来指示。不可共享的命名空间有&lt;/p&gt;\n&lt;h2 id=\&#34;支持设置的namespace\&#34;&gt;支持设置的namespace&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;mount namespace&lt;/li&gt;\n&lt;li&gt;UTS namespace&lt;/li&gt;\n&lt;li&gt;IPC namespace&lt;/li&gt;\n&lt;li&gt;network namespace&lt;/li&gt;\n&lt;li&gt;pid namespace&lt;/li&gt;\n&lt;li&gt;user namespace&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;参考资料\&#34;&gt;参考资料&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://blog.csdn.net/qq_34939308/article/details/114115443?spm=1001.2101.3001.6650.5&amp;amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5-114115443-blog-116682761.pc_relevant_multi_platform_whitelistv3&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5-114115443-blog-116682761.pc_relevant_multi_platform_whitelistv3&amp;amp;utm_relevant_index=7\&#34;&gt;unshare命令详解及案例&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.cnblogs.com/dream397/p/13996275.html\&#34;&gt;cnblogs unshare介绍&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://blog.csdn.net/weixin_42525428/article/details/116682761\&#34;&gt;linux unshare 命令,Linux ip netns 命令&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;tong-guo-unshare-tan-suo-linux-namespaces&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;unshare [options] program [arguments]&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;run program with some namespaces unshared from parent(使用与父程序不共享的名称空间运行程序)&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;title&#34;:&#34;通过unshare探索Linux namespaces&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-07-25 11:53:03&#34;,&#34;dateFormat&#34;:&#34;2022-07-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/tong-guo-unshare-tan-suo-linux-namespaces/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:40000,&#34;words&#34;:153,&#34;minutes&#34;:1},&#34;description&#34;:&#34;unshare [options] program [arguments]\n\nrun program with some namespaces unshared from parent(使用与父程序不共享的名称空间运行程序)\n\n\nunsha...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#unshare-%E5%91%BD%E4%BB%A4%E6%8F%8F%E8%BF%B0\&#34;&gt;unshare 命令描述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%94%AF%E6%8C%81%E8%AE%BE%E7%BD%AE%E7%9A%84namespace\&#34;&gt;支持设置的namespace&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\&#34;&gt;参考资料&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;ul&gt;\n&lt;li&gt;Traefik&lt;/li&gt;\n&lt;li&gt;Ingress Nginx&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;annotations\&#34;&gt;Annotations&lt;/h2&gt;\n&lt;p&gt;annotations作为k8s资源常见的一个声明配置方式 在Ingress资源对象里可以很方便的进行一些规则配置。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Traefik 1.7     &lt;a href=\&#34;https://doc.traefik.io/traefik/v1.7/configuration/backends/kubernetes/#annotations\&#34;&gt;官方文档&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;Traefik 2.0+    &lt;a href=\&#34;https://doc.traefik.io/traefik/routing/providers/kubernetes-ingress/#annotations\&#34;&gt;官方文档&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;Ingress Nginx     &lt;a href=\&#34;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/\&#34;&gt;官方文档&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;k8s-chang-yong-ingress-shi-yong-ji-qiao&#34;,&#34;abstract&#34;:&#34;&lt;ul&gt;\n&lt;li&gt;Traefik&lt;/li&gt;\n&lt;li&gt;Ingress Nginx&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;title&#34;:&#34;K8s 常用 Ingress 使用技巧&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-07-13 11:02:45&#34;,&#34;dateFormat&#34;:&#34;2022-07-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/k8s-chang-yong-ingress-shi-yong-ji-qiao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:14000,&#34;words&#34;:61,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\nTraefik\nIngress Nginx\n\n\nAnnotations\nannotations作为k8s资源常见的一个声明配置方式 在Ingress资源对象里可以很方便的进行一些规则配置。\n\nTraefik 1.7     官方文档\nTr...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#annotations\&#34;&gt;Annotations&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;根据&lt;a href=\&#34;https://docs.rancher.cn/docs/k3s/advanced/_index#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E8%BF%9F%E6%8B%89%E5%8F%96%E5%92%8C-estargz%EF%BC%9F\&#34;&gt; Rancehr文档-配置 k3s 进行 eStargz 的延迟拉取&lt;/a&gt;学习研究&lt;br&gt;\n什么是延迟拉取和 eStargz？&lt;/p&gt;\n&lt;!-- more --&gt;\n&#34;,&#34;fileName&#34;:&#34;estargz-de-yan-chi-la-qu&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;根据&lt;a href=\&#34;https://docs.rancher.cn/docs/k3s/advanced/_index#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E8%BF%9F%E6%8B%89%E5%8F%96%E5%92%8C-estargz%EF%BC%9F\&#34;&gt; Rancehr文档-配置 k3s 进行 eStargz 的延迟拉取&lt;/a&gt;学习研究&lt;br&gt;\n什么是延迟拉取和 eStargz？&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34; eStargz 的延迟拉取&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-07-12 10:35:50&#34;,&#34;dateFormat&#34;:&#34;2022-07-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/estargz-de-yan-chi-la-qu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:6000,&#34;words&#34;:29,&#34;minutes&#34;:1},&#34;description&#34;:&#34;根据 Rancehr文档-配置 k3s 进行 eStargz 的延迟拉取学习研究\n什么是延迟拉取和 eStargz？\n\n...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;项目中用到的一个需求，查询记录备忘&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-golang\&#34;&gt;package main\n \nimport (\n    &amp;quot;fmt&amp;quot;\n    &amp;quot;reflect&amp;quot;\n)\n \ntype resume struct {\n    // 反射解析结构体标签tag\n    Name string `info:&amp;quot;name&amp;quot; doc:&amp;quot;我的名字&amp;quot;`\n    Sex string `info:&amp;quot;sex&amp;quot;`\n}\n// 方法一：传递结构体对象\nfunc findTag(stru interface{}) {\n    t := reflect.TypeOf(stru)\n    for i := 0; i &amp;lt; t.NumField(); i++ {\n        fmt.Println(&amp;quot;info：&amp;quot;, t.Field(i).Tag.Get(&amp;quot;info&amp;quot;), &amp;quot;doc：&amp;quot;, t.Field(i).Tag.Get(&amp;quot;doc&amp;quot;))\n    }\n}\n// 方法二：传递结构体指针\nfunc findTag2(struc interface{}) {\n    t := reflect.TypeOf(struc).Elem()\n    for i := 0; i &amp;lt; t.NumField(); i++ {\n        fmt.Printf(&amp;quot;info: %s, doc: %s\\n&amp;quot;, t.Field(i).Tag.Get(&amp;quot;info&amp;quot;), t.Field(i).Tag.Get(&amp;quot;doc&amp;quot;))\n    }\n}\n \nfunc main() {\n    r := resume{Name: &amp;quot;mayanan&amp;quot;, Sex: &amp;quot;男&amp;quot;}\n    // 方法一：传递结构体对象\n    findTag(r)\n    // 方法二：传递结构体指针\n    findTag2(&amp;amp;r)\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;出处: &lt;a href=\&#34;https://www.cnblogs.com/mayanan/p/15484309.html\&#34;&gt;https://www.cnblogs.com/mayanan/p/15484309.html&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;golang-zhong-de-fan-she-jie-xi-jie-gou-ti-biao-qian-tag&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;项目中用到的一个需求，查询记录备忘&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;golang中的反射解析结构体标签tag&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-02-25 15:24:14&#34;,&#34;dateFormat&#34;:&#34;2022-02-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/golang-zhong-de-fan-she-jie-xi-jie-gou-ti-biao-qian-tag/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:64000,&#34;words&#34;:206,&#34;minutes&#34;:2},&#34;description&#34;:&#34;项目中用到的一个需求，查询记录备忘\n\npackage main\n \nimport (\n    &amp;quot;fmt&amp;quot;\n    &amp;quot;reflect&amp;quot;\n)\n \ntype resume struct {\n    // 反...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;!-- more --&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;指令&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;已经存在&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;不存在&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;举例&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;insert&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;报错&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;插入&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;insert into names(name, age) values(“小明”, 23);&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;insert ignore&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;忽略&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;插入&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;insert ignore into names(name, age) values(“小明”, 24);&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;replace&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;替换&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;插入&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;replace into names(name, age) values(“小明”, 25);&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;ul&gt;\n&lt;li&gt;要求：表有PrimaryKey或者unique索引&lt;/li&gt;\n&lt;li&gt;结果：表id都会自增&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;a href=\&#34;https://blog.csdn.net/mouday/article/details/81281946\&#34;&gt;学习转载自:https://blog.csdn.net/mouday/article/details/81281946&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-insert-ignoreinsert-he-replace-qu-bie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MYSQL insert ignore、insert和replace区别&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-02-23 23:15:51&#34;,&#34;dateFormat&#34;:&#34;2022-02-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/mysql-insert-ignoreinsert-he-replace-qu-bie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:23000,&#34;words&#34;:85,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n\n\n\n指令\n已经存在\n不存在\n举例\n\n\n\n\ninsert\n报错\n插入\ninsert into names(name, age) values(“小明”, 23);\n\n\ninsert ignore\n忽略\n插入\ninsert ignore i...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Kubernetes通过namespace支持了多租户，不同租户间可以通过ResourceQuota来保证资源的隔离，也无法查看其他namespace的Pod信息等。但默认kubernetes并不限制访问Pod的网络请求，对于一些敏感的应用来说可能不够用。&lt;/p&gt;\n&lt;p&gt;Refer: &lt;a href=\&#34;https://kubernetes.io/zh/docs/concepts/services-networking/network-policies/\&#34;&gt;Offical Docs&lt;/a&gt;&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;前置条件\&#34;&gt;前置条件&lt;/h2&gt;\n&lt;p&gt;网络策略通过&lt;a href=\&#34;https://kubernetes.io/zh/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/\&#34;&gt;网络插件&lt;/a&gt; 来实现。要使用网络策略，你必须使用支持&lt;code&gt;NetworkPolicy&lt;/code&gt;的网络解决方案。 创建一个 &lt;code&gt;NetworkPolicy &lt;/code&gt;资源对象而没有控制器来使它生效的话，是没有任何作用的。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;kubernetes-networkpolicy&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;Kubernetes通过namespace支持了多租户，不同租户间可以通过ResourceQuota来保证资源的隔离，也无法查看其他namespace的Pod信息等。但默认kubernetes并不限制访问Pod的网络请求，对于一些敏感的应用来说可能不够用。&lt;/p&gt;\n&lt;p&gt;Refer: &lt;a href=\&#34;https://kubernetes.io/zh/docs/concepts/services-networking/network-policies/\&#34;&gt;Offical Docs&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Kubernetes NetworkPolicy&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-02-09 11:23:29&#34;,&#34;dateFormat&#34;:&#34;2022-02-09&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/kubernetes-networkpolicy/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:29000,&#34;words&#34;:142,&#34;minutes&#34;:1},&#34;description&#34;:&#34;Kubernetes通过namespace支持了多租户，不同租户间可以通过ResourceQuota来保证资源的隔离，也无法查看其他namespace的Pod信息等。但默认kubernetes并不限制访问Pod的网络请求，对于一些敏感的应用...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6\&#34;&gt;前置条件&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;使用Golang 实践protobuf&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;https://geektutu.com/post/quick-go-protobuf.html&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;golang-protobuf-xue-xi-ji-lu&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;使用Golang 实践protobuf&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Golang Protobuf学习记录&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-02-07 17:20:43&#34;,&#34;dateFormat&#34;:&#34;2022-02-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/golang-protobuf-xue-xi-ji-lu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:4000,&#34;words&#34;:14,&#34;minutes&#34;:1},&#34;description&#34;:&#34;使用Golang 实践protobuf\n\nhttps://geektutu.com/post/quick-go-protobuf.html\n&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;percona-toolkit使用\&#34;&gt;Percona-toolkit使用&lt;/h1&gt;\n&lt;h2 id=\&#34;安装依赖\&#34;&gt;安装&amp;amp;依赖&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;yum install perl-DBI perl-DBD-MySQL perl-Time-HiRes perl-IO-Socket-SSL perl-Digest-MD5 perl-TermReadKey -y\n# centos 7\nwget https://www.percona.com/downloads/percona-toolkit/3.3.1/binary/redhat/7/x86_64/percona-toolkit-3.3.1-1.el7.x86_64.rpm\nrpm -ivh percona-toolkit-3.0.13-1.el7.x86_64.rpm\n# centos 6\n# wget https://www.percona.com/downloads/percona-toolkit/3.3.1/binary/redhat/6/x86_64/percona-toolkit-3.3.1-1.el6.x86_64.rpm\n# rpm -ivh percona-toolkit-3.0.13-1.el6.x86_64.rpm\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;percona-toolkit-工作及作用\&#34;&gt;Percona-toolkit 工作及作用&lt;/h2&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;工具类别&lt;/th&gt;\n&lt;th&gt;工具命令&lt;/th&gt;\n&lt;th&gt;工具作用&lt;/th&gt;\n&lt;th&gt;备注&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;开发类&lt;/td&gt;\n&lt;td&gt;pt-duplicate-key-checker&lt;/td&gt;\n&lt;td&gt;列出并删除重复的索引和外键&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-online-schema-change&lt;/td&gt;\n&lt;td&gt;在线修改表结构&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-query-advisor&lt;/td&gt;\n&lt;td&gt;分析查询语句，并给出建议，有bug&lt;/td&gt;\n&lt;td&gt;已废弃&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-show-grants&lt;/td&gt;\n&lt;td&gt;规范化和打印权限&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-upgrade&lt;/td&gt;\n&lt;td&gt;在多个服务器上执行查询，并比较不同&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;性能类&lt;/td&gt;\n&lt;td&gt;pt-index-usage&lt;/td&gt;\n&lt;td&gt;分析日志中索引使用情况，并出报告&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-pmp&lt;/td&gt;\n&lt;td&gt;为查询结果跟踪，并汇总跟踪结果&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-visual-explain&lt;/td&gt;\n&lt;td&gt;格式化执行计划&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-table-usage&lt;/td&gt;\n&lt;td&gt;分析日志中查询并分析表使用情况&lt;/td&gt;\n&lt;td&gt;pt 2.2新增命令&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;配置类&lt;/td&gt;\n&lt;td&gt;pt-config-diff&lt;/td&gt;\n&lt;td&gt;比较配置文件和参数&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-mysql-summary&lt;/td&gt;\n&lt;td&gt;对mysql配置和status进行汇总&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-variable-advisor&lt;/td&gt;\n&lt;td&gt;分析参数，并提出建议&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;监控类&lt;/td&gt;\n&lt;td&gt;pt-deadlock-logger&lt;/td&gt;\n&lt;td&gt;提取和记录mysql死锁信息&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-fk-error-logger&lt;/td&gt;\n&lt;td&gt;提取和记录外键信息&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-mext&lt;/td&gt;\n&lt;td&gt;并行查看status样本信息&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-query-digest&lt;/td&gt;\n&lt;td&gt;分析查询日志，并产生报告&lt;/td&gt;\n&lt;td&gt;常用命令&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-trend&lt;/td&gt;\n&lt;td&gt;按照时间段读取slow日志信息&lt;/td&gt;\n&lt;td&gt;已废弃&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;复制类&lt;/td&gt;\n&lt;td&gt;pt-heartbeat&lt;/td&gt;\n&lt;td&gt;监控mysql复制延迟&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-slave-delay&lt;/td&gt;\n&lt;td&gt;设定从落后主的时间&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-slave-find&lt;/td&gt;\n&lt;td&gt;查找和打印所有mysql复制层级关系&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-slave-restart&lt;/td&gt;\n&lt;td&gt;监控salve错误，并尝试重启salve&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-table-checksum&lt;/td&gt;\n&lt;td&gt;校验主从复制一致性&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-table-sync&lt;/td&gt;\n&lt;td&gt;高效同步表数据&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;系统类&lt;/td&gt;\n&lt;td&gt;pt-diskstats&lt;/td&gt;\n&lt;td&gt;查看系统磁盘状态&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-fifo-split&lt;/td&gt;\n&lt;td&gt;模拟切割文件并输出&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-summary&lt;/td&gt;\n&lt;td&gt;收集和显示系统概况&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-stalk&lt;/td&gt;\n&lt;td&gt;出现问题时，收集诊断数据&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-sift&lt;/td&gt;\n&lt;td&gt;浏览由pt-stalk创建的文件&lt;/td&gt;\n&lt;td&gt;pt 2.2新增命令&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-ioprofile&lt;/td&gt;\n&lt;td&gt;查询进程IO并打印一个IO活动表&lt;/td&gt;\n&lt;td&gt;pt 2.2新增命令&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;实用类&lt;/td&gt;\n&lt;td&gt;pt-archiver&lt;/td&gt;\n&lt;td&gt;将表数据归档到另一个表或文件中&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-find&lt;/td&gt;\n&lt;td&gt;查找表并执行命令&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-kill&lt;/td&gt;\n&lt;td&gt;Kill掉符合条件的sql&lt;/td&gt;\n&lt;td&gt;常用命令&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-align&lt;/td&gt;\n&lt;td&gt;对齐其他工具的输出&lt;/td&gt;\n&lt;td&gt;pt 2.2新增命令&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;pt-fingerprint&lt;/td&gt;\n&lt;td&gt;将查询转成密文&lt;/td&gt;\n&lt;td&gt;pt 2.2新增命令&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&#34;,&#34;fileName&#34;:&#34;percona-toolkit-shi-yong&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Percona-toolkit使用&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-02-06 20:26:25&#34;,&#34;dateFormat&#34;:&#34;2022-02-06&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/percona-toolkit-shi-yong/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:164000,&#34;words&#34;:633,&#34;minutes&#34;:3},&#34;description&#34;:&#34;Percona-toolkit使用\n安装&amp;amp;依赖\nyum install perl-DBI perl-DBD-MySQL perl-Time-HiRes perl-IO-Socket-SSL perl-Digest-MD5 perl-...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#percona-toolkit%E4%BD%BF%E7%94%A8\&#34;&gt;Percona-toolkit使用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96\&#34;&gt;安装&amp;amp;依赖&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#percona-toolkit-%E5%B7%A5%E4%BD%9C%E5%8F%8A%E4%BD%9C%E7%94%A8\&#34;&gt;Percona-toolkit 工作及作用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;日常遇到一些gcr/github的容器镜像由于网络原因拉取速度较慢，或者无法拉取下来，整理一些方案。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;使用阿里云加速k8sgcr的下载\&#34;&gt;使用阿里云加速k8s.gcr的下载&lt;/h2&gt;\n&lt;p&gt;使用&lt;code&gt;registry.aliyuncs.com/google_containers/&lt;/code&gt;替换&lt;code&gt; k8s.gcr.io/sig-storage/&lt;/code&gt;即可&lt;/p&gt;\n&lt;h3 id=\&#34;example\&#34;&gt;Example&lt;/h3&gt;\n&lt;p&gt;拉取CSI相关组件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;export IMAGE=csi-attacher:v3.2.1\ndocker pull registry.aliyuncs.com/google_containers/$IMAGE &amp;amp;&amp;amp; docker tag registry.aliyuncs.com/google_containers/$IMAGE  k8s.gcr.io/sig-storage/$IMAGE\n\n\nexport IMAGE=csi-provisioner:v2.1.2\ndocker pull registry.aliyuncs.com/google_containers/$IMAGE &amp;amp;&amp;amp; docker tag registry.aliyuncs.com/google_containers/$IMAGE  k8s.gcr.io/sig-storage/$IMAGE\n\n\nexport IMAGE=csi-resizer:v1.2.0\ndocker pull registry.aliyuncs.com/google_containers/$IMAGE &amp;amp;&amp;amp; docker tag registry.aliyuncs.com/google_containers/$IMAGE  k8s.gcr.io/sig-storage/$IMAGE\n\nexport IMAGE=csi-snapshotter:v3.0.3\ndocker pull registry.aliyuncs.com/google_containers/$IMAGE &amp;amp;&amp;amp; docker tag registry.aliyuncs.com/google_containers/$IMAGE  k8s.gcr.io/sig-storage/$IMAGE\n\n\nexport IMAGE=csi-node-driver-registrar:v2.3.0 \ndocker pull registry.aliyuncs.com/google_containers/$IMAGE &amp;amp;&amp;amp; docker tag registry.aliyuncs.com/google_containers/$IMAGE  k8s.gcr.io/sig-storage/$IMAGE\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;jing-xiang-la-qu-jia-su-fang-an-zong-jie&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;日常遇到一些gcr/github的容器镜像由于网络原因拉取速度较慢，或者无法拉取下来，整理一些方案。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;镜像拉取加速方案总结&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-11-13 14:04:48&#34;,&#34;dateFormat&#34;:&#34;2021-11-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/jing-xiang-la-qu-jia-su-fang-an-zong-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:72000,&#34;words&#34;:221,&#34;minutes&#34;:2},&#34;description&#34;:&#34;日常遇到一些gcr/github的容器镜像由于网络原因拉取速度较慢，或者无法拉取下来，整理一些方案。\n\n使用阿里云加速k8s.gcr的下载\n使用registry.aliyuncs.com/google_containers/替换 k8s.g...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A0%E9%80%9Fk8sgcr%E7%9A%84%E4%B8%8B%E8%BD%BD\&#34;&gt;使用阿里云加速k8s.gcr的下载&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#example\&#34;&gt;Example&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;看到redisearch的特性，研究研究 ，对比下ES使用&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;附录\&#34;&gt;附录&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;官方文档 &lt;a href=\&#34;https://oss.redislabs.com/redisearch/Commands/\&#34;&gt;https://oss.redislabs.com/redisearch/Commands/&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;redisearch-shi-yong-ji-lu&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;看到redisearch的特性，研究研究 ，对比下ES使用&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Redisearch 使用记录&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-08-12 09:22:32&#34;,&#34;dateFormat&#34;:&#34;2021-08-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/redisearch-shi-yong-ji-lu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:7000,&#34;words&#34;:28,&#34;minutes&#34;:1},&#34;description&#34;:&#34;看到redisearch的特性，研究研究 ，对比下ES使用\n\n附录\n\n官方文档 https://oss.redislabs.com/redisearch/Commands/\n\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%99%84%E5%BD%95\&#34;&gt;附录&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;!-- more --&gt;\n&lt;p&gt;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;nginx-ingress-shi-yong-shou-ce&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Nginx Ingress使用手册&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-07-08 16:18:07&#34;,&#34;dateFormat&#34;:&#34;2021-07-08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/nginx-ingress-shi-yong-shou-ce/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:4000,&#34;words&#34;:11,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\nhttps://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#\n&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;!-- more --&gt;\n&lt;p&gt;https://help.aliyun.com/document_detail/86532.html?spm=5176.2020520112.help.dexternal.4e7934c0W010f5&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;a-li-yun-shi-yong-bei-wang&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;阿里云使用备忘&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-06-17 15:51:01&#34;,&#34;dateFormat&#34;:&#34;2021-06-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/a-li-yun-shi-yong-bei-wang/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:4000,&#34;words&#34;:13,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\nhttps://help.aliyun.com/document_detail/86532.html?spm=5176.2020520112.help.dexternal.4e7934c0W010f5\n...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;线上K8s集群的一个节点总报告kubelet不健康，使用journalctl 查看日志发现大量&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;Scope libcontainer-nnnnn has no PIDs. Refusing&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt; Orphaned pod found - but volume paths are still present on disk&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;在此记录下问题的解决方案&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;问题1-scope-libcontainer-nnnnn-has-no-pids-refusing\&#34;&gt;问题1. &lt;code&gt;Scope libcontainer-nnnnn has no PIDs. Refusing&lt;/code&gt;&lt;/h2&gt;\n&lt;h3 id=\&#34;问题描述\&#34;&gt;问题描述&lt;/h3&gt;\n&lt;p&gt;使用journalctl查询&lt;code&gt; /var/log/messages&lt;/code&gt;处日志，有大量&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Scope libcontainer-nnnnn has no PIDs. Refusing\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;问题原因\&#34;&gt;问题原因&lt;/h3&gt;\n&lt;h3 id=\&#34;问题解法\&#34;&gt;问题解法&lt;/h3&gt;\n&lt;h3 id=\&#34;参考出处\&#34;&gt;参考出处&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.ibm.com/support/pages/recurring-messages-complain-scope-libcontainer-nnnnn-has-no-pids-refusing\&#34;&gt;https://www.ibm.com/support/pages/recurring-messages-complain-scope-libcontainer-nnnnn-has-no-pids-refusing&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;问题2-orphaned-pod-found-but-volume-paths-are-still-present-on-disk\&#34;&gt;问题2. &lt;code&gt;Orphaned pod found - but volume paths are still present on disk&lt;/code&gt;&lt;/h2&gt;\n&lt;h3 id=\&#34;问题描述-2\&#34;&gt;问题描述&lt;/h3&gt;\n&lt;p&gt;使用journalctl查询&lt;code&gt; /var/log/messages&lt;/code&gt;处日志，有大量报错&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;[kubelet_volumes.go:128] Orphaned pod &amp;quot;86d60ee9-9fae-11e8-8cfc-525400290b20&amp;quot; found, but volume paths are still present on disk. : There were a total of 100 errors similar to this.  Turn up verbosity to see them\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;问题原因-2\&#34;&gt;问题原因&lt;/h3&gt;\n&lt;p&gt;集群Pod停止删除了，数据文件未自动清理&lt;/p&gt;\n&lt;h3 id=\&#34;问题解法-2\&#34;&gt;问题解法&lt;/h3&gt;\n&lt;p&gt;删除&lt;code&gt;/var/lib/kubelet/pods&lt;/code&gt;对应日志ID的残留文件&lt;/p&gt;\n&lt;h3 id=\&#34;参考出处-2\&#34;&gt;参考出处&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://cloud.tencent.com/developer/article/1385911\&#34;&gt;https://cloud.tencent.com/developer/article/1385911&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;ji-lu-yi-ci-kubelet-cuo-wu-ri-zhi-pai-cha&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;线上K8s集群的一个节点总报告kubelet不健康，使用journalctl 查看日志发现大量&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;Scope libcontainer-nnnnn has no PIDs. Refusing&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt; Orphaned pod found - but volume paths are still present on disk&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;在此记录下问题的解决方案&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;记录一次kubelet错误日志排查&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-05-24 14:49:04&#34;,&#34;dateFormat&#34;:&#34;2021-05-24&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/ji-lu-yi-ci-kubelet-cuo-wu-ri-zhi-pai-cha/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:69000,&#34;words&#34;:242,&#34;minutes&#34;:2},&#34;description&#34;:&#34;线上K8s集群的一个节点总报告kubelet不健康，使用journalctl 查看日志发现大量\n\nScope libcontainer-nnnnn has no PIDs. Refusing\n Orphaned pod found - bu...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%981-scope-libcontainer-nnnnn-has-no-pids-refusing\&#34;&gt;问题1. &lt;code&gt;Scope libcontainer-nnnnn has no PIDs. Refusing&lt;/code&gt;&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\&#34;&gt;问题描述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0\&#34;&gt;问题原因&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E8%A7%A3%E6%B3%95\&#34;&gt;问题解法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83%E5%87%BA%E5%A4%84\&#34;&gt;参考出处&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%982-orphaned-pod-found-but-volume-paths-are-still-present-on-disk\&#34;&gt;问题2. &lt;code&gt;Orphaned pod found - but volume paths are still present on disk&lt;/code&gt;&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-2\&#34;&gt;问题描述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0-2\&#34;&gt;问题原因&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E8%A7%A3%E6%B3%95-2\&#34;&gt;问题解法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83%E5%87%BA%E5%A4%84-2\&#34;&gt;参考出处&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;整理学习 -_-｜&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;makefile中phony的作用\&#34;&gt;Makefile中.PHONY的作用&lt;/h2&gt;\n&lt;p&gt;单词phony (即phoney)的意思是：伪造的，假的。来自collins的解释是：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;If you describe something as phoney, you disapprove of it because it is false \nrather than genuine. \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;那么，在Makefile中，.PHONY后面的target表示的也是一个伪造的target, 而不是真实存在的文件target，注意Makefile的target默认是文件。&lt;/p&gt;\n&lt;h3 id=\&#34;举例\&#34;&gt;举例:&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;$ cat -n Makefile1\n     1    clean:\n     2        rm -f foo\n$ cat -n Makefile2\n     1    .PHONY: clean\n     2    clean:\n     3        rm -f foo\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Makefile1和Makefile2的差别就是在Makefile2中定义了：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;1 .PHONY: clean\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;直接Make看看:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;$ ls -l\ntotal 8\n-rw-r--r-- 1 huanli huanli 18 Jul 13 17:51 Makefile1\n-rw-r--r-- 1 huanli huanli 32 Jul 13 17:51 Makefile2\n$ make -f Makefile1 clean\nrm -f foo\n$ make -f Makefile2 clean\nrm -f foo\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这么观察 Makefile1/Makefile2没什么区别&lt;/p&gt;\n&lt;p&gt;再创建一个文件起名clean, 再make看看&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;$ touch clean\n$ ls -l\ntotal 8\n-rw-r--r-- 1 huanli huanli  0 Jul 13 18:06 clean\n-rw-r--r-- 1 huanli huanli 18 Jul 13 17:51 Makefile1\n-rw-r--r-- 1 huanli huanli 32 Jul 13 17:51 Makefile2\n$ make -f Makefile1 clean\nmake: &#39;clean&#39; is up to date.\n$ make -f Makefile2 clean\nrm -f foo\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;区别来了，Makefile1拒绝了执行clean, 因为文件clean存在。而Makefile2却不理会文件clean的存在，总是执行clean后面的规则。由此可见，.PHONY clean发挥了作用。&lt;/p&gt;\n&lt;h3 id=\&#34;小结\&#34;&gt;小结：&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-makefile\&#34;&gt;.PHONY: clean\n    o means the word &amp;quot;clean&amp;quot; doesn&#39;t represent a file name in this Makefile;\n    o means the Makefile has nothing to do with a file called &amp;quot;clean&amp;quot; \n      in the same directory.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;参考资料\&#34;&gt;参考资料：&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html\&#34;&gt;Phony Targets of GNU Make&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.cnblogs.com/idorax/p/9306528.html\&#34;&gt;Veli Cnblogs&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;study-makefile&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;整理学习 -_-｜&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Makefile学习&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-05-10 11:50:07&#34;,&#34;dateFormat&#34;:&#34;2021-05-10&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/study-makefile/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:107000,&#34;words&#34;:356,&#34;minutes&#34;:2},&#34;description&#34;:&#34;整理学习 -_-｜\n\nMakefile中.PHONY的作用\n单词phony (即phoney)的意思是：伪造的，假的。来自collins的解释是：\nIf you describe something as phoney, you disap...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#makefile%E4%B8%ADphony%E7%9A%84%E4%BD%9C%E7%94%A8\&#34;&gt;Makefile中.PHONY的作用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BE%E4%BE%8B\&#34;&gt;举例:&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B0%8F%E7%BB%93\&#34;&gt;小结：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\&#34;&gt;参考资料：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;遇到了两个问题&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;/var/spool/postfix/maildrop &lt;/code&gt;产生大量文件&lt;/li&gt;\n&lt;li&gt;目录中文件过多导致ls命令卡住&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;前因\&#34;&gt;前因&lt;/h2&gt;\n&lt;p&gt;收到服务器报警邮件，磁盘使用率超过百分之97，遂上线检查清理&lt;/p&gt;\n&lt;h3 id=\&#34;检查目录占用情况\&#34;&gt;检查目录占用情况&lt;/h3&gt;\n&lt;p&gt;笨办法，&lt;code&gt;du -sh *&lt;/code&gt; 查看目录/文件大小，发现卡在&lt;code&gt;var&lt;/code&gt;目录下，进入目录继续测试，发现最终卡在&lt;code&gt;/var/spool/postfix/maildrop &lt;/code&gt;下，进入目录，ls 发现ls卡死，需要kil 才能恢复，&lt;code&gt;ls -l |wc -l &lt;/code&gt;同样结果，遂开始研究问题。&lt;/p&gt;\n&lt;h2 id=\&#34;问题1-varspoolpostfixmaildrop-产生大量文件\&#34;&gt;问题1.  &lt;code&gt;/var/spool/postfix/maildrop &lt;/code&gt;产生大量文件&lt;/h2&gt;\n&lt;p&gt;crontab 每次执行任务后会发送邮件，接受者是在他的配置文件 “/etc/crontab” 通过 MAILTO=root’ 来设置的，默认是root。发送后的邮件就到&lt;code&gt;/var/spool/postfix/maildrop&lt;/code&gt;下了。&lt;/p&gt;\n&lt;p&gt;如果需要邮件发送到指定邮箱，则需要配置此处。&lt;/p&gt;\n&lt;p&gt;继续检查发现发现服务器上有很多crontab任务，因而判断发送太多邮件到maildrop下导致文件超多。&lt;/p&gt;\n&lt;h3 id=\&#34;解决方案\&#34;&gt;解决方案&lt;/h3&gt;\n&lt;h4 id=\&#34;方案1\&#34;&gt;方案1&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;修改“/etc/crontab”\n将‘MAILTO=root’替换成‘MAILTO=&amp;quot;&amp;quot;’修改之后没有成功，需要重启crond服务才可以\n也可从在crontab（crontab -e）中最前面直接加入MAILTO=&amp;quot;&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;方案2\&#34;&gt;方案2&lt;/h4&gt;\n&lt;p&gt;如果是我们不关心的备注型等输出我们完全可以让其输出到 &lt;code&gt;/dev/null&lt;/code&gt; 这样就不会因为发送失败到导致在&lt;code&gt;/var/spool/postfix/maildrop&lt;/code&gt;下面产出什么文件。&lt;br&gt;\n如果需要收集输出log，可在&lt;code&gt;crontab job&lt;/code&gt;后增加&lt;code&gt;&amp;gt;&lt;/code&gt;定向输出&lt;br&gt;\n例如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 输出空\n*/10 * * * * /tmp/test.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1\n# 定向输出到文件\n*/10 * * * * /tmp/test.sh &amp;gt;/log/test.log 2&amp;gt;&amp;amp;1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;结果\&#34;&gt;结果&lt;/h3&gt;\n&lt;p&gt;使用&lt;code&gt;方案1&lt;/code&gt;后重启crond服务，则不会产生新的文件。&lt;/p&gt;\n&lt;h2 id=\&#34;问题2-目录中文件过多导致ls命令卡住\&#34;&gt;问题2. 目录中文件过多导致ls命令卡住&lt;/h2&gt;\n&lt;h3 id=\&#34;解决方案-2\&#34;&gt;解决方案&lt;/h3&gt;\n&lt;p&gt;如果需要立马显示文件内容，则使用&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;ls -1 -f \n# 删除文件\nls -1 -f | xargs rm\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;即可立马显示文件。&lt;/p&gt;\n&lt;h3 id=\&#34;问题原因\&#34;&gt;问题原因&lt;/h3&gt;\n&lt;p&gt;(https://www.jianshu.com/p/353a5dbcd423)[https://www.jianshu.com/p/353a5dbcd423]&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;ji-lu-yi-ci-fu-wu-qi-ci-pan-rong-liang-bu-zu-de-qing-li-guo-cheng&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;遇到了两个问题&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;/var/spool/postfix/maildrop &lt;/code&gt;产生大量文件&lt;/li&gt;\n&lt;li&gt;目录中文件过多导致ls命令卡住&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;title&#34;:&#34;记录一次服务器磁盘容量不足的清理过程&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-05-07 20:57:01&#34;,&#34;dateFormat&#34;:&#34;2021-05-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/ji-lu-yi-ci-fu-wu-qi-ci-pan-rong-liang-bu-zu-de-qing-li-guo-cheng/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:124000,&#34;words&#34;:525,&#34;minutes&#34;:3},&#34;description&#34;:&#34;遇到了两个问题\n\n/var/spool/postfix/maildrop 产生大量文件\n目录中文件过多导致ls命令卡住\n\n\n前因\n收到服务器报警邮件，磁盘使用率超过百分之97，遂上线检查清理\n检查目录占用情况\n笨办法，du -sh * 查看...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E5%9B%A0\&#34;&gt;前因&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A3%80%E6%9F%A5%E7%9B%AE%E5%BD%95%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5\&#34;&gt;检查目录占用情况&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%981-varspoolpostfixmaildrop-%E4%BA%A7%E7%94%9F%E5%A4%A7%E9%87%8F%E6%96%87%E4%BB%B6\&#34;&gt;问题1.  &lt;code&gt;/var/spool/postfix/maildrop &lt;/code&gt;产生大量文件&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\&#34;&gt;解决方案&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%A1%881\&#34;&gt;方案1&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%A1%882\&#34;&gt;方案2&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%93%E6%9E%9C\&#34;&gt;结果&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%982-%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%96%87%E4%BB%B6%E8%BF%87%E5%A4%9A%E5%AF%BC%E8%87%B4ls%E5%91%BD%E4%BB%A4%E5%8D%A1%E4%BD%8F\&#34;&gt;问题2. 目录中文件过多导致ls命令卡住&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2\&#34;&gt;解决方案&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0\&#34;&gt;问题原因&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;收集各路面试问答，做一个记录&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;1-网络基础\&#34;&gt;1. 网络基础&lt;/h2&gt;\n&lt;h3 id=\&#34;11-问三次握手和四次挥手\&#34;&gt;1.1 问：三次握手和四次挥手&lt;/h3&gt;\n&lt;p&gt;为什么要进行三次握手：为了确认对方的发送和接收能力。&lt;/p&gt;\n&lt;h4 id=\&#34;三次握手\&#34;&gt;三次握手&lt;/h4&gt;\n&lt;p&gt;三次握手主要流程：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;一开始双方处于 &lt;code&gt;CLOSED&lt;/code&gt;状态，然后服务端开始监听某个端口进入 &lt;code&gt;LISTEN&lt;/code&gt; 状态&lt;/li&gt;\n&lt;li&gt;然后客户端主动发起连接，发送 &lt;code&gt;SYN&lt;/code&gt;，然后自己变为 &lt;code&gt;SYN-SENT&lt;/code&gt;，&lt;code&gt;seq = x&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;服务端收到之后，返回 &lt;code&gt;SYN seq = y&lt;/code&gt; 和 &lt;code&gt;ACK ack = x + 1&lt;/code&gt;（对于客户端发来的 SYN），自己变成 &lt;code&gt;SYN-REVD&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;之后客户端再次发送 &lt;code&gt;ACK seq = x + 1&lt;/code&gt;,&lt;code&gt; ack = y + 1&lt;/code&gt;给服务端，自己变成 &lt;code&gt;EASTABLISHED&lt;/code&gt; 状态，服务端收到 &lt;code&gt;ACK&lt;/code&gt;，也进入&lt;code&gt; ESTABLISHED&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;code&gt;SYN 需要对端确认，所以 ACK 的序列化要加一，凡是需要对端确认的，一点要消耗 TCP 报文的序列化&lt;/code&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;为什么不是两次\&#34;&gt;为什么不是两次？&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;无法确认客户端的接收能力。&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;如果首先客户端发送了 SYN 报文，但是滞留在网络中，TCP 以为丢包了，然后重传，两次握手建立了连接。&lt;br&gt;\n等到客户端关闭连接了。但是之后这个包如果到达了服务端，那么服务端接收到了，然后发送相应的数据表，就建立了链接，但是此时客户端已经关闭连接了，所以带来了链接资源的浪费。&lt;/p&gt;\n&lt;h4 id=\&#34;为什么不是四次\&#34;&gt;为什么不是四次？&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;四次以上都可以，只不过 三次就够了&lt;/code&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;四次挥手\&#34;&gt;四次挥手&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;一开始都处于 ESTABLISH 状态，然后客户端发送 FIN 报文，带上 seq = p，状态变为 FIN-WAIT-1&lt;/li&gt;\n&lt;li&gt;服务端收到之后，发送 ACK 确认，ack = p + 1，然后进入 CLOSE-WAIT 状态&lt;/li&gt;\n&lt;li&gt;客户端收到之后进入 FIN-WAIT-2  状态&lt;/li&gt;\n&lt;li&gt;过了一会等数据处理完，再次发送 FIN、ACK，seq = q，ack = p + 1，进入 LAST-ACK 阶段&lt;/li&gt;\n&lt;li&gt;客户端收到 FIN 之后，客户端收到之后进入 TIME_WAIT（等待 2MSL），然后发送 ACK 给服务端 ack = 1 + 1&lt;/li&gt;\n&lt;li&gt;服务端收到之后进入 CLOSED 状态&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;客户端这个时候还需要等待两次 MSL 之后，如果没有收到服务端的重发请求，就表明 ACK 成功到达，挥手结束，客户端变为 CLOSED 状态，否则进行 ACK 重发&lt;/p&gt;\n&lt;h4 id=\&#34;为什么需要等待-2mslmaximum-segement-lifetime\&#34;&gt;为什么需要等待 2MSL（Maximum Segement Lifetime）：&lt;/h4&gt;\n&lt;p&gt;因为如果不等待的话，如果服务端还有很多数据包要给客户端发，且此时客户端端口被新应用占据，那么就会接收到无用的数据包，造成数据包混乱，所以说最保险的方法就是等服务器发来的数据包都死翘翘了再启动新应用。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;1个 MSL 保证四次挥手中主动关闭方最后的 ACK 报文能最终到达对端&lt;/li&gt;\n&lt;li&gt;1个 MSL 保证对端没有收到 ACK 那么进行重传的 FIN 报文能够到达&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;为什么是四次而不是三次\&#34;&gt;为什么是四次而不是三次？&lt;/h4&gt;\n&lt;p&gt;如果是三次的话，那么服务端的 ACK 和 FIN 合成一个挥手，那么长时间的延迟可能让 TCP 一位 FIN 没有达到服务器端，然后让客户的不断的重发 FIN&lt;/p&gt;\n&lt;h4 id=\&#34;参考资料\&#34;&gt;参考资料&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://zhuanlan.zhihu.com/p/86426969\&#34;&gt;https://zhuanlan.zhihu.com/p/86426969&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://juejin.cn/post/6844904070889603085\&#34;&gt;https://juejin.cn/post/6844904070889603085&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;n-转载源\&#34;&gt;n. 转载源&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://juejin.cn/post/6939691851746279437\&#34;&gt;juejin-图雀社区-字节跳动最爱考的前端面试题：计算机网络基础&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;mian-jing-chang-jian-mian-shi-wen-da-zheng-li&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;收集各路面试问答，做一个记录&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;[面经] 常见面试问答整理&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-04-26 22:03:05&#34;,&#34;dateFormat&#34;:&#34;2021-04-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/mian-jing-chang-jian-mian-shi-wen-da-zheng-li/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:188000,&#34;words&#34;:853,&#34;minutes&#34;:4},&#34;description&#34;:&#34;收集各路面试问答，做一个记录\n\n1. 网络基础\n1.1 问：三次握手和四次挥手\n为什么要进行三次握手：为了确认对方的发送和接收能力。\n三次握手\n三次握手主要流程：\n\n一开始双方处于 CLOSED状态，然后服务端开始监听某个端口进入 LIST...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80\&#34;&gt;1. 网络基础&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#11-%E9%97%AE%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\&#34;&gt;1.1 问：三次握手和四次挥手&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\&#34;&gt;三次握手&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1\&#34;&gt;为什么不是两次？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1\&#34;&gt;为什么不是四次？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\&#34;&gt;四次挥手&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-2mslmaximum-segement-lifetime\&#34;&gt;为什么需要等待 2MSL（Maximum Segement Lifetime）：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%89%E6%AC%A1\&#34;&gt;为什么是四次而不是三次？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\&#34;&gt;参考资料&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#n-%E8%BD%AC%E8%BD%BD%E6%BA%90\&#34;&gt;n. 转载源&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;node版本变化有些快，需要切换不同版本构建项目，使用nvm管理node是一个比较成熟的方案。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;1-安装nvm\&#34;&gt;1. 安装nvm&lt;/h2&gt;\n&lt;h3 id=\&#34;11-macos\&#34;&gt;1.1 MacOS&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;brew安装&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;brew install nvm \n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;官方脚本&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;12-linux\&#34;&gt;1.2 Linux&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;13-安装注意事项\&#34;&gt;1.3 安装注意事项&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;==&amp;gt; Caveats\nPlease note that upstream has asked us to make explicit managing\nnvm via Homebrew is unsupported by them and you should check any\nproblems against the standard nvm install method prior to reporting.\n\nYou should create NVM&#39;s working directory if it doesn&#39;t exist:\n\n  mkdir ~/.nvm\n\nAdd the following to ~/.zshrc or your desired shell\nconfiguration file:\n\n  export NVM_DIR=&amp;quot;$HOME/.nvm&amp;quot;\n  [ -s &amp;quot;/opt/homebrew/opt/nvm/nvm.sh&amp;quot; ] &amp;amp;&amp;amp; . &amp;quot;/opt/homebrew/opt/nvm/nvm.sh&amp;quot;  # This loads nvm\n  [ -s &amp;quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&amp;quot; ] &amp;amp;&amp;amp; . &amp;quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&amp;quot;  # This loads nvm bash_completion\n\nYou can set $NVM_DIR to any location, but leaving it unchanged from\n/opt/homebrew/opt/nvm will destroy any nvm-installed Node installations\nupon upgrade/reinstall.\n\nType `nvm help` for further information.\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;创建nvm目录&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mkdir ~/.nvm\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;处理&lt;code&gt;~/.zshrc&lt;/code&gt;或者&lt;code&gt;~/.bashrc&lt;/code&gt;（此处zsh举例）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;  export NVM_DIR=&amp;quot;$HOME/.nvm&amp;quot;\n  [ -s &amp;quot;/opt/homebrew/opt/nvm/nvm.sh&amp;quot; ] &amp;amp;&amp;amp; . &amp;quot;/opt/homebrew/opt/nvm/nvm.sh&amp;quot;  # This loads nvm\n  [ -s &amp;quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&amp;quot; ] &amp;amp;&amp;amp; . &amp;quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&amp;quot;  # This loads nvm bash_completion\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;14-nvm使用说明\&#34;&gt;1.4 nvm使用说明&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 显示服务器端版本列表\nnvm ls-remote\n# 安装指定版本\nnvm install vXX.XX.XX\n# 设置默认的版本\nnvm alias default vXX.XX.XX\n# 显示本地下载的版本列表\nnvm list\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;2-配置镜像加速\&#34;&gt;2. 配置镜像加速&lt;/h2&gt;\n&lt;h3 id=\&#34;21-nvm加速\&#34;&gt;2.1 nvm加速&lt;/h3&gt;\n&lt;p&gt;需要设置环境变量&lt;code&gt;NVM_NODEJS_ORG_MIRROR&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 临时设置\nexport NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node\n# 配置上述命令到bashrc/zshrc中保持生效\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;22-npm加速\&#34;&gt;2.2 npm加速&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 查看当前registry\nnpm config -g get registry\n# 设置registry\nnpm config -g set registry https://registry.npm.taobao.org\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;23-yarn配置\&#34;&gt;2.3 yarn配置&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 安装yarn\nnpm install -g yarn\n# 查看yarn registry\nyarn config get registry\n# 设置yarn registry\nyarn config set registry http://registry.npm.taobao.org/\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;macos-xia-shi-yong-nvm-guan-li-node-huan-jing&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;node版本变化有些快，需要切换不同版本构建项目，使用nvm管理node是一个比较成熟的方案。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;MacOS 下使用nvm管理node环境&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-04-13 10:34:06&#34;,&#34;dateFormat&#34;:&#34;2021-04-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/macos-xia-shi-yong-nvm-guan-li-node-huan-jing/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:153000,&#34;words&#34;:476,&#34;minutes&#34;:3},&#34;description&#34;:&#34;node版本变化有些快，需要切换不同版本构建项目，使用nvm管理node是一个比较成熟的方案。\n\n1. 安装nvm\n1.1 MacOS\n\nbrew安装\n\nbrew install nvm \n\n\n官方脚本\n\ncurl -o- https://...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%AE%89%E8%A3%85nvm\&#34;&gt;1. 安装nvm&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#11-macos\&#34;&gt;1.1 MacOS&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#12-linux\&#34;&gt;1.2 Linux&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#13-%E5%AE%89%E8%A3%85%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\&#34;&gt;1.3 安装注意事项&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#14-nvm%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E\&#34;&gt;1.4 nvm使用说明&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F\&#34;&gt;2. 配置镜像加速&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#21-nvm%E5%8A%A0%E9%80%9F\&#34;&gt;2.1 nvm加速&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#22-npm%E5%8A%A0%E9%80%9F\&#34;&gt;2.2 npm加速&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#23-yarn%E9%85%8D%E7%BD%AE\&#34;&gt;2.3 yarn配置&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;github访问日益困难,配置git服务代理以快速clone代码🐶&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;&lt;em&gt;&lt;strong&gt;技术方案转载于&lt;a href=\&#34;http://www.chenhe.cc/p/406\&#34;&gt;http://www.chenhe.cc/p/406&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;http-代理\&#34;&gt;HTTP 代理&lt;/h2&gt;\n&lt;h3 id=\&#34;配置全局代理\&#34;&gt;配置全局代理&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# HTTP 代理\ngit config --global http.proxy http://127.0.0.1:7890\ngit config --global https.proxy http://127.0.0.1:7890\n\n# Socks5 代理\ngit config --global http.proxy socks5://127.0.0.1:7890\ngit config --global https.proxy socks5://127.0.0.1:7890\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注意这里的&lt;code&gt;socks5&lt;/code&gt;仅仅是代理使用的协议，它依然是针对 http 设置的，所以仅对 http 协议的仓库有效。使用 &lt;code&gt;git@xxx &lt;/code&gt;这种 ssh 连接的不会使用代理。&lt;/p&gt;\n&lt;h3 id=\&#34;分域名设置代理\&#34;&gt;分域名设置代理&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;git config --global http.https://github.com.proxy http://127.0.0.1:7890\ngit config --global https.https://github.com.proxy https://127.0.0.1:7890\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;ssh-代理\&#34;&gt;SSH 代理&lt;/h2&gt;\n&lt;p&gt;SSH 代理需要在密钥目录 (&lt;code&gt;~/.ssh&lt;/code&gt;) (Windows 下是 &lt;code&gt;C:\\Users\\{UserName}\\.ssh&lt;/code&gt;) 新建一个 config 文件，没有后缀名。&lt;/p&gt;\n&lt;h3 id=\&#34;linuxmacos-系统写入以下配置\&#34;&gt;Linux/MacOS 系统写入以下配置：&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 需要 netcat\nHost github.com\n  User git\n  Port 22\n  Hostname github.com\n  TCPKeepAlive yes\n  ProxyCommand nc -v -x 127.0.0.1:1080 %h %p\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;windows系统配置\&#34;&gt;Windows系统配置&lt;/h3&gt;\n&lt;p&gt;需要额外安装&lt;code&gt;connect.exe&lt;/code&gt;程序,如果找不到 connect 命令那么指定其绝对路径，一般在 git 安装目录下 \\mingw64\\bin\\connect.exe。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;Host github.com\n  User git\n  Port 22\n  Hostname github.com\n  TCPKeepAlive yes\n  # -S 为 socks, -H 为 HTTP\n  ProxyCommand connect -S 127.0.0.1:1080 %h %p\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;git-httpssh-dai-li-pei-zhi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;github访问日益困难,配置git服务代理以快速clone代码🐶&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Git HTTP+SSH 代理配置&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-04-07 23:57:20&#34;,&#34;dateFormat&#34;:&#34;2021-04-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/git-httpssh-dai-li-pei-zhi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:92000,&#34;words&#34;:322,&#34;minutes&#34;:2},&#34;description&#34;:&#34;github访问日益困难,配置git服务代理以快速clone代码🐶\n\n技术方案转载于http://www.chenhe.cc/p/406\nHTTP 代理\n配置全局代理\n# HTTP 代理\ngit config --global http....&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#http-%E4%BB%A3%E7%90%86\&#34;&gt;HTTP 代理&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86\&#34;&gt;配置全局代理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E5%9F%9F%E5%90%8D%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86\&#34;&gt;分域名设置代理&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ssh-%E4%BB%A3%E7%90%86\&#34;&gt;SSH 代理&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#linuxmacos-%E7%B3%BB%E7%BB%9F%E5%86%99%E5%85%A5%E4%BB%A5%E4%B8%8B%E9%85%8D%E7%BD%AE\&#34;&gt;Linux/MacOS 系统写入以下配置：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#windows%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE\&#34;&gt;Windows系统配置&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;HTTP接口在业务中速度较慢，使用curl进行排查&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;1-准备文件模版curltxt\&#34;&gt;1. 准备文件模版（curl.txt）&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;\\n\n            time_namelookup:  %{time_namelookup}\\n\n               time_connect:  %{time_connect}\\n\n            time_appconnect:  %{time_appconnect}\\n\n           time_pretransfer:  %{time_pretransfer}\\n\n              time_redirect:  %{time_redirect}\\n\n         time_starttransfer:  %{time_starttransfer}\\n\n                            ----------\\n\n                 time_total:  %{time_total}\\n\n\\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;2-使用curl带以下参数请求\&#34;&gt;2. 使用curl带以下参数请求&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;curl -w &amp;quot;@curl.txt&amp;quot; -o /dev/null -s https://api.example.com\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[@ ~]# curl -w &amp;quot;@curl&amp;quot; -o /dev/null -s https://api.example.com\n\n            time_namelookup:  0.004\n               time_connect:  0.014\n            time_appconnect:  0.141\n           time_pretransfer:  0.141\n              time_redirect:  0.000\n         time_starttransfer:  0.153\n                            ----------\n                 time_total:  0.165\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;3-参数说明\&#34;&gt;3. 参数说明&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;NAMELOOKUP：从开始计算，域名解析完成的耗时&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;CURLINFO_NAMELOOKUP_TIME. The time it took from the start until the name resolving was completed.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;CONNECT：从开始计算，TCP建立完成的耗时&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;CURLINFO_CONNECT_TIME. The time it took from the start until the connect to the remote host (or proxy) was completed.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;APPCONNECT：从开始计算，应用层（SSL，在TCP之上的应用层）连接/握手完成的耗时&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;CURLINFO_APPCONNECT_TIME. The time it took from the start until the SSL connect/handshake with the remote host was completed. (Added in in 7.19.0)&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;PRETRANSFER：从开始计算，准备开始传输数据的耗时&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;CURLINFO_PRETRANSFER_TIME. The time it took from the start until the file transfer is just about to begin. This includes all pre-transfer commands and negotiations that are specific to the particular protocol(s) involved.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;STARTTRANSFER：从开始计算，开始传输数据的耗时（libcurl接收到第一个字节）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;CURLINFO_STARTTRANSFER_TIME. The time it took from the start until the first byte is received by libcurl.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;TOTAL：总的耗时&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;CURLINFO_TOTAL_TIME. Total time of the previous request.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;REDIRECT：整个过程重定向的耗时，如果整个过程没有重定向，这个时间为0&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;em&gt;&lt;strong&gt;文章来源于互联网,原地址&lt;a href=\&#34;https://www.cnblogs.com/lnlvinso/p/9775484.html\&#34;&gt;https://www.cnblogs.com/lnlvinso/p/9775484.html&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;linux-xia-shi-yong-curl-cha-kan-http-qing-qiu-ge-jie-duan-hao-shi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;HTTP接口在业务中速度较慢，使用curl进行排查&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Linux下使用curl查看http请求各阶段耗时&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-04-07 23:50:42&#34;,&#34;dateFormat&#34;:&#34;2021-04-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/linux-xia-shi-yong-curl-cha-kan-http-qing-qiu-ge-jie-duan-hao-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:113000,&#34;words&#34;:381,&#34;minutes&#34;:2},&#34;description&#34;:&#34;HTTP接口在业务中速度较慢，使用curl进行排查\n\n1. 准备文件模版（curl.txt）\n\\n\n            time_namelookup:  %{time_namelookup}\\n\n               time...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%87%86%E5%A4%87%E6%96%87%E4%BB%B6%E6%A8%A1%E7%89%88curltxt\&#34;&gt;1. 准备文件模版（curl.txt）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E4%BD%BF%E7%94%A8curl%E5%B8%A6%E4%BB%A5%E4%B8%8B%E5%8F%82%E6%95%B0%E8%AF%B7%E6%B1%82\&#34;&gt;2. 使用curl带以下参数请求&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E\&#34;&gt;3. 参数说明&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;go 启用CGO_ENABLED遇到报错的解决方案&lt;br&gt;\n&lt;code&gt;gcc_libinit_windows.c:7:10: fatal error: &#39;windows.h&#39; file not found&lt;/code&gt;&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;在macos下启用cgo_enabled的交叉编译\&#34;&gt;在macOS下启用CGO_ENABLED的交叉编译&lt;/h2&gt;\n&lt;p&gt;在启用CGO_ENABLED的情况下，尝试使用下面命令进行Windows平台的交叉编译：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;$ CGO_ENABLED=1 GOOS=windows GOARCH=386 go build -x -v -ldflags &amp;quot;-s -w&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;出现错误如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# runtime/cgo\ngcc_libinit_windows.c:7:10: fatal error: &#39;windows.h&#39; file not found\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;安装mingw-w64\&#34;&gt;安装mingw-w64&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;$ brew install mingw-w64\n==&amp;gt; Downloading https://homebrew.bintray.com/bottles/isl-0.22.1.big_sur.bottle.tar.gz\n==&amp;gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/15376fb7aff7adec3786e6a31ec9b5cad585fd01ecbd5c4744ef9461b10965ff?response-content-disposition=attachment%3Bfilename%3D%22isl-0.22.1.big_sur.bottle.tar.gz%22&amp;amp;Policy=eyJTdGF0Z\n######################################################################## 100.0%\n==&amp;gt; Downloading https://homebrew.bintray.com/bottles/mpfr-4.1.0.big_sur.bottle.tar.gz\n==&amp;gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/1e8eb0326f62d3461d420d98af6fc088daca481cae89fd77a75b420d2e76d776?response-content-disposition=attachment%3Bfilename%3D%22mpfr-4.1.0.big_sur.bottle.tar.gz%22&amp;amp;Policy=eyJTdGF0Z\n######################################################################## 100.0%\n==&amp;gt; Downloading https://homebrew.bintray.com/bottles/libmpc-1.2.1.big_sur.bottle.tar.gz\n######################################################################## 100.0%\n==&amp;gt; Downloading https://homebrew.bintray.com/bottles/mingw-w64-8.0.0.catalina.bottle.tar.gz\n==&amp;gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/d294bc0e960294bf573b9da364a8d95a06a257aec8f388c16e2b975ed8e4410c?response-content-disposition=attachment%3Bfilename%3D%22mingw-w64-8.0.0.catalina.bottle.tar.gz%22&amp;amp;Policy=eyJ\n######################################################################## 100.0%\n==&amp;gt; Installing dependencies for mingw-w64: isl, mpfr and libmpc\n==&amp;gt; Installing mingw-w64 dependency: isl\n==&amp;gt; Pouring isl-0.22.1.big_sur.bottle.tar.gz\n🍺  /usr/local/Cellar/isl/0.22.1: 72 files, 4.9MB\n==&amp;gt; Installing mingw-w64 dependency: mpfr\n==&amp;gt; Pouring mpfr-4.1.0.big_sur.bottle.tar.gz\n🍺  /usr/local/Cellar/mpfr/4.1.0: 30 files, 5.2MB\n==&amp;gt; Installing mingw-w64 dependency: libmpc\n==&amp;gt; Pouring libmpc-1.2.1.big_sur.bottle.tar.gz\n🍺  /usr/local/Cellar/libmpc/1.2.1: 13 files, 425.0KB\n==&amp;gt; Installing mingw-w64\n==&amp;gt; Pouring mingw-w64-8.0.0.catalina.bottle.tar.gz\n🍺  /usr/local/Cellar/mingw-w64/8.0.0: 7,402 files, 854.6MB\n$ which x86_64-w64-mingw32-gcc\n/usr/local/bin/x86_64-w64-mingw32-gcc\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;编译x64\&#34;&gt;编译x64&lt;/h2&gt;\n&lt;h3 id=\&#34;可执行文件\&#34;&gt;可执行文件&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;$ CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ GOOS=windows GOARCH=amd64 go build -x -v -ldflags &amp;quot;-s -w&amp;quot; -o app.exe\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;静态库\&#34;&gt;静态库&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;$ CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ GOOS=windows GOARCH=amd64 go build -buildmode=c-archive -x -v -ldflags &amp;quot;-s -w&amp;quot; -o bin app.go\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;动态库\&#34;&gt;动态库&lt;/h3&gt;\n&lt;p&gt;将&lt;code&gt;-buildmode=c-archive&lt;/code&gt;改为&lt;code&gt;-buildmode=c-shared&lt;/code&gt;即可&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;&lt;strong&gt;转载资料 出处:&lt;a href=\&#34;https://www.dllhook.com/post/244.html\&#34;&gt;https://www.dllhook.com/post/244.html&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;zai-macos-xia-qi-yong-cgo_enabled-de-jiao-cha-bian-yi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;go 启用CGO_ENABLED遇到报错的解决方案&lt;br&gt;\n&lt;code&gt;gcc_libinit_windows.c:7:10: fatal error: &#39;windows.h&#39; file not found&lt;/code&gt;&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;在macOS下启用CGO_ENABLED的交叉编译&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-03-26 20:15:00&#34;,&#34;dateFormat&#34;:&#34;2021-03-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/zai-macos-xia-qi-yong-cgo_enabled-de-jiao-cha-bian-yi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:166000,&#34;words&#34;:479,&#34;minutes&#34;:3},&#34;description&#34;:&#34;go 启用CGO_ENABLED遇到报错的解决方案\ngcc_libinit_windows.c:7:10: fatal error: &#39;windows.h&#39; file not found\n\n在macOS下启用CGO_ENABLED的交叉编译...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%A8macos%E4%B8%8B%E5%90%AF%E7%94%A8cgo_enabled%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91\&#34;&gt;在macOS下启用CGO_ENABLED的交叉编译&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85mingw-w64\&#34;&gt;安装mingw-w64&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E8%AF%91x64\&#34;&gt;编译x64&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6\&#34;&gt;可执行文件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%99%E6%80%81%E5%BA%93\&#34;&gt;静态库&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%A8%E6%80%81%E5%BA%93\&#34;&gt;动态库&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;capabilities-of-the-downward-api\&#34;&gt;Capabilities of the Downward API&lt;/h3&gt;\n&lt;h4 id=\&#34;feildref即可以暴露的pod定义中的项目\&#34;&gt;feildRef，即可以暴露的pod定义中的项目：&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;spec.nodeName - the node’s name\nstatus.hostIP - the node’s IP\nmetadata.name - the pod’s name\nmetadata.namespace - the pod’s namespace\nstatus.podIP - the pod’s IP address\nspec.serviceAccountName - the pod’s service account name\nmetadata.uid - the pod’s UID\nmetadata.labels[&#39;&amp;lt;KEY&amp;gt;&#39;] - the value of the pod’s label &amp;lt;KEY&amp;gt; (for example, metadata.labels[&#39;mylabel&#39;]); available in Kubernetes 1.9+\nmetadata.annotations[&#39;&amp;lt;KEY&amp;gt;&#39;] - the value of the pod’s annotation &amp;lt;KEY&amp;gt; (for example, metadata.annotations[&#39;myannotation&#39;]); available in Kubernetes 1.9+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;resourcefieldref即可以暴露的container定义中的项目\&#34;&gt;resourceFieldRef，即可以暴露的container定义中的项目：&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;A Container’s CPU limit&lt;/li&gt;\n&lt;li&gt;A Container’s CPU request&lt;/li&gt;\n&lt;li&gt;A Container’s memory limit&lt;/li&gt;\n&lt;li&gt;A Container’s memory request&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;kubernetes-bao-lu-xin-xi-gei-pod&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Kubernetes暴露信息给Pod&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-02-06 16:53:01&#34;,&#34;dateFormat&#34;:&#34;2021-02-06&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/kubernetes-bao-lu-xin-xi-gei-pod/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:51000,&#34;words&#34;:148,&#34;minutes&#34;:1},&#34;description&#34;:&#34;Capabilities of the Downward API\nfeildRef，即可以暴露的pod定义中的项目：\nspec.nodeName - the node’s name\nstatus.hostIP - the node’s IP...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#capabilities-of-the-downward-api\&#34;&gt;Capabilities of the Downward API&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#feildref%E5%8D%B3%E5%8F%AF%E4%BB%A5%E6%9A%B4%E9%9C%B2%E7%9A%84pod%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E9%A1%B9%E7%9B%AE\&#34;&gt;feildRef，即可以暴露的pod定义中的项目：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#resourcefieldref%E5%8D%B3%E5%8F%AF%E4%BB%A5%E6%9A%B4%E9%9C%B2%E7%9A%84container%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E9%A1%B9%E7%9B%AE\&#34;&gt;resourceFieldRef，即可以暴露的container定义中的项目：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;!-- more --&gt;\n&lt;h2 id=\&#34;rancher访问ldap的默认规则\&#34;&gt;Rancher访问LDAP的默认规则&lt;/h2&gt;\n&lt;h3 id=\&#34;用户\&#34;&gt;用户&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;搜索起点: ou=Users,dc=thecover,dc=cn\n对象分类: inetOrgPerson\n登录字段: uid\n名称字段: cn\n搜索字段: uid|sn|givenName\n启用字段:\n禁用位掩码: 0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;用户组\&#34;&gt;用户组&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;搜索起点: ou=Groups,dc=thecover,dc=cn\n对象分类: groupOfNames\n名称字段: cn\n搜索字段: cn\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;创建只读用户\&#34;&gt;创建只读用户&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;创建用户（可以用管理工具创建同objectClass的用户）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;#密码\nLDAP_READONLY_USER_PW=&#39;密码&#39;\n#Base DN\nLDAP_BASE_DN=&#39;dc=thecover,dc=cn&#39;\ncat &amp;lt;&amp;lt;EOF &amp;gt; ./readOnly.ldif\ndn: cn=readonly,${LDAP_BASE_DN}\ncn: readonly\nobjectClass: simpleSecurityObject\nobjectClass: organizationalRole\ndescription: LDAP read only user\nuserPassword: ${LDAP_READONLY_USER_PW}\nEOF\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;命令行增加用户&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;ldapadd -x -D cn=Manager,dc=okcoin,dc=com -w &#39;密码&#39; -f ./readOnly.ldif\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;配置权限&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;LDAP_BASE_DN=&#39;dc=thecover,dc=cn&#39;\ncat &amp;lt;&amp;lt;EOF &amp;gt; readonly-user-acl.ldif\ndn: olcDatabase={1}hdb,cn=config\nchangetype: modify\ndelete: olcAccess\n-\nadd: olcAccess\nolcAccess: {0}to attrs=userPassword,shadowLastChange \n by dn=&amp;quot;cn=admin,dc=thecover,dc=cn&amp;quot; write \n by anonymous auth \n by self write \n by dn=&amp;quot;cn=readonly,dc=thecover,dc=cn&amp;quot; read \n by * none\nolcAccess: {1}to dn.base=&amp;quot;&amp;quot; by * read\nolcAccess: {2}to * by dn=&amp;quot;cn=Manager,dc=thecover,dc=cn&amp;quot; write by * read\nEOF\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;ldapmodify -Y EXTERNAL -H ldapi:/// -f readonly-user-acl.ldif\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;备注&lt;br&gt;\n配置权限时需要使用&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;slapcat -b cn=config\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;定位&lt;code&gt;olcDatabase&lt;/code&gt; &lt;code&gt;config&lt;/code&gt;的位置&lt;/p&gt;\n&lt;h2 id=\&#34;ldap增加memberof属性\&#34;&gt;Ldap增加memberOf属性&lt;/h2&gt;\n&lt;p&gt;https://www.linuxprobe.com/enable-memberof-openldap.html&lt;br&gt;\nhttps://kifarunix.com/how-to-create-openldap-member-groups/&lt;/p&gt;\n&lt;h2 id=\&#34;配置缓存\&#34;&gt;配置缓存&lt;/h2&gt;\n&lt;h3 id=\&#34;查询缓存配置\&#34;&gt;查询缓存配置&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;ldapsearch -Q -LLL -Y EXTERNAL -H ldapi:/// -b cn=config &#39;olcDatabase={0}mdb&#39; olcDbindex\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;删除旧配置\&#34;&gt;删除旧配置&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;cat &amp;gt;&amp;gt; del-1mdb-index.ldif &amp;lt;&amp;lt; EOF\ndn: olcDatabase={1}mdb, cn=config\nchangetype:modify\ndelete: olcDbIndex\nolcDbIndex: uid eq\nEOF\n ldapmodify -Q -Y EXTERNAL -H ldapi:/// -f del-1mdb-index.ldif\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;新增配置\&#34;&gt;新增配置&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;cat &amp;gt;&amp;gt; mdb-index.ldif &amp;lt;&amp;lt; EOF\ndn: olcDatabase={1}mdb, cn=config\nchangetype:modify\nadd:olcDbIndex\nolcDbIndex: uid pres,eq,sub\nEOF\nldapmodify -Q -Y EXTERNAL -H ldapi:/// -f mdb-index.ldif\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;ldap-shi-yong-ji-lu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;LDAP使用记录&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-12-11 15:00:44&#34;,&#34;dateFormat&#34;:&#34;2020-12-11&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/ldap-shi-yong-ji-lu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:130000,&#34;words&#34;:412,&#34;minutes&#34;:3},&#34;description&#34;:&#34;\nRancher访问LDAP的默认规则\n用户\n搜索起点: ou=Users,dc=thecover,dc=cn\n对象分类: inetOrgPerson\n登录字段: uid\n名称字段: cn\n搜索字段: uid|sn|givenName\n启用...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#rancher%E8%AE%BF%E9%97%AEldap%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99\&#34;&gt;Rancher访问LDAP的默认规则&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%A8%E6%88%B7\&#34;&gt;用户&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%A8%E6%88%B7%E7%BB%84\&#34;&gt;用户组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E5%8F%AA%E8%AF%BB%E7%94%A8%E6%88%B7\&#34;&gt;创建只读用户&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ldap%E5%A2%9E%E5%8A%A0memberof%E5%B1%9E%E6%80%A7\&#34;&gt;Ldap增加memberOf属性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE%E7%BC%93%E5%AD%98\&#34;&gt;配置缓存&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE\&#34;&gt;查询缓存配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A0%E9%99%A4%E6%97%A7%E9%85%8D%E7%BD%AE\&#34;&gt;删除旧配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E5%A2%9E%E9%85%8D%E7%BD%AE\&#34;&gt;新增配置&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;记录使用阿里云ACK容器服务以及阿里云的各服务的总结笔记&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;1-配置阿里云slb到集群的ingress\&#34;&gt;1. 配置阿里云SLB到集群的Ingress&lt;/h2&gt;\n&lt;h3 id=\&#34;11-同时使用私网slb与公网slb配合\&#34;&gt;1.1 同时使用私网SLB与公网SLB配合&lt;/h3&gt;\n&lt;p&gt;&lt;em&gt;对于一些特殊场景，您期望容器集群内的服务既能允许公网访问，同时又希望能被同一个VPC下的其他服务直接访问（不经过公网）。您只需额外部署一个kube-system/nginx-ingress-lb-intranet服务。&lt;/em&gt;&lt;/p&gt;\n&lt;p&gt;使用阿里云创建的容器集群默认已经创建了一个绑定到公网的SLB，位于&lt;code&gt;kube-system&lt;/code&gt;下。创建一个符合期望配置的内网SLB实例，新增一个Service描述，使集群自动绑定监听到SLB。&lt;/p&gt;\n&lt;p&gt;配置模版&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-yaml\&#34;&gt;# intranet nginx ingress slb service\napiVersion: v1\nkind: Service\nmetadata:\n # 这里服务取名为nginx-ingress-lb-intranet\n name: nginx-ingress-lb-intranet\n namespace: kube-system\n labels:\n   app: nginx-ingress-lb-intranet\n annotations:\n   # 指明SLB实例地址类型为私网类型\n   service.beta.kubernetes.io/alicloud-loadbalancer-address-type: intranet\n   # 修改为您的私网SLB实例ID\n   service.beta.kubernetes.io/alicloud-loadbalancer-id: &amp;lt;YOUR_INTRANET_SLB_ID&amp;gt;\n   # 是否自动创建SLB端口监听（会覆写已有端口监听），也可手动创建端口监听\n   service.beta.kubernetes.io/alicloud-loadbalancer-force-override-listeners: &#39;true&#39;\nspec:\n type: LoadBalancer\n # route traffic to other nodes\n externalTrafficPolicy: &amp;quot;Cluster&amp;quot;\n ports:\n - port: 80\n   name: http\n   targetPort: 80\n - port: 443\n   name: https\n   targetPort: 443\n selector:\n   # select app=ingress-nginx pods\n   app: ingress-nginx\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;创建服务之后通过如下命令,查看svc状态&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt; kubectl -n kube-system get svc | grep nginx-ingress-lb\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;2-coredns的特殊用法\&#34;&gt;2. CoreDNS的特殊用法&lt;/h2&gt;\n&lt;h3 id=\&#34;21-coredns拦截域名解析\&#34;&gt;2.1 CoreDNS拦截域名解析&lt;/h3&gt;\n&lt;p&gt;在内网多个集群的场景下，有些域名需要解析到内网避免出现公网流量，之前处理方案有如下几种:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;在VPC内网内自建一个DNS服务器，将所有服务器的DNS指向自建的DNS服务器\n&lt;ul&gt;\n&lt;li&gt;问题: 需要考虑到DNS的高可用以及故障容灾难&lt;/li&gt;\n&lt;li&gt;优势: 集中化,便于统一维护管理更新&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;在主机配置Hosts文件\n&lt;ul&gt;\n&lt;li&gt;问题: 主机较多，维护成本上涨&lt;/li&gt;\n&lt;li&gt;优势: 操作简单，技术成本较低&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;K8s容器集群内CoreDNS&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Kubernetes本身具有集群DNS组件，此处使用的为CoreDNS，工作负载的DNS默认策略为&lt;code&gt;ClusterFirst&lt;/code&gt;,此时Pods内程序解析DNS会优先查询集群的DNS组件，所以此时可以在集群DNS层面进行解析拦截覆盖。&lt;/p&gt;\n&lt;p&gt;CoreDNS的配置使用的ConfigMap,而ConfigMap支持热更新,修改ConfigMap后CoreDNS自动生效。配置如下:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;.:5353 {\ncache 30\nerrors\nhealth\nkubernetes cluster.local in-addr.arpa ip6.arpa {\npods insecure\nupstream /etc/resolv.conf\nfallthrough in-addr.arpa ip6.arpa\n}\nloadbalance round_robin\nhosts {\n122.212.222.111 aaa.bbb.com\nfallthrough\n}\nprometheus 0.0.0.0:9153\nproxy . /etc/resolv.conf\nreload\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;把需要的DNS规格写入Hosts节点下，即可进行集群层面的解析配置。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;a-li-yun-k8s-zui-jia-shi-jian-bi-ji&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;记录使用阿里云ACK容器服务以及阿里云的各服务的总结笔记&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;阿里云K8s实践笔记&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-09-16 11:36:16&#34;,&#34;dateFormat&#34;:&#34;2020-09-16&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/a-li-yun-k8s-zui-jia-shi-jian-bi-ji/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:171000,&#34;words&#34;:692,&#34;minutes&#34;:3},&#34;description&#34;:&#34;记录使用阿里云ACK容器服务以及阿里云的各服务的总结笔记\n\n1. 配置阿里云SLB到集群的Ingress\n1.1 同时使用私网SLB与公网SLB配合\n对于一些特殊场景，您期望容器集群内的服务既能允许公网访问，同时又希望能被同一个VPC下的其...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91slb%E5%88%B0%E9%9B%86%E7%BE%A4%E7%9A%84ingress\&#34;&gt;1. 配置阿里云SLB到集群的Ingress&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#11-%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E7%A7%81%E7%BD%91slb%E4%B8%8E%E5%85%AC%E7%BD%91slb%E9%85%8D%E5%90%88\&#34;&gt;1.1 同时使用私网SLB与公网SLB配合&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-coredns%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95\&#34;&gt;2. CoreDNS的特殊用法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#21-coredns%E6%8B%A6%E6%88%AA%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90\&#34;&gt;2.1 CoreDNS拦截域名解析&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;telnet-检测tcp端口\&#34;&gt;Telnet 检测TCP端口&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;[root@localhost ~]# telnet 127.0.0.1 8080\nTrying 127.0.0.1...\nConnected to 127.0.0.1.\nEscape character is &#39;^]&#39;.\n^CConnection closed by foreign host.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;nc-检测tcp端口\&#34;&gt;NC 检测TCP端口&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;[root@localhost ~]# nc -vz 127.0.0.1 8906\nConnection to 127.0.0.1 8906 port [tcp/*] succeeded!\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;nc-检测udp端口\&#34;&gt;NC 检测UDP端口&lt;/h1&gt;\n&lt;p&gt;&lt;code&gt;检测udp端口的时候不会立即返回测试结果，可能需要等待几秒钟&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;[root@apexsoft ~]# nc -uz 127.0.0.1 8907\nConnection to 127.0.0.1 8907 port [udp/*] succeeded!\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;shi-yong-nc-jian-ce-tcpudp-duan-kou-kai-fang&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;使用nc检测TCP/UDP端口开放&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-08-18 21:40:09&#34;,&#34;dateFormat&#34;:&#34;2020-08-18&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/shi-yong-nc-jian-ce-tcpudp-duan-kou-kai-fang/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:34000,&#34;words&#34;:110,&#34;minutes&#34;:1},&#34;description&#34;:&#34;Telnet 检测TCP端口\n[root@localhost ~]# telnet 127.0.0.1 8080\nTrying 127.0.0.1...\nConnected to 127.0.0.1.\nEscape character is...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#telnet-%E6%A3%80%E6%B5%8Btcp%E7%AB%AF%E5%8F%A3\&#34;&gt;Telnet 检测TCP端口&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#nc-%E6%A3%80%E6%B5%8Btcp%E7%AB%AF%E5%8F%A3\&#34;&gt;NC 检测TCP端口&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#nc-%E6%A3%80%E6%B5%8Budp%E7%AB%AF%E5%8F%A3\&#34;&gt;NC 检测UDP端口&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;有需求一个系统只允许微信和钉钉访问，所以配置Nginx规则过滤UA&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;配置文件\&#34;&gt;配置文件&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-nginx\&#34;&gt;server {\n    listen       80;\n    server_name  localhost;\n    set $flag 0;\n    if ($http_user_agent !~ &amp;quot;MicroMessenger&amp;quot; ){\n        set $flag &amp;quot;${flag}1&amp;quot;;\n    }\n    if ( $http_user_agent !~ &amp;quot;DingTalk&amp;quot; ){\n        set $flag &amp;quot;${flag}2&amp;quot;;\n    }\n    if ($flag = &amp;quot;012&amp;quot;) {\n        return 403;\n    }\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n    #error_page  404              /404.html;\n    # redirect server error pages to the static page /50x.html\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;踩过的坑\&#34;&gt;踩过的坑&lt;/h1&gt;\n&lt;h2 id=\&#34;一-nginx多条件判断\&#34;&gt;一. Nginx多条件判断&lt;/h2&gt;\n&lt;h2 id=\&#34;问题\&#34;&gt;问题&lt;/h2&gt;\n&lt;p&gt;&lt;em&gt;nginx的配置中不支持if条件的逻辑与、逻辑或运算 ，并且不支持if的嵌套语法&lt;/em&gt;*&lt;/p&gt;\n&lt;h2 id=\&#34;解法\&#34;&gt;解法&lt;/h2&gt;\n&lt;p&gt;定义变量,判断变量状态。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;nginx-gen-ju-ua-guo-lu-qing-qiu&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;有需求一个系统只允许微信和钉钉访问，所以配置Nginx规则过滤UA&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Nginx根据UA过滤请求&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-05-26 16:46:34&#34;,&#34;dateFormat&#34;:&#34;2020-05-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/nginx-gen-ju-ua-guo-lu-qing-qiu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:46000,&#34;words&#34;:162,&#34;minutes&#34;:1},&#34;description&#34;:&#34;有需求一个系统只允许微信和钉钉访问，所以配置Nginx规则过滤UA\n\n配置文件\nserver {\n    listen       80;\n    server_name  localhost;\n    set $flag 0;\n    i...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\&#34;&gt;配置文件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91\&#34;&gt;踩过的坑&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80-nginx%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD\&#34;&gt;一. Nginx多条件判断&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98\&#34;&gt;问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E6%B3%95\&#34;&gt;解法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;相关链接\&#34;&gt;相关链接&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://pro.ant.design/docs/deploy-cn\&#34;&gt;AntDesign文档&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;nginx-配置文件修改\&#34;&gt;Nginx 配置文件修改&lt;/h1&gt;\n&lt;h2 id=\&#34;完整配置\&#34;&gt;完整配置&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-nginx\&#34;&gt;server {\n    listen       80;\n    server_name  localhost;\n    location / { \n    proxy_pass http://localhost:8000;\n    }\n  location /active {\n      try_files $uri $uri/ /healthy/index.html;\n  }\n\n  location /healthy/api {\n       proxy_pass   http://localhost:8888/;\n  }\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;8000端口下nginx配置\&#34;&gt;8000端口下nginx配置&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-nginx\&#34;&gt;server {\n    listen  8000;\n    server_name   localhost;\n    location / {\n        root   /usr/project/;\n        try_files $uri $uri/ /index.html;  #配合react项目的history模式去除#时用到\n        index index.html;\n        client_max_body_size    8m;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;配置文件说明\&#34;&gt;配置文件说明&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;使用try_files方式的前提是服务器安装nginx的时候需要安装相应的模块，我是通过yarn源的方式安装的，包含了所有模块，所以可以直接使用&lt;/li&gt;\n&lt;li&gt;80端口下根目录会指向8000端口（习惯把项目都放在8000端口下指向的project目录下），同时添加/active访问拦截指向healthy目录下index.html，同时添加/healthy/api是为了拦截接口访问&lt;/li&gt;\n&lt;li&gt;8000端口下root指向的是/usr/project/，此目录放置所有前端项目文件夹，一些node服务端项目也可以放进去&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;ant-design-pro项目中相关配置\&#34;&gt;Ant Design Pro项目中相关配置&lt;/h1&gt;\n&lt;h2 id=\&#34;修改config文件\&#34;&gt;修改config文件&lt;/h2&gt;\n&lt;p&gt;项目目录下config/config.js&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;export default {\n  plugins,\n  proxy,\n  block: {\n    defaultGitUrl: &#39;https://github.com/ant-design/pro-blocks&#39;,\n  },\n  hash: false, // browser 模式下为false, hash 模式下为true\n  history: &#39;browser&#39;, // 默认是 browser ， hash\n  base: &#39;/healthy/&#39;, // browser 模式下为 /healthy/ ， hash模式下为 /\n  publicPath: &#39;/healthy/&#39;, // 模式下为 /healthy/ ， hash模式下为 ./\n  targets: {\n    ie: 11,\n  },\n  devtool: isAntDesignProPreview ? &#39;source-map&#39; : false,\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;引用外部文件\&#34;&gt;引用外部文件&lt;/h2&gt;\n&lt;p&gt;pages/document.ejs中引用的外部文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-html\&#34;&gt;&amp;lt;link rel=&amp;quot;shortcut icon&amp;quot; href=&amp;quot;./favicon.ico&amp;quot;&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;接口调用配置\&#34;&gt;接口调用配置&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;// config/config.js配置文件\nglobal.api = &#39;/healthy/api&#39;\n// 调用接口页面\nlet response = await axios.get(`${global.api}/dtea-service/user/result?examId=${this.questionId}`);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;为了本地项目和发布至服务器打包文件保持一致，可以把项目中本地代理修改下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;const proxy = {\n  &#39;/healthy/api&#39;: {\n    target: &#39;http://192.136.12.211:8888&#39;,\n    changeOrigin: true,\n    pathRewrite: {\n      &#39;^/healthy/api&#39;: &#39;&#39;,\n    },\n  },\n};\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;作者：wayne1125&lt;br&gt;\n链接：https://www.jianshu.com/p/16de172d0d45&lt;br&gt;\n来源：简书&lt;br&gt;\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;reactreact-shi-zhan-1-ant-design-pro-xiang-mu-history-mo-shi-xia-xiang-guan-pei-zhi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;[React]React实战(1)——Ant Design Pro项目history模式下相关配置&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-05-25 15:14:57&#34;,&#34;dateFormat&#34;:&#34;2020-05-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/reactreact-shi-zhan-1-ant-design-pro-xiang-mu-history-mo-shi-xia-xiang-guan-pei-zhi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:133000,&#34;words&#34;:506,&#34;minutes&#34;:3},&#34;description&#34;:&#34;相关链接\nAntDesign文档\nNginx 配置文件修改\n完整配置\nserver {\n    listen       80;\n    server_name  localhost;\n    location / { \n    proxy...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5\&#34;&gt;相关链接&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#nginx-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9\&#34;&gt;Nginx 配置文件修改&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE\&#34;&gt;完整配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#8000%E7%AB%AF%E5%8F%A3%E4%B8%8Bnginx%E9%85%8D%E7%BD%AE\&#34;&gt;8000端口下nginx配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E\&#34;&gt;配置文件说明&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ant-design-pro%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE\&#34;&gt;Ant Design Pro项目中相关配置&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BF%AE%E6%94%B9config%E6%96%87%E4%BB%B6\&#34;&gt;修改config文件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6\&#34;&gt;引用外部文件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E9%85%8D%E7%BD%AE\&#34;&gt;接口调用配置&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Go 中经常初始化结构体，对于初始化方式的一些深入理解。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;当我们想要在Go语言中初始化一个结构时，其实会使用到两个完全不同的关键字，也就是 make 和 new，同时出现两个用于初始化的关键字对于初学者来说可能会感到非常困惑，不过它们两者却有着完全不同的作用。&lt;/p&gt;\n&lt;p&gt;在Go语言中，make 关键字的主要作用是初始化内置的数据结构，也就是我们在前面提到的数组、切片和 Channel，而当我们想要获取指向某个类型的指针时可以使用 new 关键字，只是知道如何使用 new 的人真的比较少，下面我们就来介绍一下 make 和 new 它们的区别以及实现原理。&lt;/p&gt;\n&lt;h1 id=\&#34;概述\&#34;&gt;概述&lt;/h1&gt;\n&lt;p&gt;虽然 make 和 new 都是能够用于初始化数据结构，但是它们两者能够初始化的结构类型却有着较大的不同，make 在Go语言中只能用于初始化语言中的基本类型：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;slice := make([]int, 0, 100)\nhash := make(map[int]bool, 10)\nch := make(chan int, 5)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这些基本类型都是语言为我们提供的，我们在前面已经介绍过了它们初始化的过程以及原理，但是在这里还是需要提醒大家注意的是，这三者返回了不同类型的数据结构：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;slice 是一个包含 data、cap 和 len 的结构体；&lt;/li&gt;\n&lt;li&gt;hash 是一个指向 hmap 结构体的指针；&lt;/li&gt;\n&lt;li&gt;ch 是一个指向 hchan 结构体的指针。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;而另一个用于初始化数据结构的关键字 new 的作用其实就非常简单了，它只是接收一个类型作为参数然后返回一个指向这个类型的指针：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;i := new(int)\nvar v int\ni := &amp;amp;v\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上述代码片段中的两种不同初始化方法其实是等价的，它们都会创建一个指向 int 零值的指针。&lt;br&gt;\n&lt;img src=\&#34;https://stardemo.github.io/post-images/1590031666594.jpeg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n到了这里我们对Go语言中这两种不同关键字的使用也有了一定的了解：&lt;code&gt;make 用于创建切片、哈希表和管道等内置数据结构，new 用于分配并创建一个指向对应类型的指针&lt;/code&gt;。&lt;/p&gt;\n&lt;h1 id=\&#34;实现原理\&#34;&gt;实现原理&lt;/h1&gt;\n&lt;p&gt;接下来我们将分别介绍 make 和 new 在初始化不同数据结构时的具体过程，我们会从编译期间和运行时两个不同的阶段理解这两个关键字的原理。&lt;/p&gt;\n&lt;h2 id=\&#34;make\&#34;&gt;make&lt;/h2&gt;\n&lt;p&gt;我们已经了解了 make 在创建数组和切片、哈希表和 Channel 的具体过程，所以在这里我们也只是会简单提及 make 相关的数据结构初始化原理。&lt;br&gt;\n&lt;img src=\&#34;https://stardemo.github.io/post-images/1590031718876.gif\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n在编译期间的类型检查阶段，Go语言其实就将代表 make 关键字的 OMAKE 节点根据参数类型的不同转换成了 OMAKESLICE、OMAKEMAP 和 OMAKECHAN 三种不同类型的节点，这些节点最终也会调用不同的运行时函数来初始化数据结构。&lt;/p&gt;\n&lt;h2 id=\&#34;new\&#34;&gt;new&lt;/h2&gt;\n&lt;p&gt;内置函数 new 会在编译期间的 SSA 代码生成阶段经过 callnew 函数的处理，如果请求创建的类型大小是 0，那么就会返回一个表示空指针的 zerobase 变量，在遇到其他情况时会将关键字转换成 newobject：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;func callnew(t *types.Type) *Node {\n    if t.NotInHeap() {\n        yyerror(&amp;quot;%v is go:notinheap; heap allocation disallowed&amp;quot;, t)\n    }\n    dowidth(t)\n \n    if t.Size() == 0 {\n        z := newname(Runtimepkg.Lookup(&amp;quot;zerobase&amp;quot;))\n        z.SetClass(PEXTERN)\n        z.Type = t\n        return typecheck(nod(OADDR, z, nil), ctxExpr)\n    }\n \n    fn := syslook(&amp;quot;newobject&amp;quot;)\n    fn = substArgTypes(fn, t)\n    v := mkcall1(fn, types.NewPtr(t), nil, typename(t))\n    v.SetNonNil(true)\n    return v\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;需要提到的是，哪怕当前变量是使用 var 进行初始化，在这一阶段也可能会被转换成 newobject 的函数调用并在堆上申请内存：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;func walkstmt(n *Node) *Node {\n    switch n.Op {\n    case ODCL:\n        v := n.Left\n        if v.Class() == PAUTOHEAP {\n            if prealloc[v] == nil {\n                prealloc[v] = callnew(v.Type)\n            }\n            nn := nod(OAS, v.Name.Param.Heapaddr, prealloc[v])\n            nn.SetColas(true)\n            nn = typecheck(nn, ctxStmt)\n            return walkstmt(nn)\n        }\n    case ONEW:\n        if n.Esc == EscNone {\n            r := temp(n.Type.Elem())\n            r = nod(OAS, r, nil)\n            r = typecheck(r, ctxStmt)\n            init.Append(r)\n            r = nod(OADDR, r.Left, nil)\n            r = typecheck(r, ctxExpr)\n            n = r\n        } else {\n            n = callnew(n.Type.Elem())\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当然这也不是绝对的，如果当前声明的变量或者参数不需要在当前作用域外生存，那么其实就不会被初始化在堆上，而是会初始化在当前函数的栈中并随着函数调用的结束而被销毁。&lt;/p&gt;\n&lt;p&gt;newobject 函数的工作就是获取传入类型的大小并调用 mallocgc 在堆上申请一片大小合适的内存空间并返回指向这片内存空间的指针：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;func newobject(typ *_type) unsafe.Pointer {\n    return mallocgc(typ.size, typ, true)\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;p&gt;最后，简单总结一下Go语言中 make 和 new 关键字的实现原理，make 关键字的主要作用是创建切片、哈希表和 Channel 等内置的数据结构，而 new 的主要作用是为类型申请一片内存空间，并返回指向这片内存的指针。&lt;/p&gt;\n&lt;p&gt;————————————————&lt;br&gt;\n版权声明：本文为CSDN博主「浅汐王」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br&gt;\n原文链接：https://blog.csdn.net/qq_32252917/java/article/details/102953438&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;diff-make-and-new&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;Go 中经常初始化结构体，对于初始化方式的一些深入理解。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;[Go]make和new关键字的区别及实现原理&#34;,&#34;tags&#34;:[{&#34;index&#34;:-1,&#34;name&#34;:&#34;Golang&#34;,&#34;slug&#34;:&#34;Golang&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://stardemo.github.io/tag/Golang/&#34;}],&#34;date&#34;:&#34;2020-05-21 11:16:43&#34;,&#34;dateFormat&#34;:&#34;2020-05-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/diff-make-and-new/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:314000,&#34;words&#34;:1341,&#34;minutes&#34;:6},&#34;description&#34;:&#34;Go 中经常初始化结构体，对于初始化方式的一些深入理解。\n\n当我们想要在Go语言中初始化一个结构时，其实会使用到两个完全不同的关键字，也就是 make 和 new，同时出现两个用于初始化的关键字对于初学者来说可能会感到非常困惑，不过它们两者...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A6%82%E8%BF%B0\&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\&#34;&gt;实现原理&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#make\&#34;&gt;make&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#new\&#34;&gt;new&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;日志采集方式\&#34;&gt;日志采集方式&lt;/h2&gt;\n&lt;p&gt;日志作为任一系统不可或缺的部分，在K8S的官方文档中也介绍了多种的日志采集形式，总结起来主要有下述3种：原生方式、DaemonSet方式和Sidecar方式。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;原生方式：使用 kubectl logs 直接在查看本地保留的日志，或者通过docker engine的 log driver 把日志重定向到文件、syslog、fluentd等系统中。&lt;/li&gt;\n&lt;li&gt;DaemonSet方式：在K8S的每个node上部署日志agent，由agent采集所有容器的日志到服务端。&lt;/li&gt;\n&lt;li&gt;Sidecar方式：一个POD中运行一个sidecar的日志agent容器，用于采集该POD主容器产生的日志。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://stardemo.github.io/post-images/1589181137428.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;采集方式对比\&#34;&gt;采集方式对比&lt;/h2&gt;\n&lt;p&gt;每种采集方式都有一定的优劣势，这里我们进行简单的对比：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://stardemo.github.io/post-images/1589180900695.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;从上述表格中可以看出：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;原生方式相对功能太弱，一般不建议在生产系统中使用，否则问题调查、数据统计等工作很难完成；&lt;/li&gt;\n&lt;li&gt;DaemonSet方式在每个节点只允许一个日志agent，相对资源占用要小很多，但扩展性、租户隔离性受限，比较适用于功能单一或业务不是很多的集群；&lt;/li&gt;\n&lt;li&gt;Sidecar方式为每个POD单独部署日志agent，相对资源占用较多，但灵活性以及多租户隔离性较强，建议大型的K8S集群或作为PAAS平台为多个业务方服务的集群使用该方式。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;作者：阿里云云栖号\n链接：https://www.jianshu.com/p/72f34de4dd35\n来源：简书\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;kubernetes-ri-zhi-cai-ji-sidecar-mo-shi-jie-shao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Kubernetes日志采集Sidecar模式介绍&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-05-11 15:05:52&#34;,&#34;dateFormat&#34;:&#34;2020-05-11&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/kubernetes-ri-zhi-cai-ji-sidecar-mo-shi-jie-shao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:81000,&#34;words&#34;:384,&#34;minutes&#34;:2},&#34;description&#34;:&#34;日志采集方式\n日志作为任一系统不可或缺的部分，在K8S的官方文档中也介绍了多种的日志采集形式，总结起来主要有下述3种：原生方式、DaemonSet方式和Sidecar方式。\n\n原生方式：使用 kubectl logs 直接在查看本地保留的日...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E6%96%B9%E5%BC%8F\&#34;&gt;日志采集方式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%87%E9%9B%86%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94\&#34;&gt;采集方式对比&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;👏  博客搬家啦  &lt;strong&gt;Github Pages&lt;/strong&gt; ！&lt;br&gt;\n👏  文章逐渐迁移整理中🙏 ！&lt;br&gt;\n👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;\n...&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意...&lt;br&gt;\n&lt;a href=\&#34;https://github.com/getgridea/gridea\&#34;&gt;Github&lt;/a&gt;&lt;br&gt;\n&lt;a href=\&#34;https://gridea.dev/\&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;\n&lt;a href=\&#34;http://fehey.com/\&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;特性\&#34;&gt;特性👇&lt;/h2&gt;\n&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;\n&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;\n&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;\n&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;\n&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;\n&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;\n&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=\&#34;https://github.com/gitalk/gitalk\&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=\&#34;https://github.com/SukkaW/DisqusJS\&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;\n&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;\n&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;\n&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;\n&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;\n&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;\n&lt;p&gt;😘 Enjoy~&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;hello-gridea-blog&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;👏  博客搬家啦  &lt;strong&gt;Github Pages&lt;/strong&gt; ！&lt;br&gt;\n👏  文章逐渐迁移整理中🙏 ！&lt;br&gt;\n👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;\n...&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Hello Gridea&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Gridea&#34;,&#34;slug&#34;:&#34;hgjLRJtgV&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://stardemo.github.io/tag/hgjLRJtgV/&#34;}],&#34;date&#34;:&#34;2020-04-18 08:00:00&#34;,&#34;dateFormat&#34;:&#34;2020-04-18&#34;,&#34;feature&#34;:&#34;https://stardemo.github.io/post-images/hello-gridea-blog.png&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/hello-gridea-blog/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:66000,&#34;words&#34;:314,&#34;minutes&#34;:2},&#34;description&#34;:&#34;👏  博客搬家啦  Github Pages ！\n👏  文章逐渐迁移整理中🙏 ！\n👏  欢迎使用 Gridea ！\n...\n\n✍️  Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意...\nGi...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%89%B9%E6%80%A7\&#34;&gt;特性👇&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;一-安装\&#34;&gt;一. 安装&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;1.Ubuntu/Debian安装&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;sudo apt-get install dnsutils\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;2.CentOs/RedHat安装&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;yum install bind-utils -y\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;二-使用\&#34;&gt;二. 使用&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;1.简单查询&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;dig DOMAIN　\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;2.按记录类型查询，默认为A记录&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;dig DOMAIN cname\ndig DOMAIN mx\ndig DOMAIN AAAA\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;3.指定DNS服务器&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;dig  DOMAIN MX  8.8.8.8\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;4.从根域逐步查询的过程：+trace&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;dig DOMAIN +trace\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;5.返回简洁的查询结果&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;dig DOMAIN +short\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;linux-chang-yong-ming-ling-dig&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Linux 常用命令dig&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-04-16 10:48:37&#34;,&#34;dateFormat&#34;:&#34;2020-04-16&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/linux-chang-yong-ming-ling-dig/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:28000,&#34;words&#34;:98,&#34;minutes&#34;:1},&#34;description&#34;:&#34;一. 安装\n\n1.Ubuntu/Debian安装\n\nsudo apt-get install dnsutils\n\n\n2.CentOs/RedHat安装\n\nyum install bind-utils -y\n\n二. 使用\n\n1.简单查询\n\nd...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80-%E5%AE%89%E8%A3%85\&#34;&gt;一. 安装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C-%E4%BD%BF%E7%94%A8\&#34;&gt;二. 使用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;prometheus四种数据类型\&#34;&gt;Prometheus四种数据类型&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;Counter&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;code&gt;Counter&lt;/code&gt;用于累计值，例如记录请求次数、任务完成数、错误发生次数。一直增加，不会减少。重启进程后，会被重置。&lt;/p&gt;\n&lt;p&gt;例如：&lt;br&gt;\n&lt;code&gt;http_response_total{method=”GET”,endpoint=”/api/tracks”} 100&lt;/code&gt;&lt;br&gt;\n10秒后抓取&lt;br&gt;\n&lt;code&gt;http_response_total{method=”GET”,endpoint=”/api/tracks”} 100&lt;/code&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Gauge&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;code&gt;Gauge&lt;/code&gt;常规数值，例如 温度变化、内存使用变化。可变大，可变小。重启进程后，会被重置。&lt;/p&gt;\n&lt;p&gt;例如：&lt;br&gt;\n&lt;code&gt;memory_usage_bytes{host=”master-01″} 100 &amp;lt; 抓取值&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;memory_usage_bytes{host=”master-01″} 30&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;memory_usage_bytes{host=”master-01″} 50&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;memory_usage_bytes{host=”master-01″} 80 &amp;lt; 抓取值&lt;/code&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Histogram&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;code&gt;Histogram&lt;/code&gt;（直方图）可以理解为柱状图的意思，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。它特别之处是可以对记录的内容进行分组，提供&lt;code&gt;count&lt;/code&gt;和&lt;code&gt;sum&lt;/code&gt;全部值的功能。&lt;/p&gt;\n&lt;p&gt;例如：&lt;br&gt;\n&lt;code&gt;{小于10=5次，小于20=1次，小于30=2次}&lt;/code&gt;&lt;br&gt;\ncount=7次，sum=7次的求和值。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Summary&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;code&gt;Summary&lt;/code&gt;和&lt;code&gt;Histogram&lt;/code&gt;十分相似，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。同样提供 count 和 sum 全部值的功能。&lt;/p&gt;\n&lt;p&gt;例如：count=7次，sum=7次的值求值。&lt;/p&gt;\n&lt;p&gt;它提供一个quantiles的功能，可以按%比划分跟踪的结果。例如：quantile取值0.95，表示取采样值里面的95%数据。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;prometheus-shi-yong-ji-lu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Prometheus使用记录&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-04-13 14:24:06&#34;,&#34;dateFormat&#34;:&#34;2020-04-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/prometheus-shi-yong-ji-lu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:75000,&#34;words&#34;:319,&#34;minutes&#34;:2},&#34;description&#34;:&#34;Prometheus四种数据类型\n\nCounter\n\nCounter用于累计值，例如记录请求次数、任务完成数、错误发生次数。一直增加，不会减少。重启进程后，会被重置。\n例如：\nhttp_response_total{method=”GET”...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#prometheus%E5%9B%9B%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\&#34;&gt;Prometheus四种数据类型&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;基于现有的docker凭证文件创建secret\&#34;&gt;基于现有的Docker凭证文件创建Secret&lt;/h2&gt;\n&lt;p&gt;&lt;a href=\&#34;https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/\&#34;&gt;refrence: kubernetes-pull image private registry &lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;A Kubernetes cluster uses the Secret of &lt;code&gt;docker-registry&lt;/code&gt; type to authenticate with a container registry to pull a private image.&lt;/p&gt;\n&lt;p&gt;If you already ran &lt;code&gt;docker login&lt;/code&gt;, you can copy that credential into Kubernetes:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;kubectl create secret generic regcred \\\n    --from-file=.dockerconfigjson=&amp;lt;path/to/.docker/config.json&amp;gt; \\\n    --type=kubernetes.io/dockerconfigjson\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you need more control (for example, to set a namespace or a label on the new secret) then you can customise the Secret before storing it. Be sure to:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;set the name of the data item to &lt;code&gt;.dockerconfigjson&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;base64 encode the docker file and paste that string, unbroken as the value for field &lt;code&gt;data[&amp;quot;.dockerconfigjson&amp;quot;]&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;set type to &lt;code&gt;kubernetes.io/dockerconfigjson&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;If you get the error message&lt;br&gt;\n&lt;code&gt;error: no objects passed to create&lt;/code&gt;, it may mean the base64 encoded string is invalid. If you get an error message like&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Secret &amp;quot;myregistrykey&amp;quot; is invalid: \ndata[.dockerconfigjson]: invalid value ...\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;, it means the base64 encoded string in the data was successfully decoded, but could not be parsed as a &lt;code&gt;.docker/config.json&lt;/code&gt; file.&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;gitlab-runner-shi-yong-ji-lu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Gitlab-runner使用记录&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-04-08 17:11:28&#34;,&#34;dateFormat&#34;:&#34;2020-04-08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/gitlab-runner-shi-yong-ji-lu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:71000,&#34;words&#34;:196,&#34;minutes&#34;:2},&#34;description&#34;:&#34;基于现有的Docker凭证文件创建Secret\nrefrence: kubernetes-pull image private registry \nA Kubernetes cluster uses the Secret of docker...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E4%BA%8E%E7%8E%B0%E6%9C%89%E7%9A%84docker%E5%87%AD%E8%AF%81%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BAsecret\&#34;&gt;基于现有的Docker凭证文件创建Secret&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;动机\&#34;&gt;动机：&lt;/h1&gt;\n&lt;p&gt;使用&lt;code&gt;Gridea&lt;/code&gt;书写博客使用iCloud Drive进行目录同步，将数据目录设置到&lt;code&gt;iCloud Drive&lt;/code&gt;下，但是并不想每次同步渲染结果的&lt;code&gt;output&lt;/code&gt;目录。&lt;/p&gt;\n&lt;h1 id=\&#34;解法\&#34;&gt;解法&lt;/h1&gt;\n&lt;p&gt;查询自 - 知乎 &lt;a href=\&#34;%22https://www.zhihu.com/question/300993426/answer/539337720%22\&#34;&gt;iCloud Drive同步文件时，如何忽略指定目录？&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;原文描述\&#34;&gt;原文描述&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;# it is okay to delete the target folder since it will be rebuilt by maven\nrm -r target\n# create a nosync folder which will not be in iCloud\nmkdir target.nosync\n# create a symbolic link named &amp;quot;target&amp;quot; so that maven can find the target.nosync folder\nln -s `pwd`/target.nosync target\n# rebuild the project\nmvn package\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;实践\&#34;&gt;实践&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt; ~/Library/Mobile Documents/com~apple~CloudDocs/Gridea : rm -rf output\n ~/Library/Mobile Documents/com~apple~CloudDocs/Gridea : mkdir output.nosync\n ~/Library/Mobile Documents/com~apple~CloudDocs/Gridea : ln -s output.nosync output\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;icloud-drive-tong-bu-wen-jian-shi-hu-lue-zhi-ding-mu-lu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;iCloud Drive同步文件时，忽略指定目录&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-04-03 21:33:11&#34;,&#34;dateFormat&#34;:&#34;2020-04-03&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/icloud-drive-tong-bu-wen-jian-shi-hu-lue-zhi-ding-mu-lu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:50000,&#34;words&#34;:165,&#34;minutes&#34;:1},&#34;description&#34;:&#34;动机：\n使用Gridea书写博客使用iCloud Drive进行目录同步，将数据目录设置到iCloud Drive下，但是并不想每次同步渲染结果的output目录。\n解法\n查询自 - 知乎 iCloud Drive同步文件时，如何忽略指定目...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%A8%E6%9C%BA\&#34;&gt;动机：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E6%B3%95\&#34;&gt;解法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E6%96%87%E6%8F%8F%E8%BF%B0\&#34;&gt;原文描述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E8%B7%B5\&#34;&gt;实践&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;i-classfa-fa-archive-aria-hiddentruei-常用的一堆小工具\&#34;&gt;&lt;i class=\&#34;fa fa-archive\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;/i&gt;  常用的一堆小工具&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;i class=\&#34;fa fa-internet-explorer\&#34;&gt;&lt;/i&gt; 获取出口IP地址 &lt;a href=\&#34;http://tool.istarboy.site/getIP\&#34;&gt;http://tool.istarboy.site/getIP&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;toolbox&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;工具箱&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-04-03 09:46:25&#34;,&#34;dateFormat&#34;:&#34;2020-04-03&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/toolbox/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:5000,&#34;words&#34;:20,&#34;minutes&#34;:1},&#34;description&#34;:&#34;  常用的一堆小工具\n\n 获取出口IP地址 http://tool.istarboy.site/getIP\n\n\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#i-classfa-fa-archive-aria-hiddentruei-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E5%A0%86%E5%B0%8F%E5%B7%A5%E5%85%B7\&#34;&gt;&lt;i class=\&#34;fa fa-archive\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;/i&gt;  常用的一堆小工具&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;最近在看Gitlab的OAouth2 文档，计划使运维平台接入Gitlab的授权认证。&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;&lt;em&gt;转载自&lt;a href=\&#34;https://www.cnblogs.com/Wddpct/p/8976480.html#3-oauth-2-%E7%9A%84%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B\&#34;&gt;cnblog-白细胞-oauth2深入介绍&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;1-前言\&#34;&gt;1. 前言&lt;/h1&gt;\n&lt;p&gt;OAuth 2 是一个授权框架，或称授权标准，它可以使第三方应用程序或客户端获得对HTTP服务上（例如 Google，GitHub ）用户帐户信息的有限访问权限。OAuth 2 通过将用户身份验证委派给托管用户帐户的服务以及授权客户端访问用户帐户进行工作。综上，OAuth 2 可以为 Web 应用 和桌面应用以及移动应用提供授权流程。&lt;/p&gt;\n&lt;p&gt;本文将从OAuth 2 角色，授权许可类型，授权流程等几方面进行讲解。&lt;/p&gt;\n&lt;p&gt;在正式讲解之前，这里先引入一段应用场景，用以与后文的角色讲解对应。&lt;/p&gt;\n&lt;p&gt;开发者A注册某IT论坛后，发现可以在信息栏中填写自己的 Github 个人信息和仓库项目，但是他又觉得手工填写十分麻烦，直接提供 Github 账户和密码给论坛管理员帮忙处理更是十分智障。&lt;br&gt;\n不过该论坛似乎和 Github 有不可告人的秘密，开发者A可以点击“导入”按钮，授权该论坛访问自己的 Github 账户并限制其只具备读权限。这样一来， Github 中的所有仓库和相关信息就可以很方便地被导入到信息栏中，账户隐私信息也不会泄露。&lt;br&gt;\n这背后，便是 OAuth 2 在大显神威。&lt;/p&gt;\n&lt;h1 id=\&#34;2-oauth2-角色\&#34;&gt;2. OAuth2 角色&lt;/h1&gt;\n&lt;p&gt;OAuth 2 标准中定义了以下几种角色：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;资源所有者（Resource Owner）&lt;/li&gt;\n&lt;li&gt;资源服务器（Resource Server）&lt;/li&gt;\n&lt;li&gt;授权服务器（Authorization Server）&lt;/li&gt;\n&lt;li&gt;客户端（Client）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;21-资源所有者resource-owner\&#34;&gt;2.1 资源所有者（Resource Owner）&lt;/h2&gt;\n&lt;p&gt;资源所有者是 OAuth 2 四大基本角色之一，在 OAuth 2 标准中，资源所有者即代表授权客户端访问本身资源信息的用户（User），也就是应用场景中的“开发者A”。客户端访问用户帐户的权限仅限于用户授权的“范围”（aka. scope，例如读取或写入权限）。&lt;/p&gt;\n&lt;p&gt;如果没有特别说明，下文中出现的&amp;quot;用户&amp;quot;将统一代表资源所有者。&lt;/p&gt;\n&lt;h2 id=\&#34;22-资源授权服务器resourceauthorization-server\&#34;&gt;2.2 资源/授权服务器（Resource/Authorization Server）&lt;/h2&gt;\n&lt;p&gt;资源服务器托管了受保护的用户账号信息，而授权服务器验证用户身份然后为客户端派发资源访问令牌。&lt;/p&gt;\n&lt;p&gt;在上述应用场景中，Github 既是授权服务器也是资源服务器，个人信息和仓库信息即为资源（Resource）。而在实际工程中，不同的服务器应用往往独立部署，协同保护用户账户信息资源。&lt;/p&gt;\n&lt;h2 id=\&#34;23-客户端client\&#34;&gt;2.3 客户端（Client）&lt;/h2&gt;\n&lt;p&gt;在 OAuth 2 中，客户端即代表意图访问受限资源的第三方应用。在访问实现之前，它必须先经过用户者授权，并且获得的授权凭证将进一步由授权服务器进行验证。&lt;/p&gt;\n&lt;p&gt;如果没有特别说明，下文中将不对&amp;quot;应用&amp;quot;，“第三方应用”，“客户端”做出区分。&lt;/p&gt;\n&lt;h1 id=\&#34;3-oauth-2-的授权流程\&#34;&gt;3. OAuth 2 的授权流程&lt;/h1&gt;\n&lt;p&gt;目前为止你应该对 OAuth 2 的角色有了些概念，接下来让我们来看看这几个角色之间的抽象授权流程图和相关解释。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;请注意，实际的授权流程图会因为用户返回授权许可类型的不同而不同。但是下图大体上能反映一次完整抽象的授权流程。&lt;br&gt;\n*&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://stardemo.github.io/post-images/1587209819481.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;Authrization Request&lt;/p&gt;\n&lt;p&gt;客户端向用户请求对资源服务器的&lt;code&gt;authorization grant&lt;/code&gt;。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Authorization Grant（Get)&lt;/p&gt;\n&lt;p&gt;如果用户授权该次请求，客户端将收到一个&lt;code&gt;authorization grant&lt;/code&gt;。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Authorization Grant（Post）&lt;/p&gt;\n&lt;p&gt;客户端向授权服务器发送它自己的客户端身份标识和上一步中的&lt;code&gt;authorization grant&lt;/code&gt;，请求访问令牌。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Access Token（Get）&lt;/p&gt;\n&lt;p&gt;如果客户端身份被认证，并且&lt;code&gt;authorization grant&lt;/code&gt;也被验证通过，授权服务器将为客户端派发&lt;code&gt;access token&lt;/code&gt;。授权阶段至此全部结束。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Access Token（Post &amp;amp;&amp;amp; Validate）&lt;/p&gt;\n&lt;p&gt;客户端向资源服务器发送&lt;code&gt;access token&lt;/code&gt;用于验证并请求资源信息。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Protected Resource（Get）&lt;/p&gt;\n&lt;p&gt;如果&lt;code&gt;access token&lt;/code&gt;验证通过，资源服务器将向客户端返回资源信息。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;4-客户端应用注册\&#34;&gt;4. 客户端应用注册&lt;/h1&gt;\n&lt;p&gt;在应用 OAuth 2 之前，你必须在授权方服务中注册你的应用。如 Google Identity Platform 或者 Github OAuth Setting，诸如此类 OAuth 实现平台中一般都要求开发者提供如下所示的授权设置项。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;应用名称&lt;/li&gt;\n&lt;li&gt;应用网站&lt;/li&gt;\n&lt;li&gt;重定向URI或回调URL&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;重定向URI是授权方服务在用户授权（或拒绝）应用程序之后重定向供用户访问的地址，因此也是用于处理授权码或访问令牌的应用程序的一部分。&lt;/p&gt;\n&lt;h2 id=\&#34;41-client-id-和-client-secret\&#34;&gt;4.1 Client ID 和 Client Secret&lt;/h2&gt;\n&lt;p&gt;一旦你的应用注册成功，授权方服务将以&lt;code&gt;client id&lt;/code&gt;和&lt;code&gt;client secret&lt;/code&gt;的形式为应用发布&lt;code&gt;client credentials&lt;/code&gt;（客户端凭证）。&lt;code&gt;client id&lt;/code&gt;是公开透明的字符串，授权方服务使用该字符串来标识应用程序，并且还用于构建呈现给用户的授权 &lt;code&gt;url&lt;/code&gt; 。当应用请求访问用户的帐户时，&lt;code&gt;client secret&lt;/code&gt;用于验证应用身份，并且必须在客户端和服务之间保持私有性。&lt;/p&gt;\n&lt;h1 id=\&#34;5-授权许可authorization-grant\&#34;&gt;5. 授权许可（Authorization Grant）&lt;/h1&gt;\n&lt;p&gt;如上文的抽象授权流程图所示，前四个阶段包含了获取&lt;code&gt;authorization grant&lt;/code&gt;和&lt;code&gt;access token&lt;/code&gt;的动作。授权许可类型取决于应用请求授权的方式和授权方服务支持的 Grant Type。OAuth 2 定义了四种 Grant Type，每一种都有适用的应用场景。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;Authorization Code&lt;/p&gt;\n&lt;p&gt;结合普通服务器端应用使用。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Implicit&lt;/p&gt;\n&lt;p&gt;结合移动应用或 Web App 使用。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Resource Owner Password Credentials&lt;/p&gt;\n&lt;p&gt;适用于受信任客户端应用，例如同个组织的内部或外部应用。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Client Credentials&lt;/p&gt;\n&lt;p&gt;适用于客户端调用主服务API型应用（比如百度API Store）&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;以下将分别介绍这四种许可类型的相关授权流程。&lt;/p&gt;\n&lt;h2 id=\&#34;51-authorization-code-flow\&#34;&gt;5.1 Authorization Code Flow&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;Authorization Code&lt;/code&gt; 是最常使用的一种授权许可类型，它适用于第三方应用类型为&lt;code&gt;server-side&lt;/code&gt;型应用的场景。&lt;code&gt;Authorization Code&lt;/code&gt;授权流程基于重定向跳转，客户端必须能够与&lt;code&gt;User-agent&lt;/code&gt;（即用户的 Web 浏览器）交互并接收通过&lt;code&gt;User-agent&lt;/code&gt;路由发送的实际&lt;code&gt;authorization code&lt;/code&gt;值。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://stardemo.github.io/post-images/1587210133819.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;1-user-authorization-request\&#34;&gt;1. User Authorization Request&lt;/h3&gt;\n&lt;p&gt;首先，客户端构造了一个用于请求authorization code的URL并引导User-agent跳转访问。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;https://authorization-server.com/auth\n ?response_type=code\n &amp;amp;client_id=29352915982374239857\n &amp;amp;redirect_uri=https%3A%2F%2Fexample-client.com%2Fcallback\n &amp;amp;scope=create+delete\n &amp;amp;state=xcoiv98y2kd22vusuye3kch\nresponse_type=code\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;此参数和参数值用于提示授权服务器当前客户端正在进行&lt;code&gt;Authorization Code&lt;/code&gt;授权流程。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;client_id 客户端身份标识。&lt;/li&gt;\n&lt;li&gt;redirect_uri 标识授权服务器接收客户端请求后返回给&lt;code&gt;User-agent&lt;/code&gt;的跳转访问地址。&lt;/li&gt;\n&lt;li&gt;scope 指定客户端请求的访问级别。&lt;/li&gt;\n&lt;li&gt;state 由客户端生成的随机字符串，步骤2中用户进行授权客户端的请求时也会携带此字符串用于比较，这是为了防止CSRF攻击。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;2-user-authorizes-applcation\&#34;&gt;2. User Authorizes Applcation&lt;/h3&gt;\n&lt;p&gt;当用户点击上文中的示例链接时，用户必须已经在授权服务中进行登录（否则将会跳转到登录界面，不过 OAuth 2 并不关心认证过程），然后授权服务会提示用户授权或拒绝应用程序访问其帐户。以下是授权应用程序的示例：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://stardemo.github.io/post-images/1587210161632.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;3-authorization-code-grant\&#34;&gt;3. Authorization Code Grant&lt;/h3&gt;\n&lt;p&gt;如果用户确认授权，授权服务器将重定向&lt;code&gt;User-agent&lt;/code&gt;至之前客户端提供的指向客户端的&lt;code&gt;redirect_uri&lt;/code&gt;地址，并附带&lt;code&gt;code&lt;/code&gt;和&lt;code&gt;state&lt;/code&gt;参数（由之前客户端提供），于是客户端便能直接读取到&lt;code&gt;authorization code&lt;/code&gt;值。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;https://example-client.com/redirect\n?code=g0ZGZmNjVmOWIjNTk2NTk4ZTYyZGI3\n&amp;amp;state=xcoiv98y2kd22vusuye3kch\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;state&lt;/code&gt;值将与客户端在请求中最初设置的值相同。客户端将检查重定向中的状态值是否与最初设置的状态值相匹配。这可以防止CSRF和其他相关攻击。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;code&lt;/code&gt;是授权服务器生成的&lt;code&gt;authorization code&lt;/code&gt;值。&lt;code&gt;code&lt;/code&gt;相对较短，通常持续1到10分钟，具体取决于授权服务器设置。&lt;/p&gt;\n&lt;h3 id=\&#34;4-access-token-request\&#34;&gt;4. Access Token Request&lt;/h3&gt;\n&lt;p&gt;现在客户端已经拥有了服务器派发的authorization code，接下来便可以使用authorization code和其他参数向服务器请求access token（POST方式）。其他相关参数如下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;grant_type=authorization_code - 这告诉服务器当前客户端正在使用Authorization Code授权流程。&lt;/li&gt;\n&lt;li&gt;code - 应用程序包含它在重定向中给出的授权码。&lt;/li&gt;\n&lt;li&gt;redirect_uri - 与请求authorization code时使用的redirect_uri相同。某些资源（API）不需要此参数。&lt;/li&gt;\n&lt;li&gt;client_id - 客户端标识。&lt;/li&gt;\n&lt;li&gt;client_secret - 应用程序的客户端密钥。这确保了获取access token的请求只能从客户端发出，而不能从可能截获authorization code的攻击者发出。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;5-access-token-grant\&#34;&gt;5. Access Token Grant&lt;/h3&gt;\n&lt;p&gt;服务器将会验证第4步中的请求参数，当验证通过后（校验&lt;code&gt;authorization code&lt;/code&gt;是否过期，&lt;code&gt;client id&lt;/code&gt;和&lt;code&gt;client secret&lt;/code&gt;是否匹配等），服务器将向客户端返回&lt;code&gt;access token&lt;/code&gt;。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;{\n  &amp;quot;access_token&amp;quot;:&amp;quot;MTQ0NjJkZmQ5OTM2NDE1ZTZjNGZmZjI3&amp;quot;,\n  &amp;quot;token_type&amp;quot;:&amp;quot;bearer&amp;quot;,\n  &amp;quot;expires_in&amp;quot;:3600,\n  &amp;quot;refresh_token&amp;quot;:&amp;quot;IwOGYzYTlmM2YxOTQ5MGE3YmNmMDFkNTVk&amp;quot;,\n  &amp;quot;scope&amp;quot;:&amp;quot;create delete&amp;quot;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;至此，授权流程全部结束。直到access token 过期或失效之前，客户端可以通过资源服务器API访问用户的帐户，并具备scope中给定的操作权限。&lt;/p&gt;\n&lt;h2 id=\&#34;52-implicit-flow\&#34;&gt;5.2 Implicit Flow&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;Implicit&lt;/code&gt;授权流程和&lt;code&gt;Authorization Code&lt;/code&gt;基于重定向跳转的授权流程十分相似，但它适用于移动应用和 &lt;code&gt;Web App&lt;/code&gt;，这些应用与普通服务器端应用相比有个特点，即&lt;code&gt;client secret&lt;/code&gt;不能有效保存和信任。&lt;/p&gt;\n&lt;p&gt;相比&lt;code&gt;Authorization Code&lt;/code&gt;授权流程，&lt;code&gt;Implicit&lt;/code&gt;去除了请求和获得&lt;code&gt;authorization code&lt;/code&gt;的过程，而用户点击授权后，授权服务器也会直接把&lt;code&gt;access token&lt;/code&gt;放在&lt;code&gt;redirect_uri&lt;/code&gt;中发送给&lt;code&gt;User-agent&lt;/code&gt;（浏览器）。 同时第1步构造请求用户授权 &lt;code&gt;url&lt;/code&gt; 中的&lt;code&gt;response_type&lt;/code&gt;参数值也由 &lt;code&gt;code&lt;/code&gt; 更改为 &lt;code&gt;token&lt;/code&gt; 或 &lt;code&gt;id_token&lt;/code&gt; 。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://stardemo.github.io/post-images/1587210216686.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;1-user-authorization-request-2\&#34;&gt;1. User Authorization Request&lt;/h3&gt;\n&lt;p&gt;客户端构造的URL如下所示：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;https://{yourOktaDomain}.com/oauth2/default/v1/authorize?client_id=0oabv6kx4qq6\nh1U5l0h7&amp;amp;response_type=token&amp;amp;redirect_uri=http%3A%2F%2Flocalhost%3\nA8080&amp;amp;state=state-296bc9a0-a2a2-4a57-be1a-d0e2fd9bb601&amp;amp;nonce=foo&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;response_type的response_type参数值为 token 或 id_token 。&lt;/p&gt;\n&lt;p&gt;其他请求参数与Authorization Code授权流程相比没有并什么变化。&lt;/p&gt;\n&lt;h3 id=\&#34;2-user-authorizes-application略\&#34;&gt;2. User Authorizes Application（略）&lt;/h3&gt;\n&lt;h3 id=\&#34;3-redirect-uri-with-access-token-in-fragment\&#34;&gt;3. Redirect URI With Access Token In Fragment&lt;/h3&gt;\n&lt;p&gt;假设用户授予访问权限，授权服务器将User-agent（浏览器） 重定向回客户端使用之前提供的redirect_uri。并在 uri 的 #fragment 部分添加access_token键值对。如下所示：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;http://localhost:8080/#access_token=eyJhb[...]erw&amp;amp;token_type=Bearer&amp;amp;expires_in=3600&amp;amp;scope=openid&amp;amp;state=state-296bc9a0-a2a2-4a57-be1a-d0e2fd9bb601\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;token_type - 当且仅当response_type设置为 token 时返回，值恒为 Bearer。&lt;/p&gt;\n&lt;p&gt;注意在Implicit流程中，access_token值放在了 URI 的 #fragment 部分，而不是作为 ?query 参数。&lt;/p&gt;\n&lt;h3 id=\&#34;4-user-agent-follows-the-redirect-uri\&#34;&gt;4. User-agent Follows the Redirect URI&lt;/h3&gt;\n&lt;p&gt;User-agent（浏览器）遵循重定向指令，请求redirect_uri标识的客户端地址，并在本地保留 uri 的 #fragment 部分的access_token信息。&lt;/p&gt;\n&lt;h3 id=\&#34;5-application-sends-access-token-extraction-script\&#34;&gt;5. Application Sends Access Token Extraction Script&lt;/h3&gt;\n&lt;p&gt;客户端生成一个包含 token 解构脚本的 Html 页面，这个页面被发送给User-agent（浏览器），执行脚本解构完整的redirect_uri并提取其中的access_token（access token信息在第4步中已经被User-agent保存）。&lt;/p&gt;\n&lt;h3 id=\&#34;6-access-token-passed-to-application\&#34;&gt;6. Access Token Passed to Application&lt;/h3&gt;\n&lt;p&gt;User-agent（浏览器）向客户端发送解构提取的access token。&lt;/p&gt;\n&lt;p&gt;至此，授权流程全部结束。直到access token 过期或失效之前，客户端可以通过资源服务器API访问用户的帐户，并具备scope中给定的操作权限。&lt;/p&gt;\n&lt;h2 id=\&#34;53-resource-owner-password-credentials-flow\&#34;&gt;5.3 Resource Owner Password Credentials Flow&lt;/h2&gt;\n&lt;p&gt;Resource Owner Password Credentials授权流程适用于用户与客户端具有信任关系的情况，例如设备操作系统或同一组织的内部及外部应用。用户与应用交互表现形式往往体现为客户端能够直接获取用户凭据（用户名和密码，通常使用交互表单）。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://stardemo.github.io/post-images/1587210225887.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;1-resource-owner-password-credentials-from-user-input\&#34;&gt;1. Resource Owner Password Credentials From User Input&lt;/h3&gt;\n&lt;p&gt;用户向客户端提供用户名与密码作为授权凭据。&lt;/p&gt;\n&lt;h3 id=\&#34;2-resource-owner-password-credentials-from-client-to-server\&#34;&gt;2. Resource Owner Password Credentials From Client To Server&lt;/h3&gt;\n&lt;p&gt;客户端向授权服务器发送用户输入的授权凭据以请求 access token。客户端必须已经在服务器端进行注册。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;POST /token HTTP/1.1\nHost: server.example.com\nAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=password&amp;amp;username=johndoe&amp;amp;password=A3ddj3w\ngrant_type - 必选项，值恒为 password\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;3-access-token-passed-to-application\&#34;&gt;3. Access Token Passed to Application&lt;/h3&gt;\n&lt;p&gt;授权服务器对客户端进行认证并检验用户凭据的合法性，如果检验通过，将向客户端派发 access token&amp;gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;{\n  &amp;quot;access_token&amp;quot;:&amp;quot;2YotnFZFEjr1zCsicMWpAA&amp;quot;,\n  &amp;quot;token_type&amp;quot;:&amp;quot;example&amp;quot;,\n  &amp;quot;expires_in&amp;quot;:3600,\n  &amp;quot;refresh_token&amp;quot;:&amp;quot;tGzv3JOkF0XG5Qx2TlKWIA&amp;quot;,\n  &amp;quot;example_parameter&amp;quot;:&amp;quot;example_value&amp;quot;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;54-client-credentials-flow\&#34;&gt;5.4 Client Credentials Flow&lt;/h2&gt;\n&lt;p&gt;Client Credential是最简单的一种授权流程。客户端可以直接使用它的client credentials或其他有效认证信息向授权服务器发起获取access token的请求。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://stardemo.github.io/post-images/1587210349251.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;两步中的请求体和返回体分别如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;POST /token HTTP/1.1\nHost: server.example.com\nAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=client_credentials\ngrant_type - 必选项，值恒为 client_credentials\n{\n       &amp;quot;access_token&amp;quot;:&amp;quot;2YotnFZFEjr1zCsicMWpAA&amp;quot;,\n       &amp;quot;token_type&amp;quot;:&amp;quot;example&amp;quot;,\n       &amp;quot;expires_in&amp;quot;:3600,\n       &amp;quot;example_parameter&amp;quot;:&amp;quot;example_value&amp;quot;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;6-总结\&#34;&gt;6. 总结&lt;/h1&gt;\n&lt;p&gt;说实在的，笔者已经有很长一段时间没有好好地分享心得，发表博客，这固然有工作繁忙，学习充实的原因，但确实也是有些懒，既然认识到了，自然就不希望再堕落下去了。&lt;/p&gt;\n&lt;p&gt;这一年里读了很多书，做了很多事，虽然自觉在大学时期便接触了部分项目管理和开发的知识，但是工作后的收获仍然十分动心。微服务也好，DDD也好，或是具体的数据库理论和运维工程实践上笔者也有了更深的认识。而时至今日，笔者觉得自己是又到了重新积淀，重新迈向下一个阶段的时候。鉴权服务作为构建健壮微服务必不可少的一环（甚至可以说是第一个工程），所以以 OAuth 2 作为重启的第一篇。当然 OAuth 2 也仍然只是鉴权体系中的授权理论，更基础的认证（Authentication）理论还没有引出，希望在之后的日子里能带来更多关于鉴权相关的博文，如认证体系和功能权限设计在工程上的应用，共勉。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;学习和编程都是快乐的。&lt;/strong&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;参考资料及文献\&#34;&gt;参考资料及文献&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://tools.ietf.org/html/rfc6749\&#34;&gt;The OAuth 2.0 Authorization Framework&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://developer.okta.com/blog/2018/04/10/oauth-authorization-code-grant-type\&#34;&gt;What is the OAuth 2.0 Authorization Code Grant Type?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2#grant-type-implicit\&#34;&gt;An Introduction to OAuth 2&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://developer.okta.com/authentication-guide/implementing-authentication/implicit\&#34;&gt;Implicit Flow&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://developer.okta.com/docs/api/resources/oidc#authorize\&#34;&gt;Response Properties&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;http://www.cnblogs.com/linianhui/p/oauth2-authorization.html\&#34;&gt;认证授权 OAuth2授权&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;名词中英文对照&lt;/strong&gt;&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;英文&lt;/th&gt;\n&lt;th&gt;中文&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Authorization Grant&lt;/td&gt;\n&lt;td&gt;授权许可&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Authorization Code&lt;/td&gt;\n&lt;td&gt;授权码&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Access Token&lt;/td&gt;\n&lt;td&gt;访问令牌&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Authorization&lt;/td&gt;\n&lt;td&gt;授权&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Authentication&lt;/td&gt;\n&lt;td&gt;认证&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&#34;,&#34;fileName&#34;:&#34;repost-oauth2-get-start&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;最近在看Gitlab的OAouth2 文档，计划使运维平台接入Gitlab的授权认证。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;[转]OAuth2 入门&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-02-20 20:00:33&#34;,&#34;dateFormat&#34;:&#34;2020-02-20&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/repost-oauth2-get-start/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;15 min read&#34;,&#34;time&#34;:867000,&#34;words&#34;:3752,&#34;minutes&#34;:15},&#34;description&#34;:&#34;最近在看Gitlab的OAouth2 文档，计划使运维平台接入Gitlab的授权认证。\n\n转载自cnblog-白细胞-oauth2深入介绍\n1. 前言\nOAuth 2 是一个授权框架，或称授权标准，它可以使第三方应用程序或客户端获得对HTT...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%89%8D%E8%A8%80\&#34;&gt;1. 前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-oauth2-%E8%A7%92%E8%89%B2\&#34;&gt;2. OAuth2 角色&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#21-%E8%B5%84%E6%BA%90%E6%89%80%E6%9C%89%E8%80%85resource-owner\&#34;&gt;2.1 资源所有者（Resource Owner）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#22-%E8%B5%84%E6%BA%90%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%99%A8resourceauthorization-server\&#34;&gt;2.2 资源/授权服务器（Resource/Authorization Server）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#23-%E5%AE%A2%E6%88%B7%E7%AB%AFclient\&#34;&gt;2.3 客户端（Client）&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-oauth-2-%E7%9A%84%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B\&#34;&gt;3. OAuth 2 的授权流程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%94%E7%94%A8%E6%B3%A8%E5%86%8C\&#34;&gt;4. 客户端应用注册&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#41-client-id-%E5%92%8C-client-secret\&#34;&gt;4.1 Client ID 和 Client Secret&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-%E6%8E%88%E6%9D%83%E8%AE%B8%E5%8F%AFauthorization-grant\&#34;&gt;5. 授权许可（Authorization Grant）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#51-authorization-code-flow\&#34;&gt;5.1 Authorization Code Flow&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-user-authorization-request\&#34;&gt;1. User Authorization Request&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-user-authorizes-applcation\&#34;&gt;2. User Authorizes Applcation&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-authorization-code-grant\&#34;&gt;3. Authorization Code Grant&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-access-token-request\&#34;&gt;4. Access Token Request&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-access-token-grant\&#34;&gt;5. Access Token Grant&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#52-implicit-flow\&#34;&gt;5.2 Implicit Flow&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-user-authorization-request-2\&#34;&gt;1. User Authorization Request&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-user-authorizes-application%E7%95%A5\&#34;&gt;2. User Authorizes Application（略）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-redirect-uri-with-access-token-in-fragment\&#34;&gt;3. Redirect URI With Access Token In Fragment&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-user-agent-follows-the-redirect-uri\&#34;&gt;4. User-agent Follows the Redirect URI&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-application-sends-access-token-extraction-script\&#34;&gt;5. Application Sends Access Token Extraction Script&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-access-token-passed-to-application\&#34;&gt;6. Access Token Passed to Application&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#53-resource-owner-password-credentials-flow\&#34;&gt;5.3 Resource Owner Password Credentials Flow&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-resource-owner-password-credentials-from-user-input\&#34;&gt;1. Resource Owner Password Credentials From User Input&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-resource-owner-password-credentials-from-client-to-server\&#34;&gt;2. Resource Owner Password Credentials From Client To Server&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-access-token-passed-to-application\&#34;&gt;3. Access Token Passed to Application&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#54-client-credentials-flow\&#34;&gt;5.4 Client Credentials Flow&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E6%80%BB%E7%BB%93\&#34;&gt;6. 总结&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E5%8F%8A%E6%96%87%E7%8C%AE\&#34;&gt;参考资料及文献&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;满脑子骚操作之 --  VSCode远程调试--- Docker篇&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h3 id=\&#34;配置vscode连接远程docker\&#34;&gt;配置VSCode连接远程Docker&lt;/h3&gt;\n&lt;h4 id=\&#34;1-远程docker调试开启api访问\&#34;&gt;1. 远程Docker调试,开启api访问&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;修改&lt;code&gt;systemd&lt;/code&gt;配置&lt;code&gt;vim /lib/systemd/system/docker.service&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;在&lt;code&gt;ExecStart&lt;/code&gt;操作后增加 &lt;code&gt; -H tcp://0.0.0.0:2375&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;2-配置vscode连接远程docker\&#34;&gt;2. 配置VSCode连接远程Docker&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;VSCode安装插件 Docker &amp;amp;&amp;amp; 远程调试工具&lt;/li&gt;\n&lt;li&gt;配置VSCode DOCKER_HOST配置 &lt;code&gt;tcp://ip:2375&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;3-注意事项\&#34;&gt;3. 注意事项&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;DockerAPI端口注意使用&lt;code&gt;2375&lt;/code&gt;端口&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;远程调试docker内的golang程序\&#34;&gt;远程调试Docker内的Golang程序&lt;/h3&gt;\n&lt;h4 id=\&#34;1备注\&#34;&gt;1.备注&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;Q: 遇到&lt;code&gt;dlv&lt;/code&gt;调试程序&lt;code&gt;could not launch process: fork/exec ./debug: operation not permitted&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;A: docker run 过程中增加&lt;code&gt;--security-opt=seccomp:unconfined&lt;/code&gt;参数&lt;br&gt;\n&lt;a href=\&#34;https://github.com/go-delve/delve/issues/515\&#34;&gt;delve issue 515&lt;/a&gt; or&lt;br&gt;\n&lt;a href=\&#34;https://stackoverflow.com/questions/35827819/fork-exec-debug-operation-not-permitted\&#34;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Q:&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;A:&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;todo补充\&#34;&gt;TODO补充&lt;/h3&gt;\n&#34;,&#34;fileName&#34;:&#34;golang--docker-remote-debug&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;满脑子骚操作之 --  VSCode远程调试--- Docker篇&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34; Docker远程调试Golang&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-12-11 19:46:57&#34;,&#34;dateFormat&#34;:&#34;2019-12-11&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/golang--docker-remote-debug/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:41000,&#34;words&#34;:154,&#34;minutes&#34;:1},&#34;description&#34;:&#34;满脑子骚操作之 --  VSCode远程调试--- Docker篇\n\n配置VSCode连接远程Docker\n1. 远程Docker调试,开启api访问\n\n修改systemd配置vim /lib/systemd/system/docker.s...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AEvscode%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8Bdocker\&#34;&gt;配置VSCode连接远程Docker&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E8%BF%9C%E7%A8%8Bdocker%E8%B0%83%E8%AF%95%E5%BC%80%E5%90%AFapi%E8%AE%BF%E9%97%AE\&#34;&gt;1. 远程Docker调试,开启api访问&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E9%85%8D%E7%BD%AEvscode%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8Bdocker\&#34;&gt;2. 配置VSCode连接远程Docker&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\&#34;&gt;3. 注意事项&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95docker%E5%86%85%E7%9A%84golang%E7%A8%8B%E5%BA%8F\&#34;&gt;远程调试Docker内的Golang程序&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E5%A4%87%E6%B3%A8\&#34;&gt;1.备注&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#todo%E8%A1%A5%E5%85%85\&#34;&gt;TODO补充&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;最近学习goframe框架时涉及到一个前端框架整合，以静态文件模式加载，前后端分离模式运行的，结果遇到了路由问题，其中涉及到前端路由中的hash使用。&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h2 id=\&#34;url中的hash\&#34;&gt;url中的&lt;code&gt;hash(#)&lt;/code&gt;&lt;/h2&gt;\n&lt;h3 id=\&#34;1-hash的含义\&#34;&gt;1. &lt;code&gt;hash(#)&lt;/code&gt;的含义&lt;/h3&gt;\n&lt;p&gt;#代表网页中的一个位置，其右边的字符，就是该位置的标识符。比如&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;http://loaclhost/index.html#user\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;2http请求不包含\&#34;&gt;2.HTTP请求不包含#&lt;/h3&gt;\n&lt;h3 id=\&#34;3后面的字符\&#34;&gt;3.&lt;code&gt;#&lt;/code&gt;后面的字符&lt;/h3&gt;\n&lt;h3 id=\&#34;4改变不触发网页重载\&#34;&gt;4.改变&lt;code&gt;#&lt;/code&gt;不触发网页重载&lt;/h3&gt;\n&lt;h3 id=\&#34;5改变会改变浏览器的访问历史\&#34;&gt;5.改变&lt;code&gt;#&lt;/code&gt;会改变浏览器的访问历史&lt;/h3&gt;\n&lt;h3 id=\&#34;6windowlocationhash-读取值\&#34;&gt;6.&lt;code&gt;window.location.hash&lt;/code&gt; 读取#值&lt;/h3&gt;\n&lt;h3 id=\&#34;7onhashchange事件\&#34;&gt;7.&lt;code&gt;onhashchange&lt;/code&gt;事件&lt;/h3&gt;\n&#34;,&#34;fileName&#34;:&#34;frontend-router-hash&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;最近学习goframe框架时涉及到一个前端框架整合，以静态文件模式加载，前后端分离模式运行的，结果遇到了路由问题，其中涉及到前端路由中的hash使用。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;前端路由-Hash&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-10-28 19:48:52&#34;,&#34;dateFormat&#34;:&#34;2019-10-28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/frontend-router-hash/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:33000,&#34;words&#34;:149,&#34;minutes&#34;:1},&#34;description&#34;:&#34;最近学习goframe框架时涉及到一个前端框架整合，以静态文件模式加载，前后端分离模式运行的，结果遇到了路由问题，其中涉及到前端路由中的hash使用。\n\nurl中的hash(#)\n1. hash(#)的含义\n#代表网页中的一个位置，其右边的...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#url%E4%B8%AD%E7%9A%84hash\&#34;&gt;url中的&lt;code&gt;hash(#)&lt;/code&gt;&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-hash%E7%9A%84%E5%90%AB%E4%B9%89\&#34;&gt;1. &lt;code&gt;hash(#)&lt;/code&gt;的含义&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2http%E8%AF%B7%E6%B1%82%E4%B8%8D%E5%8C%85%E5%90%AB\&#34;&gt;2.HTTP请求不包含#&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3%E5%90%8E%E9%9D%A2%E7%9A%84%E5%AD%97%E7%AC%A6\&#34;&gt;3.&lt;code&gt;#&lt;/code&gt;后面的字符&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4%E6%94%B9%E5%8F%98%E4%B8%8D%E8%A7%A6%E5%8F%91%E7%BD%91%E9%A1%B5%E9%87%8D%E8%BD%BD\&#34;&gt;4.改变&lt;code&gt;#&lt;/code&gt;不触发网页重载&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5%E6%94%B9%E5%8F%98%E4%BC%9A%E6%94%B9%E5%8F%98%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8E%86%E5%8F%B2\&#34;&gt;5.改变&lt;code&gt;#&lt;/code&gt;会改变浏览器的访问历史&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6windowlocationhash-%E8%AF%BB%E5%8F%96%E5%80%BC\&#34;&gt;6.&lt;code&gt;window.location.hash&lt;/code&gt; 读取#值&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7onhashchange%E4%BA%8B%E4%BB%B6\&#34;&gt;7.&lt;code&gt;onhashchange&lt;/code&gt;事件&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;公司运维基础架构迭代过程中，MYSQL由5.6升级至5.7过程中遇到5.7的强规范限制导致的不兼容老系统，修改参数以适应原有系统。&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h1 id=\&#34;mysql的参数调整\&#34;&gt;MySQL的参数调整&lt;/h1&gt;\n&lt;h2 id=\&#34;问题\&#34;&gt;问题&lt;/h2&gt;\n&lt;p&gt;因为业务老旧sql原因需要禁用&lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;查询MYSQL版本&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select version();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;sql_mode查询&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; select @@GLOBAL.sql_mode;\n+-------------------------------------------------------------------------------------------------------------------------------------------+\n| @@GLOBAL.sql_mode                                                                                                                         |\n+-------------------------------------------------------------------------------------------------------------------------------------------+\n| ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |\n+-------------------------------------------------------------------------------------------------------------------------------------------+\n1 row in set\n\nmysql&amp;gt; \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;解决办法\&#34;&gt;解决办法&lt;/h2&gt;\n&lt;p&gt;重新设置sql_mode，来关闭这个选项。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;1.临时禁用&lt;br&gt;\n在sql终端中执行如下&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql&amp;gt; set @@GLOBAL.sql_mode = &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;\nmysql&amp;gt; \n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;2.永久修改&lt;br&gt;\n在mysql配置文件的mysqld节点下增加如下内容&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;sql_mode=&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;k8s模式configmap注入\&#34;&gt;k8s模式configmap注入&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;1.原理&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;永久修改mysqld节点下参数，使用k8s的&lt;code&gt;volumeMounts&lt;/code&gt;挂入路径&lt;code&gt;/etc/mysql/mysql.conf.d/mysqld.cnf&lt;/code&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;2.ConfigMap内容&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-yaml\&#34;&gt;apiVersion: v1\ndata:\n  mysqld.cnf: |-\n    # Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.\n    #\n    # This program is free software; you can redistribute it and/or modify\n    # it under the terms of the GNU General Public License as published by\n    # the Free Software Foundation; version 2 of the License.\n    #\n    # This program is distributed in the hope that it will be useful,\n    # but WITHOUT ANY WARRANTY; without even the implied warranty of\n    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    # GNU General Public License for more details.\n    #\n    # You should have received a copy of the GNU General Public License\n    # along with this program; if not, write to the Free Software\n    # Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA\n\n    #\n    # The MySQL  Server configuration file.\n    #\n    # For explanations see\n    # http://dev.mysql.com/doc/mysql/en/server-system-variables.html\n\n    [mysqld]\n    pid-file        = /var/run/mysqld/mysqld.pid\n    socket          = /var/run/mysqld/mysqld.sock\n    datadir         = /var/lib/mysql\n    log-error       = /var/log/mysql/error.log\n    # Disabling symbolic-links is recommended to prevent assorted security risks\n    symbolic-links=0\n    sql_mode=&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;\nkind: ConfigMap\nmetadata:\n  name: mysql-config-add\n  namespace: cb-common\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;record-mysql-config-settings&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;公司运维基础架构迭代过程中，MYSQL由5.6升级至5.7过程中遇到5.7的强规范限制导致的不兼容老系统，修改参数以适应原有系统。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;记录一次MYSQL参数调整&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-10-12 19:49:57&#34;,&#34;dateFormat&#34;:&#34;2019-10-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/record-mysql-config-settings/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:129000,&#34;words&#34;:411,&#34;minutes&#34;:3},&#34;description&#34;:&#34;公司运维基础架构迭代过程中，MYSQL由5.6升级至5.7过程中遇到5.7的强规范限制导致的不兼容老系统，修改参数以适应原有系统。\n\nMySQL的参数调整\n问题\n因为业务老旧sql原因需要禁用ONLY_FULL_GROUP_BY\n\n查询MY...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#mysql%E7%9A%84%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4\&#34;&gt;MySQL的参数调整&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98\&#34;&gt;问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\&#34;&gt;解决办法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#k8s%E6%A8%A1%E5%BC%8Fconfigmap%E6%B3%A8%E5%85%A5\&#34;&gt;k8s模式configmap注入&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;dd命令用于读取、转换并输出数据。&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h2 id=\&#34;dd指令使用\&#34;&gt;dd指令使用&lt;/h2&gt;\n&lt;h3 id=\&#34;语法格式\&#34;&gt;语法格式&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;dd   [option]\n# dd指令选项详解\nif=file：输入文件名，缺省为标准输入\nof=file：输出文件名，缺省为标准输出\nibs=bytes：一次读入 bytes 个字节（即一个块大小为 bytes 个字节）\nobs=bytes：一次写 bytes 个字节（即一个块大小为 bytes 个字节）\nbs=bytes：同时设置读写块的大小为 bytes ，可代替 ibs 和 obs\ncbs=bytes：一次转换 bytes 个字节，即转换缓冲区大小\nskip=blocks：从输入文件开头跳过 blocks 个块后再开始复制\nseek=blocks：从输出文件开头跳过 blocks 个块后再开始复制。（通常只有当输出文件是磁盘或磁带时才有效）\ncount=blocks：仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数\nconv=ASCII：把EBCDIC码转换为ASCIl码。\nconv=ebcdic：把ASCIl码转换为EBCDIC码。\nconv=ibm：把ASCIl码转换为alternate EBCDIC码。\nconv=block：把变动位转换成固定字符。\nconv=ublock：把固定位转换成变动位。\nconv=ucase：把字母由小写转换为大写。\nconv=lcase：把字母由大写转换为小写。\nconv=notrunc：不截短输出文件。\nconv=swab：交换每一对输入字节。\nconv=noerror：出错时不停止处理。\nconv=sync：把每个输入记录的大小都调到ibs的大小（用NUL填充）。\n\n注意：指定数字的地方若以下列字符结尾乘以相应的数字：b=512, c=1, k=1024, w=2, xm=number m，kB=1000，K=1024，MB=1000*1000，M=1024*1024，GB=1000*1000*1000，G=1024*1024*1024\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;dd使用实例\&#34;&gt;dd使用实例&lt;/h3&gt;\n&lt;h4 id=\&#34;假设了如下的情况\&#34;&gt;假设了如下的情况：&lt;/h4&gt;\n&lt;p&gt;要备份的数据文件：30720KB  &lt;code&gt;block 0 =8 KB.&lt;/code&gt; &lt;code&gt; raw offset 64 KB.&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;设定 bs=8k&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;1、从raw设备备份到raw设备&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;dd if=/dev/rsd1b of=/dev/rsd2b bs=8k skip=8 seek=8 count=3841\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;2、裸设备到文件系统&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;dd if=/dev/rsd1b of=/backup/df1.dbf bs=8k skip=8 count=3841\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;3、文件系统到裸设备&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;dd if=/backup/df1.dbf of=/dev/rsd2b bs=8k seek=8\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;4、文件系统到文件系统，你可以为了提升I/O把bs设为较高的数值&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;dd if=/oracle/dbs/df1.dbf of=/backup/df1.dbf bs=1024k\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;5、备份/dev/hdx全盘数据，并利用gzip工具进行压缩，保存到指定路径（bzip2工具也一样可使用）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;dd  if=/dev/hdx  |  gzip &amp;gt; /path/to/image.gz\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;6、生成1G的虚拟块设备Sparse File(稀疏文件)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;dd if=/dev/zero of=1G.img bs=1M seek=1000 count=0\n# Sparse File是什么，稀疏文件，也就是说，是一个拥有空的空间的文件，磁盘块将并没分配给这些文件。如果这些空的空间填满ASCII的NULL字符，那么文件才会是实际的大小。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;7、拷贝光盘数据到backup文件夹下，并保存为cd.iso文件，再进行刻录&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;dd  if=/dev/cdrom  of=/backup/cd.iso\ncdrecord -v cd.iso\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;8、将内存里的数据拷贝到backup目录下的mem.bin文件&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;dd if=/dev/mem of=/backup/mem.bin bs=1024\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;9、将软驱数据备份到当前目录的disk.img文件&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;dd if=/dev/fd0 of=disk.img count=1 bs=1440k\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;10、将备份文件恢复到指定盘&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;dd if=/backup/df1.dbf of=/dev/rsd1b\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;11、将压缩的备份文件恢复到指定盘&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;gzip -dc /path/to/image.gz | dd of=/dev/hdx\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;12、测试磁盘写能力&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;time dd if=/dev/zero of=/test.dbf bs=8k count=300000\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;因为/dev/zero是一个伪设备，它只产生空字符流，对它不会产生IO，所以，IO都会集中在of文件中，of文件只用于写，所以这个命令相当于测试磁盘的写能力。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;13、测试磁盘读能力&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;time dd if=/dev/sdb1 of=/dev/null bs=8k\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;因为/dev/sdb1是一个物理分区，对它的读取会产生IO，/dev/null是伪设备，相当于黑洞，of到该设备不会产生IO，所以，这个命令的IO只发生在/dev/sdb1上，也相当于测试磁盘的读能力。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;14、测试同时读写能力&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;time dd if=/dev/sdb1 of=/test1.dbf bs=8k\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个命令下，一个是物理分区，一个是实际的文件，对它们的读写都会产生IO（对/dev/sdb1是读，对/test1.dbf是写），假设他们都在一个磁盘中，这个命令就相当于测试磁盘的同时读写能力&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;15、备份磁盘开始的512Byte大小的MBR信息到指定文件&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;dd  if=/dev/hdx  of=/path/to/image  count=1  bs=512\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;16、恢复MBR&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;dd if=/mnt/windows/linux.lnx of=/dev/hda bs=512 count=1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;17、得到最恰当的block size。通过比较dd指令输出中所显示的命令执行时间（选时间最少的那个），即可确定系统最佳的block size大小&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file\ndd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file\ndd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file\ndd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;linux-dd-shellcmd&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;dd命令用于读取、转换并输出数据。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Linux dd实战&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-09-19 19:59:23&#34;,&#34;dateFormat&#34;:&#34;2019-09-19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/linux-dd-shellcmd/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:314000,&#34;words&#34;:1224,&#34;minutes&#34;:6},&#34;description&#34;:&#34;dd命令用于读取、转换并输出数据。\n\ndd指令使用\n语法格式\ndd   [option]\n# dd指令选项详解\nif=file：输入文件名，缺省为标准输入\nof=file：输出文件名，缺省为标准输出\nibs=bytes：一次读入 bytes...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#dd%E6%8C%87%E4%BB%A4%E4%BD%BF%E7%94%A8\&#34;&gt;dd指令使用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F\&#34;&gt;语法格式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dd%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B\&#34;&gt;dd使用实例&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%81%87%E8%AE%BE%E4%BA%86%E5%A6%82%E4%B8%8B%E7%9A%84%E6%83%85%E5%86%B5\&#34;&gt;假设了如下的情况：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;docker，kubernetes使用过程中镜像越来越多 清理镜像以缓解磁盘压力&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;&lt;strong&gt;为了以防万一（线上环境一定要谨慎谨慎再谨慎&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;1、先使用&lt;code&gt;kubectl get po –namespace &lt;/code&gt;命名空间，查看该命名空间已有的pod&lt;/li&gt;\n&lt;li&gt;2、重新部署pod，在该node节点上产生多余的images镜像&lt;/li&gt;\n&lt;li&gt;3、使用&lt;code&gt;docker system df&lt;/code&gt;命令，在执行清除镜像之前先查看镜像和容器的数量。&lt;br&gt;\n注：类似于Linux上的df命令，用于查看Docker的磁盘使用情况。这条命令可以查看到node节点中镜像和容器的数量&lt;/li&gt;\n&lt;li&gt;4、使用&lt;code&gt;docker system prune –a&lt;/code&gt;。清除无用的镜像&lt;br&gt;\n注：&lt;code&gt;docker system prune&lt;/code&gt;命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像(即无tag的镜像)。&lt;code&gt;docker system prune -a&lt;/code&gt;命令清理得更加彻底，可以将没有容器使用Docker镜像都删掉。注意，这两个命令会把你暂时关闭的容器，以及暂时没有用到的Docker镜像都删掉了…所以使用之前一定要想清楚吶。&lt;/li&gt;\n&lt;li&gt;5、使用&lt;code&gt;docker system df&lt;/code&gt;命令，查看镜像和容器的数量；是否成功&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;docker-cleanup&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;docker，kubernetes使用过程中镜像越来越多 清理镜像以缓解磁盘压力&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Docker清理无用镜像&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-09-19 19:52:52&#34;,&#34;dateFormat&#34;:&#34;2019-09-19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/docker-cleanup/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:68000,&#34;words&#34;:307,&#34;minutes&#34;:2},&#34;description&#34;:&#34;docker，kubernetes使用过程中镜像越来越多 清理镜像以缓解磁盘压力\n\n为了以防万一（线上环境一定要谨慎谨慎再谨慎\n\n1、先使用kubectl get po –namespace 命名空间，查看该命名空间已有的pod\n2、重新部...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;macos 使用touchid代替sudo&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h2 id=\&#34;操作方法\&#34;&gt;操作方法&lt;/h2&gt;\n&lt;p&gt;打开“终端”，执行以下命令：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;sudo sed -i &amp;quot;.bak&amp;quot; &#39;2s/^/auth       sufficient     pam_tid.so\\&#39;$&#39;\\n/g&#39; /etc/pam.d/sudo\nsudo sed -i &amp;quot;.bak&amp;quot; &#39;2s/^/auth       sufficient     pam_tid.so\\&#39;$&#39;\\n/g&#39; /etc/pam.d/sudo\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;然后输入您的管理员密码，回车，大功告成了！不用重启哦～&lt;/p&gt;\n&lt;h2 id=\&#34;命令说明\&#34;&gt;命令说明&lt;/h2&gt;\n&lt;p&gt;该命令的作用是把 &lt;code&gt;/etc/pam.d/sudo &lt;/code&gt;备份为 &lt;code&gt;/etc/pam.d/sudo.bak&lt;/code&gt;，然后在 &lt;code&gt;/etc/pam.d/sudo&lt;/code&gt; 的第二行前面加入 &lt;code&gt;uth sufficient pam_tid.so &lt;/code&gt;这个字符串。&lt;br&gt;\n修改该文件的目的是在 sudo 程序的认证过程前面插入 Touch ID 验证的模块。感兴趣的小伙伴可以去了解一下 PAM 架构。&lt;br&gt;\n如果需要恢复原文件，请执行：&lt;code&gt;sudo mv /etc/pam.d/sudo.bak /etc/pam.d/sudo&lt;/code&gt;。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;作者：hptuchief\n链接：https://hacpai.com/article/1512017120360\n来源：黑客派\n协议：CC BY-SA 4.0 https://creativecommons.org/licenses/by-sa/4.0/\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;sudowith-touchid&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;macos 使用touchid代替sudo&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;MBP13 使用TouchID调用sudo&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-09-19 19:51:29&#34;,&#34;dateFormat&#34;:&#34;2019-09-19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/sudowith-touchid/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:60000,&#34;words&#34;:224,&#34;minutes&#34;:2},&#34;description&#34;:&#34;macos 使用touchid代替sudo\n\n操作方法\n打开“终端”，执行以下命令：\nsudo sed -i &amp;quot;.bak&amp;quot; &#39;2s/^/auth       sufficient     pam_tid.so\\&#39;$&#39;\\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95\&#34;&gt;操作方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E\&#34;&gt;命令说明&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;记录一些使用Shell的技巧&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h2 id=\&#34;shell中的文字处理\&#34;&gt;Shell中的文字处理&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;JSON&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;# jq是一个Shell中的常用json对象化工具\n# 安装\nyum install -y jq\n# 使用Demo Data见后文 如下命令获取\nkubectl get secrets -n test test -ojson\n########Data##########################\nkubectl get secrets -n test test -ojson|jq &#39;.data.passwd&#39;\n&amp;quot;aGVsbG8=&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-json\&#34;&gt;# JSON Data\n{\n    &amp;quot;apiVersion&amp;quot;: &amp;quot;v1&amp;quot;,\n    &amp;quot;data&amp;quot;: {\n        &amp;quot;passwd&amp;quot;: &amp;quot;aGVsbG8=&amp;quot;\n    },\n    &amp;quot;kind&amp;quot;: &amp;quot;Secret&amp;quot;,\n    &amp;quot;metadata&amp;quot;: {\n        &amp;quot;annotations&amp;quot;: {\n            &amp;quot;field.cattle.io/creatorId&amp;quot;: &amp;quot;u-9hs5v&amp;quot;,\n            &amp;quot;field.cattle.io/projectId&amp;quot;: &amp;quot;c-6hbc7:p-l8wp7&amp;quot;,\n            &amp;quot;lifecycle.cattle.io/create.secretsController_c-6hbc7&amp;quot;: &amp;quot;true&amp;quot;,\n            &amp;quot;secret.user.cattle.io/secret&amp;quot;: &amp;quot;true&amp;quot;\n        },\n        &amp;quot;creationTimestamp&amp;quot;: &amp;quot;2019-04-22T05:29:28Z&amp;quot;,\n        &amp;quot;name&amp;quot;: &amp;quot;test&amp;quot;,\n        &amp;quot;namespace&amp;quot;: &amp;quot;test&amp;quot;,\n        &amp;quot;resourceVersion&amp;quot;: &amp;quot;472498492&amp;quot;,\n        &amp;quot;selfLink&amp;quot;: &amp;quot;/api/v1/namespaces/cms3/secrets/test&amp;quot;,\n        &amp;quot;uid&amp;quot;: &amp;quot;9985b4ea-64bf-11e9-9da9-06976d75b572&amp;quot;\n    },\n    &amp;quot;type&amp;quot;: &amp;quot;Opaque&amp;quot;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;String 字符串处理去除引号&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;kubectl get secrets -n test test -ojson|jq &#39;.data.passwd&#39;\n&amp;quot;aGVsbG8=&amp;quot;\nkubectl get secrets -n cms3 test -ojson|jq &#39;.data.passwd&#39;|sed &#39;s/\\&amp;quot;//g&#39;\naGVsbG8=\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;环境变量注入配置文件&lt;br&gt;\n&lt;code&gt;使用envsubst&lt;/code&gt;&lt;br&gt;\n安装&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# Ubuntu/Debian \napt-get install gettext\n# Centos\nyum install gettext\n&lt;/code&gt;&lt;/pre&gt;\n使用&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;export TEST_INJECT_VAR=&amp;quot;test-data-2020&amp;quot;\nenvsubst &amp;lt; input.file  &amp;gt; output.file\ncat input.file\n${TEST_INJECT_VAR}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;shell-skills&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;记录一些使用Shell的技巧&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Shell使用技巧合辑&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-04-22 20:00:34&#34;,&#34;dateFormat&#34;:&#34;2019-04-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/shell-skills/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:94000,&#34;words&#34;:281,&#34;minutes&#34;:2},&#34;description&#34;:&#34;记录一些使用Shell的技巧\n\nShell中的文字处理\n\nJSON\n\n# jq是一个Shell中的常用json对象化工具\n# 安装\nyum install -y jq\n# 使用Demo Data见后文 如下命令获取\nkubectl get ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#shell%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86\&#34;&gt;Shell中的文字处理&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;记录日常使用中的一些技巧&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h1 id=\&#34;vscode使用技巧记录\&#34;&gt;VSCode使用技巧记录&lt;/h1&gt;\n&lt;h2 id=\&#34;代码折叠\&#34;&gt;代码折叠&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;折叠所有区域代码：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;code&gt;ctrl + k&lt;/code&gt; +&lt;code&gt;ctrl + 0&lt;/code&gt;  ( 注意这个是零，不是字母O)&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;展开所有折叠区域代码：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;code&gt;ctrl +k&lt;/code&gt;+ &lt;code&gt; ctrl + J&lt;/code&gt; ;&lt;/p&gt;\n&lt;h2 id=\&#34;删除多行\&#34;&gt;删除多行&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;1.移动到要删除的行字符&lt;/li&gt;\n&lt;li&gt;2.按下快捷键&lt;code&gt;ctrl + shift +l&lt;/code&gt; ,或者从&lt;code&gt;selection菜单&lt;/code&gt;中选择&lt;code&gt;select all occurrences&lt;/code&gt;(选择所有出现的单词)&lt;/li&gt;\n&lt;li&gt;3.此时点击 键盘上的 &lt;code&gt;delete&lt;/code&gt;,就会把所有的选中字符全部删除&lt;/li&gt;\n&lt;li&gt;4.最后按下&lt;code&gt;shift + delete&lt;/code&gt; ,则会把光标所在的行整行删除掉&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;vscode-shi-yong-ji-qiao-ji-lu&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;记录日常使用中的一些技巧&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;VSCode使用技巧记录&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-04-08 20:05:20&#34;,&#34;dateFormat&#34;:&#34;2019-04-08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/vscode-shi-yong-ji-qiao-ji-lu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:33000,&#34;words&#34;:149,&#34;minutes&#34;:1},&#34;description&#34;:&#34;记录日常使用中的一些技巧\n\nVSCode使用技巧记录\n代码折叠\n\n折叠所有区域代码：\n\nctrl + k +ctrl + 0  ( 注意这个是零，不是字母O)\n\n展开所有折叠区域代码：\n\nctrl +k+  ctrl + J ;\n删除多行\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#vscode%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E8%AE%B0%E5%BD%95\&#34;&gt;VSCode使用技巧记录&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81%E6%8A%98%E5%8F%A0\&#34;&gt;代码折叠&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A0%E9%99%A4%E5%A4%9A%E8%A1%8C\&#34;&gt;删除多行&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Nginx 高并发情况下对内核的性能调参&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h2 id=\&#34;何为高并发\&#34;&gt;何为高并发&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;默认的Linux内核参数考虑的是最通用场景，不符合用于支持高并发访问的Web服务器，所以需要修改Linux内核参数，这样可以让Nginx拥有更高的性能；&lt;/li&gt;\n&lt;li&gt;在优化内核时，可以做的事情很多，不过，我们通常会根据业务特点来进行调整，当Nginx作为静态web内容服务器、反向代理或者提供压缩服务器的服务器时，期内核参数的调整都是不同的，这里针对最通用的、使Nginx支持更多并发请求的TCP网络参数做简单的配置；&lt;/li&gt;\n&lt;li&gt;这些需要修改/etc/sysctl.conf来更改内核参数。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;配置详析\&#34;&gt;配置详析&lt;/h2&gt;\n&lt;p&gt;表示单个进程较大可以打开的句柄数；&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;fs.file-max = 999999\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;参数设置为 1 ，表示允许将TIME_WAIT状态的socket重新用于新的TCP链接，这对于服务器来说意义重大，因为总有大量TIME_WAIT状态的链接存在；&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_tw_reuse = 1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当keepalive启动时，TCP发送keepalive消息的频度；默认是2小时，将其设置为10分钟，可以更快的清理无效链接。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;ner.ipv4.tcp_keepalive_time = 600\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当服务器主动关闭链接时，socket保持在FIN_WAIT_2状态的较大时间&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_fin_timeout = 30\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个参数表示操作系统允许TIME_WAIT套接字数量的较大值，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。&lt;/p&gt;\n&lt;p&gt;该参数默认为180000，过多的TIME_WAIT套接字会使Web服务器变慢。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_max_tw_buckets = 5000\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;定义UDP和TCP链接的本地端口的取值范围。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.ipv4.ip_local_port_range = 1024 65000\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;定义了TCP接受缓存的最小值、默认值、较大值。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_rmem = 10240 87380 12582912\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;定义TCP发送缓存的最小值、默认值、较大值。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_wmem = 10240 87380 12582912\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当网卡接收数据包的速度大于内核处理速度时，会有一个列队保存这些数据包。这个参数表示该列队的较大值。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.core.netdev_max_backlog = 8096\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;表示内核套接字接受缓存区默认大小。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.core.rmem_default = 6291456\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;表示内核套接字发送缓存区默认大小。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.core.wmem_default = 6291456\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;表示内核套接字接受缓存区较大大小。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.core.rmem_max = 12582912\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;表示内核套接字发送缓存区较大大小。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.core.wmem_max = 12582912\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注意：以上的四条配置，需要根据业务逻辑和实际的硬件成本来综合考虑；&lt;/p&gt;\n&lt;p&gt;与性能无关。用于解决TCP的SYN***。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_syncookies = 1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个参数表示TCP三次握手建立阶段接受SYN请求列队的较大长度，默认1024，将其设置的大一些可以使出现Nginx繁忙来不及accept新连接的情况时，Linux不至于丢失客户端发起的链接请求。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_max_syn_backlog = 8192\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个参数用于设置启用timewait快速回收。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_tw_recycle = 1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;选项默认值是128，这个参数用于调节系统同时发起的TCP连接数，在高并发的请求中，默认的值可能会导致链接超时或者重传，因此需要结合高并发请求数来调节此值。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.core.somaxconn=262114\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;选项用于设定系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤立链接将立即被复位并输出警告信息。这个限制指示为了防止简单的DOS***，不用过分依靠这个限制甚至认为的减小这个值，更多的情况是增加这个值。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_max_orphans=262114\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;为了方便使用，下方可以直接复制&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_tw_reuse = 1\nfs.file-max = 999999\nnet.ipv4.tcp_fin_timeout = 30\nner.ipv4.tcp_keepalive_time = 600\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;©著作权归作者所有：来自51CTO博客作者喵来个鱼的&lt;a href=\&#34;https://blog.51cto.com/m51cto/2363354\&#34;&gt;原创作品&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;nginx10mgao-bing-fa-nei-he-you-hua-xiang-jie&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;Nginx 高并发情况下对内核的性能调参&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Nginx10m+高并发内核优化详解&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-21 20:06:23&#34;,&#34;dateFormat&#34;:&#34;2019-03-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/nginx10mgao-bing-fa-nei-he-you-hua-xiang-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:219000,&#34;words&#34;:986,&#34;minutes&#34;:4},&#34;description&#34;:&#34;Nginx 高并发情况下对内核的性能调参\n\n何为高并发\n\n默认的Linux内核参数考虑的是最通用场景，不符合用于支持高并发访问的Web服务器，所以需要修改Linux内核参数，这样可以让Nginx拥有更高的性能；\n在优化内核时，可以做的事情很...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%95%E4%B8%BA%E9%AB%98%E5%B9%B6%E5%8F%91\&#34;&gt;何为高并发&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE%E8%AF%A6%E6%9E%90\&#34;&gt;配置详析&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;多次失败登录即封掉IP，防止暴力破解&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.cnblogs.com/panblack/p/secure_ssh_auto_block.html\&#34;&gt;参考Blog&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;一-系统\&#34;&gt;一、系统：&lt;/h2&gt;\n&lt;p&gt;Centos7 64位&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;rpm -qa | grep tcp\nyum  –y  install  tcp_wrappers  \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;二-方法\&#34;&gt;二、方法：&lt;/h2&gt;\n&lt;p&gt;读取/var/log/secure，查找关键字 Failed，例如：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Jan 21 22:14:36 gitlab sshd[1631]: Failed password for invalid user admin from 193.201.224.199 port 34257 ssh2\nJan 21 22:14:39 gitlab sshd[1631]: Failed password for invalid user admin from 193.201.224.199 port 34257 ssh2\nJan 21 22:14:40 gitlab sshd[1641]: Failed password for invalid user deploy5 from 139.59.93.89 port 36812 ssh2\nJan 21 22:14:46 gitlab sshd[1664]: Failed password for invalid user router from 193.201.224.199 port 4674 ssh2\nJan 21 22:14:52 gitlab sshd[1675]: Failed password for invalid user root from 193.201.224.199 port 11127 ssh2\nJan 21 22:14:59 gitlab sshd[1692]: Failed password for invalid user admin from 193.201.224.199 port 24144 ssh2\nJan 21 22:15:01 gitlab sshd[1692]: Failed password for invalid user admin from 193.201.224.199 port 24144 ssh2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;从这些行中提取IP地址，如果次数达到10次(脚本中判断次数字符长度是否大于1)则将该IP写到 /etc/hosts.deny中。&lt;/p&gt;\n&lt;h2 id=\&#34;三步骤\&#34;&gt;三.步骤：&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;1、先把始终允许的IP填入 /etc/hosts.allow ，&lt;mark&gt;这很重要&lt;/mark&gt;！比如：&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;sshd:19.16.18.1:allow\nsshd:19.16.18.2:allow\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;脚本 /usr/local/bin/secure_ssh.sh&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;#! /bin/bash\ncat /var/log/secure|awk &#39;/Failed/{print $(NF-3)}&#39;|sort|uniq -c|awk &#39;{print $2&amp;quot;=&amp;quot;$1;}&#39; &amp;gt; /usr/local/bin/black.list\nfor i in `cat  /usr/local/bin/black.list`\ndo\n  IP=`echo $i |awk -F= &#39;{print $1}&#39;`\n  NUM=`echo $i|awk -F= &#39;{print $2}&#39;`\n  if [ ${#NUM} -gt 1 ]; then\n    grep $IP /etc/hosts.deny &amp;gt; /dev/null\n    if [ $? -gt 0 ];then\n      echo &amp;quot;sshd:$IP:deny&amp;quot; &amp;gt;&amp;gt; /etc/hosts.deny\n    fi\n  fi\ndone\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;将secure_ssh.sh脚本放入cron计划任务，每1分钟执行一次。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;# crontab -e\n*/1 * * * *  sh /usr/local/bin/secure_ssh.sh\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;四-测试\&#34;&gt;四、测试：&lt;/h2&gt;\n&#34;,&#34;fileName&#34;:&#34;fu-wu-qi-ssh-jia-gu&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;多次失败登录即封掉IP，防止暴力破解&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;服务器SSH加固&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-15 20:08:53&#34;,&#34;dateFormat&#34;:&#34;2019-03-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/fu-wu-qi-ssh-jia-gu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:131000,&#34;words&#34;:401,&#34;minutes&#34;:3},&#34;description&#34;:&#34;多次失败登录即封掉IP，防止暴力破解\n\n参考Blog\n一、系统：\nCentos7 64位\nrpm -qa | grep tcp\nyum  –y  install  tcp_wrappers  \n\n二、方法：\n读取/var/log/secur...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80-%E7%B3%BB%E7%BB%9F\&#34;&gt;一、系统：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C-%E6%96%B9%E6%B3%95\&#34;&gt;二、方法：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%89%E6%AD%A5%E9%AA%A4\&#34;&gt;三.步骤：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9B-%E6%B5%8B%E8%AF%95\&#34;&gt;四、测试：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;统计文件或者系统内IP出现频率&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h2 id=\&#34;统计文件里的ip\&#34;&gt;统计文件里的IP&lt;/h2&gt;\n&lt;h3 id=\&#34;准备文件\&#34;&gt;准备文件&lt;/h3&gt;\n&lt;p&gt;首先准备文件demo.txt，内容如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;1 192.168.41.20 \n2 192.168.41.21 \n3 192.168.41.22 \n4 192.168.41.23 \n5 192.168.41.24 \n6 192.168.41.25\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;统计\&#34;&gt;统计&lt;/h3&gt;\n&lt;p&gt;统计出现次数最多的ip次数：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;cat demo.txt | awk &#39;{print $2}&#39; | sort | uniq -c | sort -n -r | head -n 1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;awk &#39;{ print $2}&#39;：取数据的第2域（第2列），第一列是标号（1，2，3...）,第二列是ip地址\n\nsort：对IP部分进行排序。\n\nuniq -c：打印每一重复行出现的次数。（并去掉重复行）\n\nsort -n -r：按照重复行出现的次序倒序排列。\n\nhead -n 1：取排在第一位的ip地址\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;统计netstat-ntu命令的结果中出现次数最多的ip地址\&#34;&gt;统计&lt;code&gt;netstat -ntu&lt;/code&gt;命令的结果中出现次数最多的ip地址：&lt;/h2&gt;\n&lt;p&gt;执行命令 &lt;code&gt;netstat -ntu&lt;/code&gt;，显示结果如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Active Internet connections (w/o servers) \nProto Recv-Q Send-Q Local Address Foreign Address State \ntcp 0 0 127.0.0.1:8152 127.0.0.1:4193 TIME_WAIT \ntcp 0 0 127.0.0.1:8152 127.0.0.1:4192 TIME_WAIT \ntcp 0 0 127.0.0.1:8152 127.0.0.1:4196 TIME_WAIT \ntcp 0 0 127.0.0.1:8152 127.0.0.1:4199 TIME_WAIT \ntcp 0 0 127.0.0.1:8152 127.0.0.1:4201 TIME_WAIT \ntcp 0 0 127.0.0.1:8152 127.0.0.1:4204 TIME_WAIT \ntcp 0 0 127.0.0.1:8152 127.0.0.1:4207 TIME_WAIT \ntcp 0 0 127.0.0.1:8152 127.0.0.1:4210 TIME_WAIT \ntcp 0 0 192.168.32.62:41682 192.168.47.27:5431 TIME_WAIT \ntcp 0 0 192.168.32.62:41685 192.168.47.27:5431 TIME_WAIT\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;使用脚本命令进行统计：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;netstat -ntu | tail -n +3|awk &#39;{ print $5}&#39; | cut -d : -f 1 | sort | uniq -c| sort -n -r | head -n 5\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;统计结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;8 127.0.0.1\n2 192.168.47.27\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;tail -n +3 :去掉上面用红色标明的两行。\n\nawk &#39;{ print $5}&#39;：取数据的第5域（第5列）\n\ncut -d : -f 1 ：取蓝色部分前面的IP部分。\n\nsort：对IP部分进行排序。\n\nuniq -c：打印每一重复行出现的次数。（并去掉重复行）\n\nsort -n -r：按照重复行出现的次序倒序排列。\n\nhead -n 5：取排在前5位的IP \n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;p&gt;作者：Hello_刘&lt;br&gt;\n来源：CSDN&lt;br&gt;\n原文：https://blog.csdn.net/xiamoyanyulrq/article/details/81570652&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;shell-tong-ji-ip-chu-xian-pin-ci&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;统计文件或者系统内IP出现频率&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Shell统计IP出现频次&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-15 20:07:31&#34;,&#34;dateFormat&#34;:&#34;2019-03-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/shell-tong-ji-ip-chu-xian-pin-ci/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:158000,&#34;words&#34;:534,&#34;minutes&#34;:3},&#34;description&#34;:&#34;统计文件或者系统内IP出现频率\n\n统计文件里的IP\n准备文件\n首先准备文件demo.txt，内容如下：\n1 192.168.41.20 \n2 192.168.41.21 \n3 192.168.41.22 \n4 192.168.41.23 \n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E9%87%8C%E7%9A%84ip\&#34;&gt;统计文件里的IP&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%86%E5%A4%87%E6%96%87%E4%BB%B6\&#34;&gt;准备文件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%9F%E8%AE%A1\&#34;&gt;统计&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%9F%E8%AE%A1netstat-ntu%E5%91%BD%E4%BB%A4%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84ip%E5%9C%B0%E5%9D%80\&#34;&gt;统计&lt;code&gt;netstat -ntu&lt;/code&gt;命令的结果中出现次数最多的ip地址：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;转载自阮一峰的博客文章&lt;a href=\&#34;http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html\&#34;&gt;Systemd 入门教程：实战篇 &lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;作为学习摘录&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h1 id=\&#34;一-开机启动\&#34;&gt;一、开机启动&lt;/h1&gt;\n&lt;p&gt;对于那些支持 Systemd 的软件，安装的时候，会自动在&lt;code&gt;/usr/lib/systemd/system&lt;/code&gt;目录添加一个配置文件。&lt;/p&gt;\n&lt;p&gt;如果你想让该软件开机启动，就执行下面的命令（以&lt;code&gt;httpd.service&lt;/code&gt;为例）。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$ sudo systemctl enable httpd\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面的命令相当于在&lt;code&gt;/etc/systemd/system&lt;/code&gt;目录添加一个符号链接，指向&lt;code&gt;/usr/lib/systemd/system&lt;/code&gt;里面的&lt;code&gt;httpd.service&lt;/code&gt;文件。&lt;/p&gt;\n&lt;p&gt;这是因为开机时，&lt;code&gt;Systemd&lt;/code&gt;只执行&lt;code&gt;/etc/systemd/system&lt;/code&gt;目录里面的配置文件。这也意味着，如果把修改后的配置文件放在该目录，就可以达到覆盖原始配置的效果。&lt;/p&gt;\n&lt;h1 id=\&#34;二-启动服务\&#34;&gt;二、启动服务&lt;/h1&gt;\n&lt;p&gt;设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行&lt;code&gt;systemctl start&lt;/code&gt;命令。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$ sudo systemctl start httpd\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;执行上面的命令以后，有可能启动失败，因此要用&lt;code&gt;systemctl status&lt;/code&gt;命令查看一下该服务的状态。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$ sudo systemctl status httpd\n\nhttpd.service - The Apache HTTP Server\n   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled)\n   Active: active (running) since 金 2014-12-05 12:18:22 JST; 7min ago\n Main PID: 4349 (httpd)\n   Status: &amp;quot;Total requests: 1; Current requests/sec: 0; Current traffic:   0 B/sec&amp;quot;\n   CGroup: /system.slice/httpd.service\n           ├─4349 /usr/sbin/httpd -DFOREGROUND\n           ├─4350 /usr/sbin/httpd -DFOREGROUND\n           ├─4351 /usr/sbin/httpd -DFOREGROUND\n           ├─4352 /usr/sbin/httpd -DFOREGROUND\n           ├─4353 /usr/sbin/httpd -DFOREGROUND\n           └─4354 /usr/sbin/httpd -DFOREGROUND\n\n12月 05 12:18:22 localhost.localdomain systemd[1]: Starting The Apache HTTP Server...\n12月 05 12:18:22 localhost.localdomain systemd[1]: Started The Apache HTTP Server.\n12月 05 12:22:40 localhost.localdomain systemd[1]: Started The Apache HTTP Server.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面的输出结果含义如下。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Loaded行：配置文件的位置，是否设为开机启动&lt;/li&gt;\n&lt;li&gt;Active行：表示正在运行&lt;/li&gt;\n&lt;li&gt;Main PID行：主进程ID&lt;/li&gt;\n&lt;li&gt;Status行：由应用本身（这里是 httpd ）提供的软件当前状态&lt;/li&gt;\n&lt;li&gt;CGroup块：应用的所有子进程&lt;/li&gt;\n&lt;li&gt;日志块：应用的日志&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;三-停止服务\&#34;&gt;三、停止服务&lt;/h1&gt;\n&lt;p&gt;终止正在运行的服务，需要执行&lt;code&gt;systemctl stop&lt;/code&gt;命令。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$ sudo systemctl stop httpd.service\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;有时候，该命令可能没有响应，服务停不下来。这时候就不得不&amp;quot;杀进程&amp;quot;了，向正在运行的进程发出&lt;code&gt;kill&lt;/code&gt;信号。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$ sudo systemctl kill httpd.service\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;此外，重启服务要执行&lt;code&gt;systemctl restart&lt;/code&gt;命令。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$ sudo systemctl restart httpd.service\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;四-读懂配置文件\&#34;&gt;四、读懂配置文件&lt;/h1&gt;\n&lt;p&gt;一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。&lt;/p&gt;\n&lt;p&gt;前面说过，配置文件主要放在&lt;code&gt;/usr/lib/systemd/system&lt;/code&gt;目录，也可能在&lt;code&gt;/etc/systemd/system&lt;/code&gt;目录。找到配置文件以后，使用文本编辑器打开即可。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;systemctl cat&lt;/code&gt;命令可以用来查看配置文件，下面以&lt;code&gt;sshd.service&lt;/code&gt;文件为例，它的作用是启动一个 SSH 服务器，供其他用户以 SSH 方式登录。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$ systemctl cat sshd.service\n\n[Unit]\nDescription=OpenSSH server daemon\nDocumentation=man:sshd(8) man:sshd_config(5)\nAfter=network.target sshd-keygen.service\nWants=sshd-keygen.service\n\n[Service]\nEnvironmentFile=/etc/sysconfig/sshd\nExecStart=/usr/sbin/sshd -D $OPTIONS\nExecReload=/bin/kill -HUP $MAINPID\nType=simple\nKillMode=process\nRestart=on-failure\nRestartSec=42s\n\n[Install]\nWantedBy=multi-user.target\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看到，配置文件分成几个区块，每个区块包含若干条键值对。&lt;/p&gt;\n&lt;p&gt;下面依次解释每个区块的内容。&lt;/p&gt;\n&lt;h1 id=\&#34;五-unit-区块启动顺序与依赖关系\&#34;&gt;五、 [Unit] 区块：启动顺序与依赖关系。&lt;/h1&gt;\n&lt;p&gt;&lt;code&gt;Unit&lt;/code&gt;区块的&lt;code&gt;Description&lt;/code&gt;字段给出当前服务的简单描述，&lt;code&gt;Documentation&lt;/code&gt;字段给出文档位置。&lt;/p&gt;\n&lt;p&gt;接下来的设置是启动顺序和依赖关系，这个比较重要。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;After&lt;/code&gt;字段：表示如果&lt;code&gt;network.target&lt;/code&gt;或&lt;code&gt;sshd-keygen.service&lt;/code&gt;需要启动，那么sshd.service应该在它们之后启动。&lt;/li&gt;\n&lt;li&gt;相应地，还有一个&lt;code&gt;Before&lt;/code&gt;字段，定义&lt;code&gt;sshd.service&lt;/code&gt;应该在哪些服务之前启动。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;注意，&lt;code&gt;After&lt;/code&gt;和&lt;code&gt;Before&lt;/code&gt;字段只涉及启动顺序，不涉及依赖关系。&lt;/p&gt;\n&lt;p&gt;举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。&lt;/p&gt;\n&lt;p&gt;设置依赖关系，需要使用&lt;code&gt;Wants&lt;/code&gt;字段和&lt;code&gt;Requires&lt;/code&gt;字段。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;Wants字段：表示sshd.service与sshd-keygen.service之间存在&amp;quot;弱依赖&amp;quot;关系，即如果&amp;quot;sshd-keygen.service&amp;quot;启动失败或停止运行，不影响sshd.service继续执行。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Requires字段则表示&amp;quot;强依赖&amp;quot;关系，即如果该服务启动失败或异常退出，那么sshd.service也必须退出。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;注意，Wants字段与Requires字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。&lt;/p&gt;\n&lt;h1 id=\&#34;六-service-区块启动行为\&#34;&gt;六、[Service] 区块：启动行为&lt;/h1&gt;\n&lt;p&gt;&lt;code&gt;Service&lt;/code&gt;区块定义如何启动当前服务。&lt;/p&gt;\n&lt;h2 id=\&#34;61-启动命令\&#34;&gt;6.1 启动命令&lt;/h2&gt;\n&lt;p&gt;许多软件都有自己的环境参数文件，该文件可以用&lt;code&gt;EnvironmentFile&lt;/code&gt;字段读取。&lt;/p&gt;\n&lt;h3 id=\&#34;environmentfile字段\&#34;&gt;&lt;code&gt;EnvironmentFile&lt;/code&gt;字段：&lt;/h3&gt;\n&lt;p&gt;指定当前服务的环境参数文件。该文件内部的&lt;code&gt;key=value&lt;/code&gt;键值对，可以用&lt;code&gt;$key&lt;/code&gt;的形式，在当前配置文件中获取。&lt;/p&gt;\n&lt;p&gt;上面的例子中，&lt;code&gt;sshd&lt;/code&gt; 的环境参数文件是&lt;code&gt;/etc/sysconfig/sshd&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;配置文件里面最重要的字段是ExecStart。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;ExecStart字段：定义启动进程时执行的命令。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面的例子中，启动&lt;code&gt;sshd&lt;/code&gt;，执行的命令是&lt;code&gt;/usr/sbin/sshd -D $OPTIONS&lt;/code&gt;，其中的变量&lt;code&gt;$OPTIONS&lt;/code&gt;就来自&lt;code&gt;EnvironmentFile&lt;/code&gt;字段指定的环境参数文件。&lt;/p&gt;\n&lt;p&gt;与之作用相似的，还有如下这些字段。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;ExecReload字段：重启服务时执行的命令&lt;/li&gt;\n&lt;li&gt;ExecStop字段：停止服务时执行的命令&lt;/li&gt;\n&lt;li&gt;ExecStartPre字段：启动服务之前执行的命令&lt;/li&gt;\n&lt;li&gt;ExecStartPost字段：启动服务之后执行的命令&lt;/li&gt;\n&lt;li&gt;ExecStopPost字段：停止服务之后执行的命令&lt;br&gt;\n请看下面的例子。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;[Service]\nExecStart=/bin/echo execstart1\nExecStart=\nExecStart=/bin/echo execstart2\nExecStartPost=/bin/echo post1\nExecStartPost=/bin/echo post2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面这个配置文件，第二行&lt;code&gt;ExecStart&lt;/code&gt;设为空值，等于取消了第一行的设置，运行结果如下。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;\nexecstart2\npost1\npost2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;所有的启动设置之前，都可以加上一个连词号（-），表示&amp;quot;抑制错误&amp;quot;，即发生错误的时候，不影响其他命令的执行。比如，&lt;code&gt;EnvironmentFile=-/etc/sysconfig/sshd&lt;/code&gt;（注意等号后面的那个连词号），就表示即使&lt;code&gt;/etc/sysconfig/sshd&lt;/code&gt;文件不存在，也不会抛出错误。&lt;/p&gt;\n&lt;h2 id=\&#34;62-启动类型\&#34;&gt;6.2 启动类型&lt;/h2&gt;\n&lt;p&gt;Type字段定义启动类型。它可以设置的值如下。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;simple（默认值）：ExecStart字段启动的进程为主进程&lt;/li&gt;\n&lt;li&gt;forking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程&lt;/li&gt;\n&lt;li&gt;oneshot：类似于simple，但只执行一次，Systemd 会等它执行完，才启动其他服务&lt;/li&gt;\n&lt;li&gt;dbus：类似于simple，但会等待 D-Bus 信号后启动&lt;/li&gt;\n&lt;li&gt;notify：类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务&lt;/li&gt;\n&lt;li&gt;idle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;下面是一个oneshot的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;\n[Unit]\nDescription=Switch-off Touchpad\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/touchpad-off\n\n[Install]\nWantedBy=multi-user.target\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面的配置文件，启动类型设为&lt;code&gt;oneshot&lt;/code&gt;，就表明这个服务只要运行一次就够了，不需要长期运行。&lt;/p&gt;\n&lt;p&gt;如果关闭以后，将来某个时候还想打开，配置文件修改如下。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[Unit]\nDescription=Switch-off Touchpad\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/touchpad-off start\nExecStop=/usr/bin/touchpad-off stop\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面配置文件中，&lt;code&gt;RemainAfterExit&lt;/code&gt;字段设为&lt;code&gt;yes&lt;/code&gt;，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用&lt;code&gt;systemctl stop&lt;/code&gt;命令停止服务，&lt;code&gt;ExecStop&lt;/code&gt;指定的命令就会执行，从而重新开启触摸板。&lt;/p&gt;\n&lt;h2 id=\&#34;63-重启行为\&#34;&gt;6.3 重启行为&lt;/h2&gt;\n&lt;p&gt;Service区块有一些字段，定义了重启行为。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;KillMode字段：定义 Systemd 如何停止 sshd 服务。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面这个例子中，将&lt;code&gt;KillMode&lt;/code&gt;设为&lt;code&gt;process&lt;/code&gt;，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对 sshd 很重要，否则你停止服务的时候，会连自己打开的 SSH session 一起杀掉。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;KillMode&lt;/code&gt;字段可以设置的值如下。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉&lt;/li&gt;\n&lt;li&gt;process：只杀主进程&lt;/li&gt;\n&lt;li&gt;mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号&lt;/li&gt;\n&lt;li&gt;none：没有进程会被杀掉，只是执行服务的 stop 命令。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;接下来是Restart字段。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Restart字段：定义了 sshd 退出后，Systemd 的重启方式。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面的例子中，&lt;code&gt;Restart&lt;/code&gt;设为&lt;code&gt;on-failure&lt;/code&gt;，表示任何意外的失败，就将重启sshd。如果 sshd 正常停止（比如执行&lt;code&gt;systemctl stop&lt;/code&gt;命令），它就不会重启。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;Restart&lt;/code&gt;字段可以设置的值如下。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;no（默认值）：退出后不会重启&lt;/li&gt;\n&lt;li&gt;on-success：只有正常退出时（退出状态码为0），才会重启&lt;/li&gt;\n&lt;li&gt;on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启&lt;/li&gt;\n&lt;li&gt;on-abnormal：只有被信号终止和超时，才会重启&lt;/li&gt;\n&lt;li&gt;on-abort：只有在收到没有捕捉到的信号终止时，才会重启&lt;/li&gt;\n&lt;li&gt;on-watchdog：超时退出，才会重启&lt;/li&gt;\n&lt;li&gt;always：不管是什么退出原因，总是重启&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;对于守护进程，推荐设为&lt;code&gt;on-failure&lt;/code&gt;。对于那些允许发生错误退出的服务，可以设&lt;code&gt;为on-abnormal&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;最后是&lt;code&gt;RestartSec&lt;/code&gt;字段。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;RestartSec字段：表示 Systemd 重启服务之前，需要等待的秒数。上面的例子设为等待42秒。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;七-install-区块\&#34;&gt;七、[Install] 区块&lt;/h1&gt;\n&lt;p&gt;&lt;code&gt;Install&lt;/code&gt;区块，定义如何安装这个配置文件，即怎样做到开机启动。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;WantedBy&lt;/code&gt;字段：表示该服务所在的 Target。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;Target&lt;/code&gt;的含义是服务组，表示一组服务。&lt;code&gt;WantedBy=multi-user.target&lt;/code&gt;指的是，sshd 所在的 &lt;code&gt;Target&lt;/code&gt; 是&lt;code&gt;multi-user.target&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;这个设置非常重要，因为执行&lt;code&gt;systemctl enable sshd.service&lt;/code&gt;命令时，&lt;code&gt;sshd.service&lt;/code&gt;的一个符号链接，就会放在&lt;code&gt;/etc/systemd/system&lt;/code&gt;目录下面的&lt;code&gt;multi-user.target.wants&lt;/code&gt;子目录之中。&lt;/p&gt;\n&lt;p&gt;Systemd 有默认的启动 Target。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$ systemctl get-default\nmulti-user.target\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面的结果表示，默认的启动 Target 是&lt;code&gt;multi-user.target&lt;/code&gt;。在这个组里的所有服务，都将开机启动。这就是为什么&lt;code&gt;systemctl enable&lt;/code&gt;命令能设置开机启动的原因。&lt;/p&gt;\n&lt;p&gt;使用 Target 的时候，&lt;code&gt;systemctl list-dependencies&lt;/code&gt;命令和&lt;code&gt;systemctl isolate&lt;/code&gt;命令也很有用。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;# 查看 multi-user.target 包含的所有服务\n$ systemctl list-dependencies multi-user.target\n\n# 切换到另一个 target\n# shutdown.target 就是关机状态\n$ sudo systemctl isolate shutdown.target\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;一般来说，常用的 Target 有两个：一个是&lt;code&gt;multi-user.target&lt;/code&gt;，表示多用户命令行状态；另一个是&lt;code&gt;graphical.target&lt;/code&gt;，表示图形用户状态，它依赖于&lt;code&gt;multi-user.target&lt;/code&gt;。官方文档有一张非常清晰的&lt;a href=\&#34;https://www.freedesktop.org/software/systemd/man/bootup.html#System%20Manager%20Bootup\&#34;&gt; Target 依赖关系图&lt;/a&gt;。&lt;/p&gt;\n&lt;h1 id=\&#34;八-target-的配置文件\&#34;&gt;八、Target 的配置文件&lt;/h1&gt;\n&lt;p&gt;Target 也有自己的配置文件。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;\n$ systemctl cat multi-user.target\n\n[Unit]\nDescription=Multi-User System\nDocumentation=man:systemd.special(7)\nRequires=basic.target\nConflicts=rescue.service rescue.target\nAfter=basic.target rescue.service rescue.target\nAllowIsolate=yes\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注意，Target 配置文件里面没有启动命令。&lt;/p&gt;\n&lt;p&gt;上面输出结果中，主要字段含义如下。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Requires字段：要求basic.target一起运行。\n\nConflicts字段：冲突字段。如果rescue.service或rescue.target正在运行，multi-user.target就不能运行，反之亦然。\n\nAfter：表示multi-user.target在basic.target 、 rescue.service、 rescue.target之后启动，如果它们有启动的话。\n\nAllowIsolate：允许使用systemctl isolate命令切换到multi-user.target。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;九-修改配置文件后重启\&#34;&gt;九、修改配置文件后重启&lt;/h1&gt;\n&lt;p&gt;修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;# 重新加载配置文件\n$ sudo systemctl daemon-reload\n\n# 重启相关服务\n$ sudo systemctl restart foobar\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;systemd-shi-zhan&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;转载自阮一峰的博客文章&lt;a href=\&#34;http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html\&#34;&gt;Systemd 入门教程：实战篇 &lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;作为学习摘录&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;systemd实战&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-11 20:08:11&#34;,&#34;dateFormat&#34;:&#34;2019-03-11&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/systemd-shi-zhan/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;12 min read&#34;,&#34;time&#34;:698000,&#34;words&#34;:2946,&#34;minutes&#34;:12},&#34;description&#34;:&#34;转载自阮一峰的博客文章Systemd 入门教程：实战篇 \n作为学习摘录\n\n一、开机启动\n对于那些支持 Systemd 的软件，安装的时候，会自动在/usr/lib/systemd/system目录添加一个配置文件。\n如果你想让该软件开机启动...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8\&#34;&gt;一、开机启动&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1\&#34;&gt;二、启动服务&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%89-%E5%81%9C%E6%AD%A2%E6%9C%8D%E5%8A%A1\&#34;&gt;三、停止服务&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9B-%E8%AF%BB%E6%87%82%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\&#34;&gt;四、读懂配置文件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%94-unit-%E5%8C%BA%E5%9D%97%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F%E4%B8%8E%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB\&#34;&gt;五、 [Unit] 区块：启动顺序与依赖关系。&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%AD-service-%E5%8C%BA%E5%9D%97%E5%90%AF%E5%8A%A8%E8%A1%8C%E4%B8%BA\&#34;&gt;六、[Service] 区块：启动行为&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#61-%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4\&#34;&gt;6.1 启动命令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#environmentfile%E5%AD%97%E6%AE%B5\&#34;&gt;&lt;code&gt;EnvironmentFile&lt;/code&gt;字段：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#62-%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%9E%8B\&#34;&gt;6.2 启动类型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#63-%E9%87%8D%E5%90%AF%E8%A1%8C%E4%B8%BA\&#34;&gt;6.3 重启行为&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%83-install-%E5%8C%BA%E5%9D%97\&#34;&gt;七、[Install] 区块&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%AB-target-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\&#34;&gt;八、Target 的配置文件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B9%9D-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%8E%E9%87%8D%E5%90%AF\&#34;&gt;九、修改配置文件后重启&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;此处捕获一只快乐的野生技术宅&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;em&gt;宅？不宅？宅？Orz~&lt;/em&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;关于本站\&#34;&gt;🏠 关于本站&lt;/h2&gt;\n&lt;h2 id=\&#34;博主是谁\&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;\n&lt;h2 id=\&#34;关注\&#34;&gt;👀关注&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;DevOps技术&lt;/li&gt;\n&lt;li&gt;Service Mesh &amp;amp;&amp;amp; Micro Service&lt;/li&gt;\n&lt;li&gt;Iot &amp;amp;&amp;amp; Hardware Security &amp;amp;&amp;amp; Edge Computing&lt;/li&gt;\n&lt;li&gt;Kubernetes&lt;/li&gt;\n&lt;li&gt;Golang&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;折腾\&#34;&gt;🔧折腾&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;各种嵌入式(RaspberryPi，BeagleBone，ESP8266，STM32~~~)&lt;/li&gt;\n&lt;li&gt;拆拆拆~~~(常游走于&lt;a href=\&#34;https://www.mydigit.cn/\&#34;&gt;数码之家&lt;/a&gt;)&lt;/li&gt;\n&lt;li&gt;黑苹果Hackintosh (常游走于&lt;a href=\&#34;http://bbs.pcbeta.com/\&#34;&gt;远景论坛&lt;/a&gt;)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;喜欢\&#34;&gt;⛹ 喜欢&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;旅行 (哪儿都想去~)&lt;/li&gt;\n&lt;li&gt;吃吃吃(baes成都~~~)&lt;/li&gt;\n&lt;li&gt;数码周边~~~(带电的都玩)(弱电！ =_=  被自动化专业支配的恐惧)&lt;/li&gt;\n&lt;li&gt;各种开源新工具 （人送外号小叮当）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;不喜欢\&#34;&gt;不喜欢&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;选择 (选择困难啊~~)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;联系我呀\&#34;&gt;📬 联系我呀&lt;/h2&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-25 19:09:48&#34;,&#34;dateFormat&#34;:&#34;2019-01-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/about/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:34000,&#34;words&#34;:149,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n此处捕获一只快乐的野生技术宅\n\n宅？不宅？宅？Orz~\n🏠 关于本站\n👨‍💻 博主是谁\n👀关注\n\nDevOps技术\nService Mesh &amp;amp;&amp;amp; Micro Service\nIot &amp;amp;&amp;amp; Hard...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99\&#34;&gt;🏠 关于本站&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E4%B8%BB%E6%98%AF%E8%B0%81\&#34;&gt;👨‍💻 博主是谁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E6%B3%A8\&#34;&gt;👀关注&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8A%98%E8%85%BE\&#34;&gt;🔧折腾&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%96%9C%E6%AC%A2\&#34;&gt;⛹ 喜欢&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8D%E5%96%9C%E6%AC%A2\&#34;&gt;不喜欢&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%94%E7%B3%BB%E6%88%91%E5%91%80\&#34;&gt;📬 联系我呀&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;帮公司打包业务Docker images时发现rewrire规则默认没有打开，查询解法如下&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h2 id=\&#34;apache开启rewrite重写\&#34;&gt;apache开启rewrite重写&lt;/h2&gt;\n&lt;h3 id=\&#34;命令开启\&#34;&gt;命令开启&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;sudo a2enmod rewrite\nsudo /etc/init.d/apache2 restart\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;文件修改启动\&#34;&gt;文件修改启动&lt;/h3&gt;\n&lt;p&gt;在终端输入：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;sudo a2enmod rewrite  #开启Rewrite模块（停用模块，使用 a2dismod）\n\nsudo gedit /etc/apache2/sites-available/default \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;修改下面的地方&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-apache\&#34;&gt;&amp;lt;Directory /&amp;gt;\n\nOptions FollowSymLinks\n\nAllowOverride None（修改为AllowOverride All）\n\n&amp;lt;/Directory&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-apache\&#34;&gt;&amp;lt;Directory &amp;quot;/var/orioner&amp;quot;&amp;gt;\n\nOptions Indexes FollowSymLinks MultiViews\n\nAllowOverride None（修改为AllowOverride All）\n\nOrder allow,deny\n\nallow from all\n\n&amp;lt;/Directory&amp;gt;\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;最后&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;sudo /etc/init.d/apache2 restart。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;建立htaccess\&#34;&gt;建立htaccess&lt;/h3&gt;\n&lt;p&gt;在网站下面建立.htaccess文件&lt;/p&gt;\n&lt;p&gt;修改.htaccess文件属性  chmod -R 777 .htaccess&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;httpd-kai-qi-rewrite-gong-neng&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;帮公司打包业务Docker images时发现rewrire规则默认没有打开，查询解法如下&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Httpd开启rewrite功能&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-14 20:10:36&#34;,&#34;dateFormat&#34;:&#34;2019-01-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/httpd-kai-qi-rewrite-gong-neng/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:44000,&#34;words&#34;:158,&#34;minutes&#34;:1},&#34;description&#34;:&#34;帮公司打包业务Docker images时发现rewrire规则默认没有打开，查询解法如下\n\napache开启rewrite重写\n命令开启\nsudo a2enmod rewrite\nsudo /etc/init.d/apache2 rest...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#apache%E5%BC%80%E5%90%AFrewrite%E9%87%8D%E5%86%99\&#34;&gt;apache开启rewrite重写&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%BD%E4%BB%A4%E5%BC%80%E5%90%AF\&#34;&gt;命令开启&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E5%90%AF%E5%8A%A8\&#34;&gt;文件修改启动&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BB%BA%E7%AB%8Bhtaccess\&#34;&gt;建立htaccess&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;奇怪的使用场景用到了nginx的四层代理转发&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h2 id=\&#34;配置nginx转发tcp\&#34;&gt;配置nginx转发tcp&lt;/h2&gt;\n&lt;h3 id=\&#34;1查看版本以及原始编译参数\&#34;&gt;1.查看版本以及原始编译参数&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;nginx -V\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;nginx version: nginx/1.12.2\nbuilt by gcc 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) \nbuilt with OpenSSL 1.0.2k-fips  26 Jan 2017\nTLS SNI support enabled\nconfigure arguments: --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx \\\n--modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf \\\n--error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log \\\n--http-client-body-temp-path=/var/lib/nginx/tmp/client_body \\\n--http-proxy-temp-path=/var/lib/nginx/tmp/proxy \\\n--http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi \\\n--http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi \\\n--http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid \\\n--lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-file-aio \\\n--with-http_auth_request_module --with-http_ssl_module --with-http_v2_module \\\n--with-http_realip_module --with-http_addition_module --with-http_xslt_module=dynamic \\\n--with-http_image_filter_module=dynamic --with-http_geoip_module=dynamic \\\n--with-http_sub_module --with-http_dav_module --with-http_flv_module \\\n--with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module \\\n--with-http_random_index_module --with-http_secure_link_module \\\n--with-http_degradation_module --with-http_slice_module --with-http_stub_status_module \\\n--with-http_perl_module=dynamic --with-mail=dynamic --with-mail_ssl_module --with-pcre \\\n--with-pcre-jit --with-debug --with-stream=dynamic --with-cc-opt=&#39;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic&#39; \n--with-ld-opt=&#39;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&#39; \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;此处参考自己当前使用的nginx编译参数&lt;/p&gt;\n&lt;h3 id=\&#34;2编译配置\&#34;&gt;2.编译，配置&lt;/h3&gt;\n&lt;p&gt;在configure里增加如下参数启用模块&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;./configure --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx \\\n--modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf \\\n--error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log \\\n--http-client-body-temp-path=/var/lib/nginx/tmp/client_body \\\n--http-proxy-temp-path=/var/lib/nginx/tmp/proxy \\\n--http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi \\\n--http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi \\\n--http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid \\\n--lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-file-aio \\\n--with-http_auth_request_module --with-http_ssl_module --with-http_v2_module \\\n--with-http_realip_module --with-http_addition_module --with-http_xslt_module=dynamic \\\n--with-http_image_filter_module=dynamic --with-http_geoip_module=dynamic \\\n--with-http_sub_module --with-http_dav_module --with-http_flv_module \\\n--with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module \\\n--with-http_random_index_module --with-http_secure_link_module \\\n--with-http_degradation_module --with-http_slice_module --with-http_stub_status_module \\\n--with-http_perl_module=dynamic --with-mail=dynamic --with-mail_ssl_module --with-pcre \\\n--with-pcre-jit --with-stream --with-stream=dynamic --with-stream_ssl_preread_module \\\n--with-stream_ssl_module --with-debug --with-cc-opt=&#39;-O2 -g -pipe -Wall \\\n-Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 \\\n-grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic&#39; \\\n--with-ld-opt=&#39;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&#39; \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;最主要的使用&lt;code&gt;--with-stream --with-stream_ssl_preread_module --with-stream_ssl_module&lt;/code&gt; 这几个模块，有需要可以添加其它的模块；然后编译安装make &amp;amp;&amp;amp; make install。&lt;/p&gt;\n&lt;h3 id=\&#34;3配置\&#34;&gt;3.配置&lt;/h3&gt;\n&lt;p&gt;具体配置命令参考pread module和stream module，启动的时候指定下面的配置文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-nginx\&#34;&gt;user  root;\nworker_processes  auto;\nerror_log  logs/error.log;\npid        logs/nginx.pid;\nworker_rlimit_core   2G;\nworker_rlimit_nofile 65535;\nevents {\n    worker_connections  81920;\n}\nstream {\n    log_format  main  &#39;$remote_addr - [$time_local] $connection &#39;\n                      &#39;$status $proxy_protocol_addr $server_addr &#39;;\n    access_log  logs/access.log  main;\n    resolver 114.114.114.114;\n    resolver_timeout 60s;\n    variables_hash_bucket_size 512;\n    server {\n        listen       443;\n        ssl_preread on;\n        proxy_pass $ssl_preread_server_name:443;\n        #大致看了一下源码，这里为什么需要配置端口也没有研究明白，求解释？\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;此处我使用的的是另一套配置,可以时间根据域名转发https(这段配置丢到stream配置块内)&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-nginx\&#34;&gt;map $ssl_preread_server_name $backend_pool {\n    a.com    a;\n    b.com    b;\n}\nupstream aaa{\n    server 192.168.166.3:443;\n}\nupstream bbb{\n    server 192.168.166.4:443;\n}\nserver {\n    listen 443;\n    ssl_preread on;\n    resolver 223.5.5.5; \n    proxy_pass $backend_pool;\n    proxy_connect_timeout 15s;\n    proxy_timeout 15s;\n    proxy_next_upstream_timeout 15s;\n    error_log /var/log/nginx/tcp_a.com.log warn;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样就可以给&lt;code&gt;https://a.com&lt;/code&gt; 和&lt;code&gt;https://b.com&lt;/code&gt;两个域名做tcp层的代理了，其他域名如果也绑host过来就会被403掉。&lt;br&gt;\n这里其实是利用了NGINX的TCP转发做了SNI 反代，与普通的http/http的区别在于，TCP转发只是四层转发不需要证书&lt;/p&gt;\n&lt;h3 id=\&#34;4遇到的问题\&#34;&gt;4.遇到的问题&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;编译错误1&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;./configure: error: the invalid value in --with-ld-opt=&amp;quot;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&amp;quot;\n#解决方案\nyum install redhat-rpm-config\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;缺少依赖库&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;#根据缺少内容进行安装\nyum install perl-ExtUtils-Embed gd-devel gperftools-devel\nyum install gcc \nyum install pcre-devel  openssl-devel\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;nginx-tcp-si-ceng-zhuan-fa-https&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;奇怪的使用场景用到了nginx的四层代理转发&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Nginx TCP四层转发HTTPS&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-14 20:09:37&#34;,&#34;dateFormat&#34;:&#34;2019-01-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/nginx-tcp-si-ceng-zhuan-fa-https/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:297000,&#34;words&#34;:923,&#34;minutes&#34;:5},&#34;description&#34;:&#34;奇怪的使用场景用到了nginx的四层代理转发\n\n配置nginx转发tcp\n1.查看版本以及原始编译参数\nnginx -V\n\nnginx version: nginx/1.12.2\nbuilt by gcc 4.8.5 20150623 (R...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AEnginx%E8%BD%AC%E5%8F%91tcp\&#34;&gt;配置nginx转发tcp&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E6%9F%A5%E7%9C%8B%E7%89%88%E6%9C%AC%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%A7%8B%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0\&#34;&gt;1.查看版本以及原始编译参数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE\&#34;&gt;2.编译，配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3%E9%85%8D%E7%BD%AE\&#34;&gt;3.配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98\&#34;&gt;4.遇到的问题&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;RT Hackintosh是一个好东西，但是苹果这bug不修就很不爽了&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h2 id=\&#34;症状\&#34;&gt;症状&lt;/h2&gt;\n&lt;p&gt;无效的服务器地址 BasicIPv6ValidationError错误解决方法&lt;/p&gt;\n&lt;h2 id=\&#34;解决方案\&#34;&gt;解决方案：&lt;/h2&gt;\n&lt;p&gt;思路是这样的：先关闭IPv6，然后设置IPv4，再重新开启IPv6。&lt;/p&gt;\n&lt;p&gt;update 2018.08.08  我发现其实可以直接用命令行修改IPv4，不用管IPv6，如果它没报错的话&lt;/p&gt;\n&lt;h3 id=\&#34;1-关闭-ipv6\&#34;&gt;1. 关闭 IPv6&lt;/h3&gt;\n&lt;p&gt;显然 ”高级“ &amp;gt; &amp;quot;TCP/IP&amp;quot; 下 IPv6 没有提供关闭选项，所以需要用终端命令&lt;/p&gt;\n&lt;p&gt;终端输入：&lt;code&gt;networksetup -setv6off Ethernet&lt;/code&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;2-设置ipv4地址\&#34;&gt;2. 设置IPv4地址&lt;/h3&gt;\n&lt;p&gt;终端输入：&lt;code&gt;networksetup -setmanual Ethernet 192.168.31.2 255.255.255.0 192.168.1.1&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;对应IP地址、子网掩码、路由器&lt;/p&gt;\n&lt;p&gt;设置完成后，可以看到，以太网显示状态是：已连接&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mac-osx-1014-wang-qia-pei-zhi-cuo-wu&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;RT Hackintosh是一个好东西，但是苹果这bug不修就很不爽了&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;mac osx 10.14网卡配置错误&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-14 19:11:23&#34;,&#34;dateFormat&#34;:&#34;2019-01-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/mac-osx-1014-wang-qia-pei-zhi-cuo-wu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:45000,&#34;words&#34;:191,&#34;minutes&#34;:1},&#34;description&#34;:&#34;RT Hackintosh是一个好东西，但是苹果这bug不修就很不爽了\n\n症状\n无效的服务器地址 BasicIPv6ValidationError错误解决方法\n解决方案：\n思路是这样的：先关闭IPv6，然后设置IPv4，再重新开启IPv6。...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%97%87%E7%8A%B6\&#34;&gt;症状&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\&#34;&gt;解决方案：&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%85%B3%E9%97%AD-ipv6\&#34;&gt;1. 关闭 IPv6&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E8%AE%BE%E7%BD%AEipv4%E5%9C%B0%E5%9D%80\&#34;&gt;2. 设置IPv4地址&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;最近东西都整理到了有道云笔记里了，一直没空发，还是搬过来些吧，不用显得那么凄凉～&lt;/p&gt;\n&lt;!--more---&gt;\n&lt;h2 id=\&#34;一-文件夹式\&#34;&gt;一、文件夹式&lt;/h2&gt;\n&lt;p&gt;任意位置新建文件夹，输入（任意名称）&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cmd\&#34;&gt;.{BF782CC9-5A52-4A17-806C-2A894FFEEAC5}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;（包括小数点和大括号）&lt;br&gt;\n例如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cmd\&#34;&gt;lang.{BF782CC9-5A52-4A17-806C-2A894FFEEAC5}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;便可直接进入语言设置&lt;/p&gt;\n&lt;h2 id=\&#34;二-快捷方式\&#34;&gt;二、快捷方式&lt;/h2&gt;\n&lt;p&gt;任意位置新建快捷方式，输入&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cmd\&#34;&gt;explorer shell:::{BF782CC9-5A52-4A17-806C-2A894FFEEAC5}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;自己指定名称，也可更改图标。例如语言设置的默认图标位于&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cmd\&#34;&gt;%SystemRoot%\\System32\\UserLanguagesCpl.dll\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;da-kai-win10-1803-de-yu-yan-mian-ban&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;打开Win10 1803的语言面板&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-14 18:12:09&#34;,&#34;dateFormat&#34;:&#34;2019-01-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/da-kai-win10-1803-de-yu-yan-mian-ban/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:32000,&#34;words&#34;:141,&#34;minutes&#34;:1},&#34;description&#34;:&#34;最近东西都整理到了有道云笔记里了，一直没空发，还是搬过来些吧，不用显得那么凄凉～\n\n一、文件夹式\n任意位置新建文件夹，输入（任意名称）\n.{BF782CC9-5A52-4A17-806C-2A894FFEEAC5}\n\n（包括小数点和大括号）...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%BC%8F\&#34;&gt;一、文件夹式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F\&#34;&gt;二、快捷方式&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;主要记录了使用vim编辑器过程中踩的一些坑以及一些技巧～&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h1 id=\&#34;vim的一些使用备忘\&#34;&gt;VIM的一些使用备忘&lt;/h1&gt;\n&lt;h2 id=\&#34;vim粘贴代码时自动缩进造成的错误\&#34;&gt;vim粘贴代码时自动缩进造成的错误&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;:set paste\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;退出粘贴模式&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;set nopaste\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;vim-shi-yong-guo-cheng-zhong-de-yi-xie-keng&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;主要记录了使用vim编辑器过程中踩的一些坑以及一些技巧～&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;vim使用过程中的一些坑&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2018-11-19 20:13:38&#34;,&#34;dateFormat&#34;:&#34;2018-11-19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/vim-shi-yong-guo-cheng-zhong-de-yi-xie-keng/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:12000,&#34;words&#34;:58,&#34;minutes&#34;:1},&#34;description&#34;:&#34;主要记录了使用vim编辑器过程中踩的一些坑以及一些技巧～\n\nVIM的一些使用备忘\nvim粘贴代码时自动缩进造成的错误\n:set paste\n\n退出粘贴模式\nset nopaste\n\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#vim%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98\&#34;&gt;VIM的一些使用备忘&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#vim%E7%B2%98%E8%B4%B4%E4%BB%A3%E7%A0%81%E6%97%B6%E8%87%AA%E5%8A%A8%E7%BC%A9%E8%BF%9B%E9%80%A0%E6%88%90%E7%9A%84%E9%94%99%E8%AF%AF\&#34;&gt;vim粘贴代码时自动缩进造成的错误&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;alpha-beta-rc-ga版本的区别\&#34;&gt;Alpha、Beta、RC、GA版本的区别&lt;/h1&gt;\n&lt;!--more--&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;Alpha：是内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Beta：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;RC：(Release　Candidate) 顾名思义么 ! 用在软件上就是候选版本。系统平台上就是发行候选版本。RC版不会再加入新的功能了，主要着重于除错。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;GA:General Availability,正式发布的版本，在国外都是用GA来说明release版本的。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;RTM：(Release to Manufacture)是给工厂大量压片的版本，内容跟正式版是一样的，不过RTM版也有出限制、评估版的。但是和正式版本的主要程序代码都是一样的。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;OEM：是给计算机厂商随着计算机贩卖的，也就是随机版。只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面CD和说明书(授权书)。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;RVL：号称是正式版，其实RVL根本不是版本的名称。它是中文版/英文版文档破解出来的。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;EVAL：而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;RTL：Retail(零售版)是真正的正式版，正式上架零售版。在安装盘的i386文件夹里有一个eula.txt，最后有一行EULAID，就是你的版本。比如简体中文正式版是EULAID:WX.4_PRO_RTL_CN，繁体中文正式版是WX.4_PRO_RTL_TW。其中：如果是WX.开头是正式版，WB.开头是测试版。_PRE，代表家庭版；_PRO，代表专业版。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;α、β、λ常用来表示软件测试过程中的三个阶段，α是第一阶段，一般只供内部测试使用；β是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用；λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;ruan-jian-ban-ben-dai-hao-de-jie-shi&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;alpha-beta-rc-ga版本的区别\&#34;&gt;Alpha、Beta、RC、GA版本的区别&lt;/h1&gt;\n&#34;,&#34;title&#34;:&#34;软件版本代号的解释&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2018-11-12 20:12:52&#34;,&#34;dateFormat&#34;:&#34;2018-11-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/ruan-jian-ban-ben-dai-hao-de-jie-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:120000,&#34;words&#34;:563,&#34;minutes&#34;:3},&#34;description&#34;:&#34;Alpha、Beta、RC、GA版本的区别\n\n\n\nAlpha：是内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。\n\n\nBeta：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。\n\n\nRC：(Rele...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#alpha-beta-rc-ga%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB\&#34;&gt;Alpha、Beta、RC、GA版本的区别&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;经过几天的测试，博客稳定了～功能可用。&lt;br&gt;\n之前日志的博客内容找时间会做排版上的修复以及调整。&lt;br&gt;\n今后不定期同步有道云写的markdown文章过来。&lt;br&gt;\n下边是本次博客迁移过程中的一些东西。&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h1 id=\&#34;博客迁移笔记\&#34;&gt;博客迁移笔记&lt;/h1&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;原博客方案wordpress-docker\&#34;&gt;原博客方案:Wordpress + Docker&lt;/h2&gt;\n&lt;h2 id=\&#34;新博客方案hexohexo-adminpm2\&#34;&gt;新博客方案:Hexo+Hexo admin+PM2&lt;/h2&gt;\n&lt;h2 id=\&#34;迁移原因\&#34;&gt;迁移原因&lt;/h2&gt;\n&lt;p&gt;新的VPS配置太低，wordpress无法扛住压力，资源消耗太多。&lt;/p&gt;\n&lt;h2 id=\&#34;部署hexo-博客系统\&#34;&gt;部署hexo 博客系统&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;Requirement: nodejs&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;安装nodejs\&#34;&gt;安装Nodejs&lt;/h3&gt;\n&lt;h3 id=\&#34;安装hexo\&#34;&gt;安装hexo&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;npm install -g hexo-cli\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;安装pm2\&#34;&gt;安装pm2&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;npm install -g pm2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;初始化hexo博客\&#34;&gt;初始化hexo博客&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;cd /home/\nhexo init hexo_blog\ncd hexo_blog\n#运行hexo\nhexo server \n#Ctrl+c 退出\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;安装hexo-admin-wordpress迁移工具\&#34;&gt;安装hexo admin &amp;amp; wordpress迁移工具&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;cd /home/hexo_blog\nnpm install hexo-migrator-wordpress --save\nnpm install --save hexo-admin\n#导入wordpress的备份文件\nhexo migrate wordpress *.wordpress.*.xml\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;几款hexo的插件\&#34;&gt;几款Hexo的插件&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;npm install hexo-generator-feed --save #RSS支持\nnpm install hexo-generator-baidu-sitemap --save #Baidu站点地图\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;参考&lt;a href=\&#34;https://www.jianshu.com/p/739bf1305e66\&#34;&gt;简书&lt;/a&gt;的优化方案&lt;/p&gt;\n&lt;h3 id=\&#34;hexo使用pm2进行进程守护\&#34;&gt;Hexo使用PM2进行进程守护&lt;/h3&gt;\n&lt;p&gt;在blog的项目目录下边创建daemon.js&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;var spawn = require(&#39;child_process&#39;).spawn;\nfree = spawn(&#39;hexo&#39;, [&#39;server&#39;,&#39;-p 18868&#39;]);/* 其实就是等于执行hexo server -p 18868*/\nfree.stdout.on(&#39;data&#39;, function (data) {\n    console.log(&#39;standard output:\\n&#39; + data);\n});\nfree.stderr.on(&#39;data&#39;, function (data) {\n    console.log(&#39;standard error output:\\n&#39; + data);\n});\nfree.on(&#39;exit&#39;, function (code, signal) {\n    console.log(&#39;child process eixt ,exit:&#39; + code);\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;使用pm2启动守护进程&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;pm2 start daemon.js --name=&amp;quot;hexo_blog&amp;quot; #以hexo_blog名字启动hexo\npm2 save    #保存pm2任务列表\npm2 startup #添加pm2开机启动服务\nsystemctl enable pm2-root.service   #启动pm2开机服务\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;添加nginx转发\&#34;&gt;添加Nginx转发&lt;/h3&gt;\n&lt;p&gt;配置文件，本文使用的是HTTPS&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;server {\n    listen      443 ssl;\n    server_name  blog.istarboy.cc;\n    ssl on;\n    ssl_certificate   cert/blog.pem;\n    ssl_certificate_key  cert/blog.key;\n    ssl_session_timeout 5m;\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers on;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n    location / {\n        proxy_pass   http://127.0.0.1:18868;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # deny access to .htaccess files, if Apache&#39;s document root\n    # concurs with nginx&#39;s one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;通过nginx将请求转发至18868端口，原因是通过httpd ab工具进行压力测试，测试结果如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@aliyun ~]# ab -c 1000 -n 1000  https://blog.istarboy.cc/2018/11/05/nginx-https中的一些经验/\nThis is ApacheBench, Version 2.3 &amp;lt;$Revision: 1430300 $&amp;gt;\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking blog.istarboy.cc (be patient)\nCompleted 100 requests\nCompleted 200 requests\nCompleted 300 requests\nCompleted 400 requests\nCompleted 500 requests\nCompleted 600 requests\nCompleted 700 requests\nCompleted 800 requests\nCompleted 900 requests\nCompleted 1000 requests\nFinished 1000 requests\n\n\nServer Software:        nginx/1.14.0\nServer Hostname:        blog.istarboy.cc\nServer Port:            443\nSSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128\n\nDocument Path:          /2018/11/05/nginx-https中的一些经验/\nDocument Length:        270 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   12.559 seconds\nComplete requests:      1000\nFailed requests:        0\nWrite errors:           0\nNon-2xx responses:      1000\nTotal transferred:      533000 bytes\nHTML transferred:       270000 bytes\nRequests per second:    79.63 [#/sec] (mean)\nTime per request:       12558.737 [ms] (mean)\nTime per request:       12.559 [ms] (mean, across all concurrent requests)\nTransfer rate:          41.45 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:      401 1060 1153.4    500   10212\nProcessing:   134  237 256.4    162    2214\nWaiting:      134  236 255.7    162    2214\nTotal:        538 1297 1162.3    951   10359\n\nPercentage of the requests served within a certain time (ms)\n  50%    951\n  66%   1093\n  75%   1383\n  80%   1648\n  90%   2614\n  95%   4220\n  98%   4507\n  99%   5107\n 100%  10359 (longest request)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;测试1000并发1000请求，因为服务器是使用的加利福尼亚的乞丐配置VPS（贫穷Orz），所以延迟尚可接受，下边是未经过nginx转发的ab测试结果。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@aliyun ~]# ab -c 1000 -n 1000  http://istarboy.cc:4000/\nThis is ApacheBench, Version 2.3 &amp;lt;$Revision: 1430300 $&amp;gt;\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking istarboy.cc (be patient)\nCompleted 100 requests\napr_socket_recv: Connection reset by peer (104)\nTotal of 151 requests completed\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Connection reset by peer!! 服务就崩了，gg，hexo自带的web server扛不住连接数啊。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@aliyun ~]# ab -c 100 -n 1000  http://istarboy.cc:4000/\nThis is ApacheBench, Version 2.3 &amp;lt;$Revision: 1430300 $&amp;gt;\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking istarboy.cc (be patient)\nCompleted 100 requests\nCompleted 200 requests\nCompleted 300 requests\nCompleted 400 requests\nCompleted 500 requests\nCompleted 600 requests\nCompleted 700 requests\nCompleted 800 requests\nCompleted 900 requests\napr_pollset_poll: The timeout specified has expired (70007)\nTotal of 999 requests completed\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;降低并发到100，依然惨不忍睹，且htop中现实服务器进入高负载的状态，完全不像Nginx转发后的结果，资源占用百分之30 -_-!!  。应该是和nginx的缓存机制有关（Nginx下的负载还和HTTPS有关系）。&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;++所以博客还是使用Nginx作为前级负载啦～++&lt;/em&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;安全相关配置\&#34;&gt;安全相关配置&lt;/h3&gt;\n&lt;p&gt;因为博客系统使用的https，同时hexo监听了本地的18868端口，并使用nginx转发了blog二级域名下的http，和https请求到本地的博客系统端口。（http使用了rewrite进行永久重定向到https）但是出现一个安全问题，通过域名/ip直接访问18868端口也是可以直接访问到非https非nginx负载的blog页面的！&lt;em&gt;Orz&lt;/em&gt;、加iptables规则！&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;iptables -I INPUT -p tcp --dport 18868 -j DROP  #禁止所有的TCP连接进入18868端口\niptables -I INPUT -p udp --dport 18868 -j DROP  #禁止所有的UDP连接进入18868端口\niptables -I INPUT -s 127.0.0.1 -ptcp --dport 18868 -j ACCEPT    #允许本地TCP访问18868端口\niptables -I INPUT -s 127.0.0.1 -pudp --dport 18868 -j ACCEPT    #允许本地UDP访问18868端口\nservice iptables save   #保存iptables规则\n# 别问我为什么web只需要加tcp就好，我为什么加udp规则，任性。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;规则设置好浏览器打开端口页面超时，服务器测试telnet连接端口超时，规则设置成功。&lt;/p&gt;\n&lt;h1 id=\&#34;cdn优化方案\&#34;&gt;CDN优化方案&lt;/h1&gt;\n&lt;p&gt;使用Nginx的GeoIP模块判断ip来源，如果来源为CN，则proxy_pass到CDN的域名上，如果非CN IP则转发至https的本地服务器上。 判断处理在HTTP监听层设计。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;bo-ke-zheng-shi-ban-jia-liao-~&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;经过几天的测试，博客稳定了～功能可用。&lt;br&gt;\n之前日志的博客内容找时间会做排版上的修复以及调整。&lt;br&gt;\n今后不定期同步有道云写的markdown文章过来。&lt;br&gt;\n下边是本次博客迁移过程中的一些东西。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;博客正式搬家了～&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2018-11-09 20:14:22&#34;,&#34;dateFormat&#34;:&#34;2018-11-09&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/bo-ke-zheng-shi-ban-jia-liao-~/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:417000,&#34;words&#34;:1423,&#34;minutes&#34;:7},&#34;description&#34;:&#34;经过几天的测试，博客稳定了～功能可用。\n之前日志的博客内容找时间会做排版上的修复以及调整。\n今后不定期同步有道云写的markdown文章过来。\n下边是本次博客迁移过程中的一些东西。\n\n博客迁移笔记\n\n原博客方案:Wordpress + Do...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E7%AC%94%E8%AE%B0\&#34;&gt;博客迁移笔记&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E5%8D%9A%E5%AE%A2%E6%96%B9%E6%A1%88wordpress-docker\&#34;&gt;原博客方案:Wordpress + Docker&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E5%8D%9A%E5%AE%A2%E6%96%B9%E6%A1%88hexohexo-adminpm2\&#34;&gt;新博客方案:Hexo+Hexo admin+PM2&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%81%E7%A7%BB%E5%8E%9F%E5%9B%A0\&#34;&gt;迁移原因&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%83%A8%E7%BD%B2hexo-%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F\&#34;&gt;部署hexo 博客系统&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85nodejs\&#34;&gt;安装Nodejs&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85hexo\&#34;&gt;安装hexo&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85pm2\&#34;&gt;安装pm2&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9D%E5%A7%8B%E5%8C%96hexo%E5%8D%9A%E5%AE%A2\&#34;&gt;初始化hexo博客&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85hexo-admin-wordpress%E8%BF%81%E7%A7%BB%E5%B7%A5%E5%85%B7\&#34;&gt;安装hexo admin &amp;amp; wordpress迁移工具&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%A0%E6%AC%BEhexo%E7%9A%84%E6%8F%92%E4%BB%B6\&#34;&gt;几款Hexo的插件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#hexo%E4%BD%BF%E7%94%A8pm2%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E5%AE%88%E6%8A%A4\&#34;&gt;Hexo使用PM2进行进程守护&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B7%BB%E5%8A%A0nginx%E8%BD%AC%E5%8F%91\&#34;&gt;添加Nginx转发&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE\&#34;&gt;安全相关配置&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#cdn%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88\&#34;&gt;CDN优化方案&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;安装\&#34;&gt;安装&lt;/h1&gt;\n&lt;h3 id=\&#34;系统要求\&#34;&gt;系统要求&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;selinux关闭&lt;/li&gt;\n&lt;li&gt;关闭swap&lt;/li&gt;\n&lt;li&gt;各主机，节点之间ip和主机名加入/etc/hosts解析&lt;/li&gt;\n&lt;li&gt;停用Firewalld&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;安装docker\&#34;&gt;安装Docker&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;使用Docker官网自动化脚本通过阿里云镜像安装&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;手动部署 (Ubuntu)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;sudo apt-get update\nsudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common\ncurl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\nsudo add-apt-repository &amp;quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&amp;quot;\nsudo apt-get -y update\nsudo apt-get -y install docker-ce\n# 安装指定版本的Docker-CE:\n# Step 1: 查找Docker-CE的版本:\n# apt-cache madison docker-ce\n#   docker-ce | 17.03.1~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages\n#   docker-ce | 17.03.0~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages\n# Step 2: 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.1~ce-0~ubuntu-xenial)\n# sudo apt-get -y install docker-ce=[VERSION]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;手动部署(Centos)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;# step 1: 安装必要的一些系统工具\nsudo yum install -y yum-utils device-mapper-persistent-data lvm2\n# Step 2: 添加软件源信息\nsudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n# Step 3: 更新并安装 Docker-CE\nsudo yum makecache fast\nsudo yum -y install docker-ce\n# Step 4: 开启Docker服务\nsudo service docker start\n\n# 注意：\n# 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。\n# vim /etc/yum.repos.d/docker-ce.repo\n#   将 [docker-ce-test] 下方的 enabled=0 修改为 enabled=1\n#\n# 安装指定版本的Docker-CE:\n# Step 1: 查找Docker-CE的版本:\n# yum list docker-ce.x86_64 --showduplicates | sort -r\n#   Loading mirror speeds from cached hostfile\n#   Loaded plugins: branch, fastestmirror, langpacks\n#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable\n#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable\n#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable\n#   Available Packages\n# Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)\n# sudo yum -y install docker-ce-[VERSION]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;安装指定版本\&#34;&gt;安装指定版本&lt;/h2&gt;\n&lt;h3 id=\&#34;查看docker版本\&#34;&gt;查看Docker版本：&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;yum list docker-ce --showduplicates&lt;/code&gt;&lt;br&gt;\n安装较旧版本（比如Docker 17.03.2) 时需要指定完整的rpm包的包名，并且加上--setopt=obsoletes=0 参数：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;# Install docker\n# on a new system with yum repo defined, forcing older version and ignoring obsoletes introduced by 17.06.0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;yum install -y --setopt=obsoletes=0 \\\n   docker-ce-17.03.2.ce-1.el7.centos.x86_64 \\\n   docker-ce-selinux-17.03.2.ce-1.el7.centos.noarch\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;或安装Docker较新版本（比如Docker 18.03.0)时加上rpm包名的版本号部分：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;sudo yum install docker-ce-18.03.0.ce\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;或安装Docker最新版本，无需加版本号：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;sudo yum install docker-ce\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;配置docker加速镜像源-此处为七牛\&#34;&gt;配置docker加速镜像源 （此处为七牛）&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;cat &amp;lt;&amp;lt;EOF&amp;gt; /etc/docker/daemon.json\n{\n    &amp;quot;registry-mirrors&amp;quot;:[&amp;quot;https://reg-mirror.qiniu.com&amp;quot;,&amp;quot;https://gcr-mirror.qiniu.com&amp;quot;,&amp;quot;https://quay-mirror.qiniu.com&amp;quot;]\n}\nEOF\nsystemctl restart docker\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;阿里云&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;sudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&#39;EOF&#39;\n{\n  &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://3me95jt4.mirror.aliyuncs.com&amp;quot;]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;安装kubelet-kubeadm-kubectl\&#34;&gt;安装kubelet kubeadm kubectl&lt;/h3&gt;\n&lt;h5 id=\&#34;k8s部署过程中的三大工具\&#34;&gt;k8s部署过程中的三大工具&lt;/h5&gt;\n&lt;p&gt;kubelet： k8s的服务程序&lt;/p&gt;\n&lt;p&gt;kubeadm:  k8s集群创建以及部署工具&lt;/p&gt;\n&lt;p&gt;kubectl:  k8s集群的控制交互程序&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Debian/Ubuntu&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;apt-get update &amp;amp;&amp;amp; apt-get install -y apt-transport-https\ncurl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - \ncat &amp;lt;&amp;lt;EOF &amp;gt;/etc/apt/sources.list.d/kubernetes.list\ndeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main\nEOF  \napt-get update\napt-get install -y kubelet kubeadm kubectl\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;Centos/RHEL/Fedora&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/\nenabled=1\ngpgcheck=1\nrepo_gpgcheck=1\ngpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\nEOF\nsetenforce 0\nyum install -y kubelet kubeadm kubectl\nsystemctl enable kubelet &amp;amp;&amp;amp; systemctl start kubelet\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;部署k8s集群\&#34;&gt;部署k8s集群&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;kubeadm init --kubernetes-version=v1.12.1 --pod-network-cidr=10.244.0.0/16\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\nkubectl apply -f https://docs.projectcalico.org/v3.0/getting-started/kubernetes/installation/hosted/kubeadm/1.7/calico.yaml\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注意网络插件的使用，整理这篇文章&lt;/p&gt;\n&lt;p&gt;http://www.cnblogs.com/RainingNight/p/using-kubeadm-to-create-a-cluster-1-12.html&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;kubernets-112-install&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Kubernets 1.12的安装&#34;,&#34;tags&#34;:[{&#34;index&#34;:-1,&#34;name&#34;:&#34;运维&#34;,&#34;slug&#34;:&#34;UeMKnE0pQ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://stardemo.github.io/tag/UeMKnE0pQ/&#34;}],&#34;date&#34;:&#34;2018-10-20 22:00:15&#34;,&#34;dateFormat&#34;:&#34;2018-10-20&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/kubernets-112-install/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:328000,&#34;words&#34;:1045,&#34;minutes&#34;:6},&#34;description&#34;:&#34;安装\n系统要求\n\nselinux关闭\n关闭swap\n各主机，节点之间ip和主机名加入/etc/hosts解析\n停用Firewalld\n\n安装Docker\n\n使用Docker官网自动化脚本通过阿里云镜像安装\n\ncurl -fsSL https...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85\&#34;&gt;安装&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B3%BB%E7%BB%9F%E8%A6%81%E6%B1%82\&#34;&gt;系统要求&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85docker\&#34;&gt;安装Docker&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC\&#34;&gt;安装指定版本&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E7%9C%8Bdocker%E7%89%88%E6%9C%AC\&#34;&gt;查看Docker版本：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AEdocker%E5%8A%A0%E9%80%9F%E9%95%9C%E5%83%8F%E6%BA%90-%E6%AD%A4%E5%A4%84%E4%B8%BA%E4%B8%83%E7%89%9B\&#34;&gt;配置docker加速镜像源 （此处为七牛）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85kubelet-kubeadm-kubectl\&#34;&gt;安装kubelet kubeadm kubectl&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#k8s%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B7%A5%E5%85%B7\&#34;&gt;k8s部署过程中的三大工具&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%83%A8%E7%BD%B2k8s%E9%9B%86%E7%BE%A4\&#34;&gt;部署k8s集群&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;测试MariaDB搭建集群&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;测试环境：Vmware （Centos 7 x3）&lt;/p&gt;\n&lt;h3 id=\&#34;1修改centos的软件源添加mariadb的软件源并安装mariadb-galera-server\&#34;&gt;1.修改Centos的软件源，添加MariaDB的软件源，并安装MariaDB-Galera-server&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;[root@www ~]# vi /etc/yum.repos.d/mariadb.repo\n# MariaDB 10.0 CentOS repository list\n# http://mariadb.org/mariadb/repositories/\n[mariadb]\nname = MariaDB\nbaseurl = http://yum.mariadb.org/10.0/centos7-amd64\ngpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB\ngpgcheck=1\nenabled=0\n[root@www ~\\]# yum --enablerepo=mariadb -y install MariaDB-Galera-server\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;2修改主控节点\&#34;&gt;2.修改主控节点&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;vim /etc/my.cnf.d/server.cnf\n[galera]\n# Mandatory settings\nwsrep_provider=/usr/lib64/galera/libgalera_smm.so\n# specify all nodes in cluster\nwsrep_cluster_address=&amp;quot;gcomm://10.0.0.31,10.0.0.51&amp;quot;\n# uncomment all\nbinlog_format=row\ndefault_storage_engine=InnoDB\ninnodb_autoinc_lock_mode=2\nbind-address=0.0.0.0\n# add follows\n# cluster name\nwsrep_cluster_name=&amp;quot;MariaDB_Cluster&amp;quot;\n# own IP address\nwsrep_node_address=&amp;quot;10.0.0.31&amp;quot;\n# replication provider\nwsrep_sst_method=rsync\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;启动数据库集群主控端&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt; [root@www ~]# /etc/rc.d/init.d/mysql bootstrap\nBootstrapping the cluster.. Starting MySQL.. SUCCESS!\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;初始化数据库(只需要在主控端进行）&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[root@www ~]# mysql_secure_installation\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;3配置数据节点依次配置每个节点\&#34;&gt;3.配置数据节点(依次配置每个节点）&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;vim /etc/my.cnf.d/server.cnf\n\\[galera\\]\n\\# Mandatory settings\nwsrep\\_provider=/usr/lib64/galera/libgalera\\_smm.so\n\\# specify all nodes in cluster\nwsrep\\_cluster\\_address=&amp;quot;gcomm://10.0.0.31,10.0.0.51&amp;quot;\n\\# uncomment all\nbinlog_format=row\ndefault\\_storage\\_engine=InnoDB\ninnodb\\_autoinc\\_lock_mode=2\nbind-address=0.0.0.0\n\\# add follows\n\\# cluster name\nwsrep\\_cluster\\_name=&amp;quot;MariaDB_Cluster&amp;quot;\n\\# own IP address\nwsrep\\_node\\_address=&amp;quot;10.0.0.51&amp;quot;\n\\# replication provider\nwsrep\\_sst\\_method=rsync\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;启动节点数据库服务&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;\\[root@node01 ~\\]# systemctl start mysql\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;4.集群搭建基本完成 下面进行测试&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;\\[root@node01 ~\\]# mysql -u root -p\nEnter password:\nWelcome to the MariaDB monitor.  Commands end with ; or \\\\g.\nYour MariaDB connection id is 6\nServer version: 10.0.20-MariaDB-wsrep MariaDB Server, wsrep_25.10.r4144\nCopyright (c) 2000, 2015, Oracle, MariaDB Corporation Ab and others.\nType &#39;help;&#39; or &#39;\\\\h&#39; for help. Type &#39;\\\\c&#39; to clear the current input statement.\nMariaDB \\[(none)\\]&amp;gt; show status like &#39;wsrep_%&#39;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;数据库回显：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;MariaDB \\[(none)\\]&amp;gt; show status like &#39;wsrep_%&#39;;\n+------------------------------+--------------------------------------+\n| Variable_name                | Value                                |\n+------------------------------+--------------------------------------+\n| wsrep\\_local\\_state_uuid       | 20329169-3414-11e5-9285-cab5ed757f81 |\n| wsrep\\_protocol\\_version       | 7                                    |\n| wsrep\\_last\\_committed         | 3                                    |\n| wsrep_replicated             | 0                                    |\n| wsrep\\_replicated\\_bytes       | 0                                    |\n| wsrep\\_repl\\_keys              | 0                                    |\n| wsrep\\_repl\\_keys_bytes        | 0                                    |\n| wsrep\\_repl\\_data_bytes        | 0                                    |\n| wsrep\\_repl\\_other_bytes       | 0                                    |\n| wsrep_received               | 3                                    |\n| wsrep\\_received\\_bytes         | 237                                  |\n| wsrep\\_local\\_commits          | 0                                    |\n| wsrep\\_local\\_cert_failures    | 0                                    |\n| wsrep\\_local\\_replays          | 0                                    |\n| wsrep\\_local\\_send_queue       | 0                                    |\n| wsrep\\_local\\_send\\_queue\\_max   | 2                                    |\n| wsrep\\_local\\_send\\_queue\\_min   | 0                                    |\n| wsrep\\_local\\_send\\_queue\\_avg   | 0.333333                             |\n| wsrep\\_local\\_recv_queue       | 0                                    |\n| wsrep\\_local\\_recv\\_queue\\_max   | 1                                    |\n| wsrep\\_local\\_recv\\_queue\\_min   | 0                                    |\n| wsrep\\_local\\_recv\\_queue\\_avg   | 0.000000                             |\n| wsrep\\_local\\_cached_downto    | 18446744073709551615                 |\n| wsrep\\_flow\\_control\\_paused\\_ns | 0                                    |\n| wsrep\\_flow\\_control_paused    | 0.000000                             |\n| wsrep\\_flow\\_control_sent      | 0                                    |\n| wsrep\\_flow\\_control_recv      | 0                                    |\n| wsrep\\_cert\\_deps_distance     | 0.000000                             |\n| wsrep\\_apply\\_oooe             | 0.000000                             |\n| wsrep\\_apply\\_oool             | 0.000000                             |\n| wsrep\\_apply\\_window           | 0.000000                             |\n| wsrep\\_commit\\_oooe            | 0.000000                             |\n| wsrep\\_commit\\_oool            | 0.000000                             |\n| wsrep\\_commit\\_window          | 0.000000                             |\n| wsrep\\_local\\_state            | 4                                    |\n| wsrep\\_local\\_state_comment    | Synced                               |\n| wsrep\\_cert\\_index_size        | 0                                    |\n| wsrep\\_causal\\_reads           | 0                                    |\n| wsrep\\_cert\\_interval          | 0.000000                             |\n| wsrep\\_incoming\\_addresses     | 10.0.0.31:3306,10.0.0.51:3306        |\n| wsrep\\_evs\\_delayed            |                                      |\n| wsrep\\_evs\\_evict_list         |                                      |\n| wsrep\\_evs\\_repl_latency       | 0/0/0/0/0                            |\n| wsrep\\_evs\\_state              | OPERATIONAL                          |\n| wsrep\\_gcomm\\_uuid             | 69d7b95d-3415-11e5-9666-7be9d4b6159d |\n| wsrep\\_cluster\\_conf_id        | 2                                    |\n| wsrep\\_cluster\\_size           | 2                                    |\n| wsrep\\_cluster\\_state_uuid     | 20329169-3414-11e5-9285-cab5ed757f81 |\n| wsrep\\_cluster\\_status         | Primary                              |\n| wsrep_connected              | ON                                   |\n| wsrep\\_local\\_bf_aborts        | 0                                    |\n| wsrep\\_local\\_index            | 1                                    |\n| wsrep\\_provider\\_name          | Galera                               |\n| wsrep\\_provider\\_vendor        | Codership Oy &amp;lt;info@codership.com&amp;gt;    |\n| wsrep\\_provider\\_version       | 25.3.9(r3387)                        |\n| wsrep_ready                  | ON                                   |\n| wsrep\\_thread\\_count           | 2                                    |\n+------------------------------+--------------------------------------+\n57 rows in set (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;*wsrep_local_state_comment | Synced *&lt;br&gt;\n表示数据库同步正常&lt;br&gt;\n可以对其中的一个节点数据库进行增删改 然后经由其他节点进行查看 同步正常&lt;/p&gt;\n&lt;h3 id=\&#34;写在最后\&#34;&gt;写在最后：&lt;/h3&gt;\n&lt;p&gt;本次Blog是经过测试&lt;/p&gt;\n&lt;h3 id=\&#34;参考资料\&#34;&gt;参考资料&lt;/h3&gt;\n&lt;p&gt;http://www.server-world.info/en/note?os=CentOS_7&amp;amp;p=mariadb&amp;amp;f=4 https://v2ex.com/t/202975 http://galeracluster.com/documentation-webpages/?id=mysql_galera_configuration&lt;/p&gt;\n&lt;h3 id=\&#34;ps\&#34;&gt;PS：&lt;/h3&gt;\n&lt;p&gt;v2ex教材待测试 同时尝试将集群做到Docker内作为应用打包方案 以及Debian的尝试部署&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysqlmariadbji-qun-ce-shi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;测试MariaDB搭建集群&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Mysql（mariadb）集群测试&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2016-03-01 14:01:16&#34;,&#34;dateFormat&#34;:&#34;2016-03-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/mysqlmariadbji-qun-ce-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:276000,&#34;words&#34;:824,&#34;minutes&#34;:5},&#34;description&#34;:&#34;测试MariaDB搭建集群\n\n测试环境：Vmware （Centos 7 x3）\n1.修改Centos的软件源，添加MariaDB的软件源，并安装MariaDB-Galera-server\n[root@www ~]# vi /etc/yum...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E4%BF%AE%E6%94%B9centos%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BA%90%E6%B7%BB%E5%8A%A0mariadb%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BA%90%E5%B9%B6%E5%AE%89%E8%A3%85mariadb-galera-server\&#34;&gt;1.修改Centos的软件源，添加MariaDB的软件源，并安装MariaDB-Galera-server&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%8E%A7%E8%8A%82%E7%82%B9\&#34;&gt;2.修改主控节点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E4%BE%9D%E6%AC%A1%E9%85%8D%E7%BD%AE%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9\&#34;&gt;3.配置数据节点(依次配置每个节点）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E\&#34;&gt;写在最后：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\&#34;&gt;参考资料&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ps\&#34;&gt;PS：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Python练习一波&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h3 id=\&#34;练习之前应该知道的\&#34;&gt;练习之前应该知道的&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;Linux命令行将以 \\$ 开始，比如 \\$ls, $python&lt;/li&gt;\n&lt;li&gt;Python命令行将以 &amp;gt;&amp;gt;&amp;gt; 开始，比如 &amp;gt;&amp;gt;&amp;gt;print &#39;Hello World!&#39;&lt;/li&gt;\n&lt;li&gt;注释会以 # 开始&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;一shell界面输入python可以进入python执行状态\&#34;&gt;一.Shell界面输入python可以进入python执行状态&lt;/h3&gt;\n&lt;h5 id=\&#34;\&#34;&gt;&lt;img src=\&#34;http://blog.istarboy.cc/wp-content/uploads/2016/02/mm-300x51.png\&#34; alt=\&#34;mm\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/h5&gt;\n&lt;p&gt;然后可以执行相关内容。&lt;/p&gt;\n&lt;h3 id=\&#34;二printhello-world\&#34;&gt;二.&amp;gt;&amp;gt;&amp;gt;print(&#39;Hello World!&#39;)&lt;/h3&gt;\n&lt;p&gt;print是一个常用函数，其功能就是输出括号中得字符串。 直接在python解释器状态运行会输出Hello World! 也可以写入py文件使用python *.py运行程序，在py文件头加上 #!/usr/bin/env python  可以直接进行chmod +x &lt;em&gt;.py ./&lt;/em&gt;.py执行测试脚本。&lt;/p&gt;\n&lt;h3 id=\&#34;三变量\&#34;&gt;三.变量&lt;/h3&gt;\n&lt;p&gt;Python的变量不需要声明，你可以直接输入：a = 10 那么内存里就有了一个变量a， 它的值是10，它的类型是integer (整数)。无需声明，数据类型是Python自动决定的。print type(a)可以显示a变量的数据类型。&lt;/p&gt;\n&lt;h3 id=\&#34;四数据类型\&#34;&gt;四.数据类型&lt;/h3&gt;\n&lt;p&gt;变量&lt;/p&gt;\n&lt;p&gt;数据类型&lt;/p&gt;\n&lt;p&gt;a=10&lt;/p&gt;\n&lt;p&gt;int 整数&lt;/p&gt;\n&lt;p&gt;a=1.3&lt;/p&gt;\n&lt;p&gt;float 浮点数&lt;/p&gt;\n&lt;p&gt;a=True&lt;/p&gt;\n&lt;p&gt;真值(True/False)&lt;/p&gt;\n&lt;p&gt;a=&#39;Hello!&#39;&lt;/p&gt;\n&lt;p&gt;字符串&lt;/p&gt;\n&lt;h3 id=\&#34;五序列\&#34;&gt;五.序列&lt;/h3&gt;\n&lt;p&gt;sequence(序列)是一组&lt;strong&gt;有顺序&lt;/strong&gt;的&lt;strong&gt;元素&lt;/strong&gt;的&lt;strong&gt;集合&lt;/strong&gt; (严格的说，是对象的集合，但鉴于我们还没有引入“对象”概念，暂时说元素) 序列可以包含一个或多个&lt;strong&gt;元素&lt;/strong&gt;，也可以没有任何元素。 我们之前所说的基本数据类型，都可以作为序列的元素。元素还可以是另一个序列，以及我们以后要介绍的其他对象。 序列有两种：tuple（&lt;strong&gt;定值表&lt;/strong&gt;； 也有翻译为&lt;strong&gt;元组&lt;/strong&gt;） 和 list (&lt;strong&gt;表&lt;/strong&gt;)&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;s1 = (2, 1.3, &#39;love&#39;, 5.6, 9, 12, False)         # s1是一个tuple\n&amp;gt;&amp;gt;&amp;gt;s2 = [True, 5, &#39;smile&#39;]                          # s2是一个list\n&amp;gt;&amp;gt;&amp;gt;print s1,type(s1)\n&amp;gt;&amp;gt;&amp;gt;print s2,type(s2)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;tuple和list的主要区别在于，一旦建立，&lt;strong&gt;tuple的各个元素不可再变更，而list的各个元素可以再变更&lt;/strong&gt;。 一个序列作为另一个序列的元素：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;s3 = [1,[3,4,5]]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;空序列：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;s4 = []\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;1-元素的引用\&#34;&gt;1、元素的引用&lt;/h3&gt;\n&lt;p&gt;序列元素的下标从0开始：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;print s1[0]\n&amp;gt;&amp;gt;&amp;gt;print s2[2]\n&amp;gt;&amp;gt;&amp;gt;print s3[1][2]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;由于list的元素可变更，你可以对list的某个元素赋值：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;s2[1] = 3.0\n&amp;gt;&amp;gt;&amp;gt;print s2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果你对tuple做这样的操作，会得到错误提示。 所以，可以看到，序列的引用通过s[int]实现，(int为下标)。&lt;/p&gt;\n&lt;h3 id=\&#34;2-其他引用方式\&#34;&gt;2、其他引用方式&lt;/h3&gt;\n&lt;p&gt;范围引用： 基本样式 &lt;strong&gt;[下限:上限:步长]&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;print s1[:5]             # 从开始到下标4 （下标5的元素 不包括在内）\n&amp;gt;&amp;gt;&amp;gt;print s1[2:]             # 从下标2到最后\n&amp;gt;&amp;gt;&amp;gt;print s1[0:5:2]          # 从下标0到下标4 (下标5不包括在内)，每隔2取一个元素 （下标为0，2，4的元素）\n&amp;gt;&amp;gt;&amp;gt;print s1[2:0:-1]         # 从下标2到下标1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;从上面可以看到，在范围引用的时候，如果写明上限，那么&lt;strong&gt;这个上限本身不包括在内&lt;/strong&gt;。 尾部元素引用：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;print s1[-1]             # 序列最后一个元素\n&amp;gt;&amp;gt;&amp;gt;print s1[-3]             # 序列倒数第三个元素\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;同样，如果s1[0:-1], 那么最后一个元素不会被引用 （再一次，&lt;strong&gt;不包括上限元素本身&lt;/strong&gt;）。&lt;/p&gt;\n&lt;h3 id=\&#34;3-字符串是元组\&#34;&gt;3、字符串是元组&lt;/h3&gt;\n&lt;p&gt;字符串是一种特殊的元素，因此可以执行元组的相关操作。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;str = &#39;abcdef&#39;\n&amp;gt;&amp;gt;&amp;gt;print str[2:4]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;六-运算\&#34;&gt;六、运算&lt;/h2&gt;\n&lt;h3 id=\&#34;1-数学运算\&#34;&gt;1、数学运算&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;print 1+9        # 加法\n&amp;gt;&amp;gt;&amp;gt;print 1.3-4      # 减法\n&amp;gt;&amp;gt;&amp;gt;print 3*5        # 乘法\n&amp;gt;&amp;gt;&amp;gt;print 4.5/1.5    # 除法\n&amp;gt;&amp;gt;&amp;gt;print 3**2       # 乘方     \n&amp;gt;&amp;gt;&amp;gt;print 10%3       # 求余数\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;2-判断\&#34;&gt;2、判断&lt;/h3&gt;\n&lt;p&gt;判断是真还是假，返回True/False:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;print 5==6               # =， 相等\n&amp;gt;&amp;gt;&amp;gt;print 8.0!=8.0           # !=, 不等\n&amp;gt;&amp;gt;&amp;gt;print 3&amp;lt;3, 3&amp;lt;=3          # &amp;lt;, 小于; &amp;lt;=, 小于等于\n&amp;gt;&amp;gt;&amp;gt;print 4&amp;gt;5, 4&amp;gt;=0          # &amp;gt;, 大于; &amp;gt;=, 大于等于\n&amp;gt;&amp;gt;&amp;gt;print 5 in [1,3,5]       # 5是list [1,3,5]的一个元素\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;还有is, is not等, 暂时不深入。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;3-逻辑运算\&#34;&gt;3、逻辑运算&lt;/h3&gt;\n&lt;p&gt;True/False之间的运算：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;print True and True, True and False      # and, “与”运算， 两者都为真才是真\n&amp;gt;&amp;gt;&amp;gt;print True or False                      # or, &amp;quot;或&amp;quot;运算， 其中之一为真即为真\n&amp;gt;&amp;gt;&amp;gt;print not True                           # not, “非”运算， 取反\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以和上一部分结合做一些练习，比如：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;print 5==6 or 3&amp;gt;=3\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;七-缩进和选择\&#34;&gt;七、缩进和选择&lt;/h2&gt;\n&lt;h3 id=\&#34;1-缩进\&#34;&gt;1、缩进&lt;/h3&gt;\n&lt;p&gt;Python最具特色的是用缩进来标明成块的代码。我下面以if选择结构来举例。if后面跟随条件，如果条件成立，则执行归属于 if 的一个代码块。 先看C语言的表达方式（注意，&lt;strong&gt;这是C，不是Python!&lt;/strong&gt;）&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;if ( i &amp;gt; 0 )\n{\n    x = 1;\n    y = 2;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果i &amp;gt; 0的话，我们将进行括号中所包括的两个赋值操作。括号中包含的就是块操作，它隶属于if。 在Python中，同样的目的，这段话是这样的：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;if i &amp;gt; 0:\n    x = 1\n    y = 2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在Python中， 去掉了i &amp;gt; 0周围的括号，去除了每个语句句尾的分号，表示块的花括号也消失了。 多出来了if ...之后的 &lt;strong&gt;:(冒号)&lt;/strong&gt;, 还有就是x = 1 和 y =2前面有&lt;strong&gt;四个空格的缩进&lt;/strong&gt;。通过缩进，Python识别出这两个语句是隶属于if。 Python这样设计的理由纯粹是为了程序好看。&lt;/p&gt;\n&lt;h3 id=\&#34;2-if语句\&#34;&gt;2、if语句&lt;/h3&gt;\n&lt;p&gt;写一个完整的程序，命名为ifDemo.py。这个程序用于实现if结构。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;i = 1\nx = 1\nif i &amp;gt; 0:\n    x = x+1\nprint x\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;用cd命令进入该文件所在目录，然后输入命令运行它：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$python ifDemo.py  # 运行\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;程序运行到 if 的时候，条件为True，因此执行&lt;strong&gt;x = x+1&lt;/strong&gt;。 &lt;strong&gt;print x&lt;/strong&gt;语句没有缩进，那么就是if之外。 如果将第一句改成i = -1，那么 if 遇到假值 (False), &lt;strong&gt;x = x+1&lt;/strong&gt;隶属于 if , 这一句跳过。&lt;strong&gt;print x&lt;/strong&gt;没有缩进，是 if 之外，不跳过，继续执行。 这种以&lt;strong&gt;四个空格&lt;/strong&gt;的缩进来表示&lt;strong&gt;隶属关系&lt;/strong&gt;的书写方式，以后还会看到。强制缩进增强了程序的&lt;strong&gt;可读性&lt;/strong&gt;。 复杂一些的 if 选择：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;i = 1\nif i &amp;gt; 0:\n    print &#39;positive i&#39;\n    i = i + 1\nelif i == 0:\n    print &#39;i is 0&#39;\n    i = i * 10\nelse:\n    print &#39;negative i&#39;\n    i = i - 1\nprint &#39;new i:&#39;,i\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这里有三个块，分别属于&lt;strong&gt;if，elif，else&lt;/strong&gt;引领。 Python检测条件，如果发现 if 的条件为假，那么跳过后面紧跟的块，检测下一个 elif 的条件； 如果还是假，那么执行else块。 通过上面的结构将程序分出三个分支。程序根据条件，只执行三个分支中的一个。 整个 if 可以放在另一个 if 语句中，也就是 if 结构的嵌套使用：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;i  = 5\nif i &amp;gt; 1:\n    print &#39;i bigger than 1&#39;\n    print &#39;good&#39;\n    if i &amp;gt; 2:\n        print &#39;i bigger than 2&#39;\n        print &#39;even better&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;if i &amp;gt; 2 后面的块相对于该 if 缩进了四个空格，以表明其隶属于该 if ，而不是外层的 if 。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;chu-xue-python-o_o&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;Python练习一波&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;初学Python o(∩_∩)o 、&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2016-02-08 13:59:36&#34;,&#34;dateFormat&#34;:&#34;2016-02-08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/chu-xue-python-o_o/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:449000,&#34;words&#34;:1798,&#34;minutes&#34;:8},&#34;description&#34;:&#34;Python练习一波\n\n练习之前应该知道的\n\nLinux命令行将以 \\$ 开始，比如 \\$ls, $python\nPython命令行将以 &amp;gt;&amp;gt;&amp;gt; 开始，比如 &amp;gt;&amp;gt;&amp;gt;print &#39;Hello World!&#39;...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%83%E4%B9%A0%E4%B9%8B%E5%89%8D%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84\&#34;&gt;练习之前应该知道的&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80shell%E7%95%8C%E9%9D%A2%E8%BE%93%E5%85%A5python%E5%8F%AF%E4%BB%A5%E8%BF%9B%E5%85%A5python%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81\&#34;&gt;一.Shell界面输入python可以进入python执行状态&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#\&#34;&gt;!mm&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8Cprinthello-world\&#34;&gt;二.&amp;gt;&amp;gt;&amp;gt;print(&#39;Hello World!&#39;)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%89%E5%8F%98%E9%87%8F\&#34;&gt;三.变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\&#34;&gt;四.数据类型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%94%E5%BA%8F%E5%88%97\&#34;&gt;五.序列&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%85%83%E7%B4%A0%E7%9A%84%E5%BC%95%E7%94%A8\&#34;&gt;1、元素的引用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%85%B6%E4%BB%96%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F\&#34;&gt;2、其他引用方式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%85%83%E7%BB%84\&#34;&gt;3、字符串是元组&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%AD-%E8%BF%90%E7%AE%97\&#34;&gt;六、运算&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97\&#34;&gt;1、数学运算&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%88%A4%E6%96%AD\&#34;&gt;2、判断&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97\&#34;&gt;3、逻辑运算&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%83-%E7%BC%A9%E8%BF%9B%E5%92%8C%E9%80%89%E6%8B%A9\&#34;&gt;七、缩进和选择&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E7%BC%A9%E8%BF%9B\&#34;&gt;1、缩进&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-if%E8%AF%AD%E5%8F%A5\&#34;&gt;2、if语句&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;记一次Ubuntu安装后的决心总结&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h4 id=\&#34;各种发行版的ubuntu-应该执行的优化操作-备忘记录\&#34;&gt;各种发行版的Ubuntu 应该执行的优化操作  备忘记录&lt;/h4&gt;\n&lt;p&gt;PS：为了避免官方源的不定期大姨妈 可以换软件源为CQU或者Ali-OSM&lt;/p&gt;\n&lt;h1 id=\&#34;1删除libreoffice\&#34;&gt;1.删除libreoffice&lt;/h1&gt;\n&lt;p&gt;libreoffice虽然是开源的，但是Java写出来的office执行效率实在不敢恭维，装完系统后果断删掉&lt;/p&gt;\n&lt;p&gt;sudo apt-get remove libreoffice-common&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;2删除amazon的链接\&#34;&gt;2.删除Amazon的链接&lt;/h1&gt;\n&lt;p&gt;sudo apt-get remove unity-webapps-common&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;3删掉基本不用的自带软件用的时候再装也来得及\&#34;&gt;3.删掉基本不用的自带软件（用的时候再装也来得及）&lt;/h1&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku  landscape-client-ui-install&lt;/p&gt;\n&lt;p&gt;sudo apt-get remove onboard deja-dup&lt;/p&gt;\n&lt;p&gt;这样系统就基本上干净了。&lt;/p&gt;\n&lt;h1 id=\&#34;4安装vim\&#34;&gt;4.安装Vim&lt;/h1&gt;\n&lt;p&gt;居然默认没有集成Vim神器，只能手动安装了。&lt;/p&gt;\n&lt;p&gt;sudo apt-get install vim&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;5设置时间使用utc\&#34;&gt;5.设置时间使用UTC&lt;/h1&gt;\n&lt;p&gt;sudo vim /etc/default/rcS&lt;/p&gt;\n&lt;p&gt;将UTC=no改为UTC=yes&lt;/p&gt;\n&lt;h1 id=\&#34;6安装chrome\&#34;&gt;6.安装Chrome&lt;/h1&gt;\n&lt;p&gt;到 https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 下载最新的安装文件。 然后&lt;/p&gt;\n&lt;p&gt;sudo apt-get install libappindicator1 libindicator7&lt;br&gt;\nsudo dpkg -i google-chrome-stable_current_amd64.deb&lt;br&gt;\nsudo apt-get -f install&lt;/p&gt;\n&lt;p&gt;这样以后就可以apt安装和更新chrome浏览器了。&lt;/p&gt;\n&lt;h1 id=\&#34;7安装搜狗输入法\&#34;&gt;7.安装搜狗输入法&lt;/h1&gt;\n&lt;p&gt;&lt;strong&gt;//有毒 不要安装&lt;/strong&gt; 在mint的输入法控制台启用fctix 然后安装下边插件 sudo apt-get install fcitx-googlepinyin 可以使用谷歌拼音 vim /etc/apt/sources.list.d/ubuntukylin.list文件，加入ubuntu kylin的apt源&lt;/p&gt;\n&lt;p&gt;deb http://archive.ubuntukylin.com:10006/ubuntukylin trusty main&lt;/p&gt;\n&lt;p&gt;然后&lt;/p&gt;\n&lt;p&gt;//sudo apt-get update&lt;br&gt;\n//sudo apt-get install sogoupinyin&lt;/p&gt;\n&lt;p&gt;这样就可以apt安装和更新搜狗输入法了。&lt;/p&gt;\n&lt;h1 id=\&#34;8安装wps-office\&#34;&gt;8.安装WPS Office&lt;/h1&gt;\n&lt;p&gt;目前MS一直不出Linux版的Office，只能凑合着用WPS了&lt;/p&gt;\n&lt;p&gt;sudo apt-get install wps-office&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;9安装oracle-java\&#34;&gt;9.安装Oracle Java&lt;/h1&gt;\n&lt;p&gt;sudo add-apt-repository ppa:webupd8team/java&lt;br&gt;\nsudo apt-get update&lt;br&gt;\nsudo apt-get install oracle-java8-installer&lt;/p&gt;\n&lt;p&gt;由于系统自带的是OpenJDK，卸载OpenJDK之后会带有残留，导致运行&lt;/p&gt;\n&lt;p&gt;java -version&lt;/p&gt;\n&lt;p&gt;时第一行不是java的版本号，会是Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar这个提示，导致很多检测java版本号的脚本会运行出错，因此需要手动清除残留。&lt;/p&gt;\n&lt;p&gt;sudo rm /usr/share/upstart/sessions/jayatana.conf&lt;/p&gt;\n&lt;p&gt;删除/usr/share/upstart/sessions/jayatana.conf文件，重启之后再运行java -version就不会再有Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar提示了。&lt;/p&gt;\n&lt;h1 id=\&#34;10安装sublime-text-3\&#34;&gt;10.安装Sublime Text 3&lt;/h1&gt;\n&lt;p&gt;sudo add-apt-repository ppa:webupd8team/sublime-text-3&lt;br&gt;\nsudo apt-get update&lt;br&gt;\nsudo apt-get install sublime-text&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;11安装git和vpnc\&#34;&gt;11.安装git和vpnc&lt;/h1&gt;\n&lt;p&gt;git和vpn大家都懂的，程序员的好工具。&lt;/p&gt;\n&lt;p&gt;sudo apt-get install vpnc git&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;12安装axel\&#34;&gt;12.安装axel&lt;/h1&gt;\n&lt;p&gt;axel是Linux命令行界面的多线程下载工具，比wget的好处就是可以指定多个线程同时在命令行终端里下载文件。&lt;/p&gt;\n&lt;p&gt;sudo apt-get install axel&lt;/p&gt;\n&lt;p&gt;安装之后，就可以代替wget用多线程下载了。&lt;/p&gt;\n&lt;h1 id=\&#34;13安装openssh-server\&#34;&gt;13.安装openssh-server&lt;/h1&gt;\n&lt;p&gt;sudo apt-get install openssh-server&lt;/p&gt;\n&lt;p&gt;安装之后，就可以在Win下用ssh工具远程登陆了，当然也多了一个安全隐患，如果不想远程登陆本机的话，可以不装openssh-server。&lt;/p&gt;\n&lt;h1 id=\&#34;14安装cmake和qt-creator\&#34;&gt;14.安装CMake和Qt Creator&lt;/h1&gt;\n&lt;p&gt;CMake和Qt Creator是Linux下开发C++程序的神器，Ubuntu 15.04已经集成了最新版的Qt Creator （3.1.1）。&lt;/p&gt;\n&lt;p&gt;sudo apt-get install cmake qtcreator&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;15安装exfat文件系统驱动\&#34;&gt;15.安装ExFat文件系统驱动&lt;/h1&gt;\n&lt;p&gt;Ubuntu默认不支持exFat文件系统的挂载，需要手动安装exfat的支持&lt;/p&gt;\n&lt;p&gt;sudo apt-get install exfat-fuse&lt;/p&gt;\n&lt;p&gt;装上exfat-fuse之后就可以挂载exfat分区的磁盘了。&lt;/p&gt;\n&lt;h1 id=\&#34;16安装lnav\&#34;&gt;16.安装lnav&lt;/h1&gt;\n&lt;p&gt;lnav工具是在终端界面看日志的神器&lt;/p&gt;\n&lt;p&gt;sudo apt-get install lnav&lt;/p&gt;\n&lt;p&gt;装上之后在终端里就可以用lnav彩色显示日志了。&lt;/p&gt;\n&lt;h1 id=\&#34;17安装unrar\&#34;&gt;17.安装unrar&lt;/h1&gt;\n&lt;p&gt;系统默认不带解压缩rar文件的功能，手动安装unrar程序&lt;/p&gt;\n&lt;p&gt;sudo apt-get install unrar&lt;/p&gt;\n&lt;p&gt;装上之后就可以用命令解压缩rar文件了。 使用如下命令解压缩文件到当前目录。&lt;/p&gt;\n&lt;p&gt;unrar x test.rar&lt;/p&gt;\n&lt;h1 id=\&#34;18php环境配置\&#34;&gt;18.PHP环境配置&lt;/h1&gt;\n&lt;p&gt;sudo apt-get intstall php5 php5-dev php5-xdebug php5-cli php-pear  libpcre3-dev libpcre3 curl gcc g++ -y sudo pecl install swoole&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;ubuntu-an-zhuang-hou-de-you-hua-blabla&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;记一次Ubuntu安装后的决心总结&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Ubuntu安装后的优化blabla···&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2016-02-04 13:58:27&#34;,&#34;dateFormat&#34;:&#34;2016-02-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/ubuntu-an-zhuang-hou-de-you-hua-blabla/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:257000,&#34;words&#34;:979,&#34;minutes&#34;:5},&#34;description&#34;:&#34;记一次Ubuntu安装后的决心总结\n\n各种发行版的Ubuntu 应该执行的优化操作  备忘记录\nPS：为了避免官方源的不定期大姨妈 可以换软件源为CQU或者Ali-OSM\n1.删除libreoffice\nlibreoffice虽然是开源的，...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%84%E7%A7%8D%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84ubuntu-%E5%BA%94%E8%AF%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BC%98%E5%8C%96%E6%93%8D%E4%BD%9C-%E5%A4%87%E5%BF%98%E8%AE%B0%E5%BD%95\&#34;&gt;各种发行版的Ubuntu 应该执行的优化操作  备忘记录&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E5%88%A0%E9%99%A4libreoffice\&#34;&gt;1.删除libreoffice&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2%E5%88%A0%E9%99%A4amazon%E7%9A%84%E9%93%BE%E6%8E%A5\&#34;&gt;2.删除Amazon的链接&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3%E5%88%A0%E6%8E%89%E5%9F%BA%E6%9C%AC%E4%B8%8D%E7%94%A8%E7%9A%84%E8%87%AA%E5%B8%A6%E8%BD%AF%E4%BB%B6%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%86%8D%E8%A3%85%E4%B9%9F%E6%9D%A5%E5%BE%97%E5%8F%8A\&#34;&gt;3.删掉基本不用的自带软件（用的时候再装也来得及）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4%E5%AE%89%E8%A3%85vim\&#34;&gt;4.安装Vim&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5%E8%AE%BE%E7%BD%AE%E6%97%B6%E9%97%B4%E4%BD%BF%E7%94%A8utc\&#34;&gt;5.设置时间使用UTC&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6%E5%AE%89%E8%A3%85chrome\&#34;&gt;6.安装Chrome&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95\&#34;&gt;7.安装搜狗输入法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#8%E5%AE%89%E8%A3%85wps-office\&#34;&gt;8.安装WPS Office&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#9%E5%AE%89%E8%A3%85oracle-java\&#34;&gt;9.安装Oracle Java&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#10%E5%AE%89%E8%A3%85sublime-text-3\&#34;&gt;10.安装Sublime Text 3&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#11%E5%AE%89%E8%A3%85git%E5%92%8Cvpnc\&#34;&gt;11.安装git和vpnc&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#12%E5%AE%89%E8%A3%85axel\&#34;&gt;12.安装axel&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#13%E5%AE%89%E8%A3%85openssh-server\&#34;&gt;13.安装openssh-server&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#14%E5%AE%89%E8%A3%85cmake%E5%92%8Cqt-creator\&#34;&gt;14.安装CMake和Qt Creator&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#15%E5%AE%89%E8%A3%85exfat%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%A9%B1%E5%8A%A8\&#34;&gt;15.安装ExFat文件系统驱动&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#16%E5%AE%89%E8%A3%85lnav\&#34;&gt;16.安装lnav&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#17%E5%AE%89%E8%A3%85unrar\&#34;&gt;17.安装unrar&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#18php%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE\&#34;&gt;18.PHP环境配置&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;屏幕的参数的一篇爬文 ，无意义&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;今天闲来无事又开始乱看51nb，然后看了某DC2屏幕与普通IPS的对比，感觉已经中毒。&lt;/p&gt;\n&lt;p&gt;开始详细了解 √&lt;/p&gt;\n&lt;p&gt;DC1是8BIT的屏幕，DC2是10BIT的屏，与普通屏幕就是色域上的区别。&lt;/p&gt;\n&lt;p&gt;以下色域的资料：&lt;/p&gt;\n&lt;p&gt;色域（Color Space)，又被称为色彩空间，它代表了一个色彩影像所能表现RGB色彩空间的色彩具体情况。&lt;/p&gt;\n&lt;p&gt;我们经常用到的色彩空间主要有RGB、CMYK、Lab等，而RGB色彩空间又有AdobeRGB、AppleRGB、sRGB等几种，这些RGB色彩空间大多与显示设备、输入设备（数码相机、扫描仪）相关联。&lt;/p&gt;\n&lt;p&gt;Adobe RGB与sRGB则是我们最为常见的，也是目前数码相机中重要的设置。 Adobe RGB是由Adobe公司推出的色域标准，sRGB是由惠普与微软公司于1977年共同开发的，其中“S”可解释为“标准”（Standard)。&lt;/p&gt;\n&lt;p&gt;Adobe RGB较之sRGB有更宽广的色彩空间，它包含了sRGB所没有的CMYK色域，层次较丰富，但色彩饱和较低。如果希望在最终的摄影作品中精细调整色彩饱和度，可选择Adobe RGB模式。&lt;/p&gt;\n&lt;p&gt;若将由Adobe RGB模式拍摄的图像更改为sRGB模式的，影像的色彩会有所损失。但由于其色域较广，所以影像的色彩还会真实地反应出来。若将sRGB模式拍摄的影像转换为Adobe RGB模式的，由于sRGB本身色域较窄，实际上并没有什么变化，而我们所见到的色彩改变，其实只是输出装置的模拟色彩。 因为sRGB拥有较小的色域空间，所以不建议专业的印前用户使用，它主要应用在网页浏览等。&lt;/p&gt;\n&lt;p&gt;目前，微软与惠普发表了sRGB64，这样在色彩调整及转换时会保存信息以备以后使用。而Adobe RGB具备非常大的色域空间，对以后在输出及分色有极大的优势和便利性，应用更为广泛。 普通消费级数码相机中多以sRGB做为相机内的色域标准，从而使所拍图像在不需要加工的情况下能在显示器或打印机等输出装置中展示其本来面目。&lt;/p&gt;\n&lt;p&gt;而高档或单反数码相机则提供了Adobe RGB和sRGB两种色域选择。如佳能EOS 20D、柯尼卡美能达DiMAGEA2/A1等，而尼康D70则设有Ia（sRGB）、II（Adobe RGB）、IIIa（sRGB）三种选择，其中Ia（sRGB）适合拍摄人像使用，可表现较自然的肤色；而IIIa（sRGB）适合拍摄风景及花卉，调校更真实的艳丽色彩。 作为类比，你可以试想三个颜色（红绿蓝）被投射到一堵白色的墙上，当这些同样密度的光叠加在一起就产生了白色，而当你只投射绿色和红色时，你会看到墙变成了黄色。把这三种颜色的光按不同的方法叠加会生成各种不同颜色的光，再举一个例子，当你在墙上投射红色和绿色时，墙就会变成桔黄色。 一句话，我们所看到的各种颜色的光就是由这三种颜色叠合而成的，所有可能的颜色的集合就是我们所说的“色域”。&lt;/p&gt;\n&lt;p&gt;不同的人识别“RGB色彩空间”里的颜色和光线的能力是很相似的，但并不完全一致。“RGB色彩空间”中也有各种模式，我们最常见的有sRGB和Adobe RGB，这两者中sRGB应用的更广一点，它在过去的一个世纪中被广泛的使用在数码相机，高清相机，高清视频和电脑显示中，换句话说就是它就是电子产品采用或支持的色彩模式。它在上个世纪90年代由Hewlett Packard同微软公司一起制定这种模式的相关规则，其中“s”就代表了“标准”，它至今还是我们现在通用的标准。&lt;/p&gt;\n&lt;p&gt;sRGB最主要的缺点就是色域很有限（它所能包容的颜色虽然已然我们所能识别的范围之外，但是在有些时候，它还是太小了-译者），在这个时候Adobe就推出了自己的RGB模式标准–Adobe RGB，它在色域上超过sRGB很多，相当于在给sRGB套上了一个外套，Adobe甚至后来又推出了Adobe Wide gamut RGB，它包含的颜色更多，然而我们平时并不需要这么多颜色，通常我们只会在平面设计和中高档数码相机里才用到它们。&lt;/p&gt;\n&lt;p&gt;下面，我再来说一下NTSC是什么。 人眼所能看到的光线称之为可见光，在光谱图上可以知道可见光谱是波长从380nm到780nm之间的光线，而通过R红、G绿、B蓝这三种颜色的混合，可以得到近似于全部可见光谱范围内的光线，目前所使用绝大多数彩色显示器，不管是LEDT、CRT、LCD、PDP、DLP还是其他什么，都是基于三原色成像。而NTSC制式，是1952年12月由美国国家电视标准委员会（National Television System Committee，缩写为NTSC）制定的彩色电视广播标准。一般电视色域是72%，广色域的92%即达广色域标准，因为他牌的计算方式为92%除以72%等于127%，因而号称广色域达130%，其实就是92%。 彩色影像是由蓝、绿、红三原色依不同比例及加上亮度混合而成，10位之影像是由蓝绿红各1024阶层组合而成，可产生1024×1024×1024＝10.7亿之颜色组合，比起8位256×256×256＝16.7百万色，足足多出了64倍之颜色组合。&lt;/p&gt;\n&lt;p&gt;10位之色彩加上灰阶，在影像分辨率比8位之分辨率至少好上4倍。 今日的显示器的色域归类为三种类型。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ol&gt;\n&lt;li&gt;AdobeRGB 色域&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;sRGB 色域&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;和 sRGB 色域相同或更高但低于AdobeRGB 色域 红色的三角锥为AdobeRGB的色域空间，蓝色三角锥为sRGB的色域空间。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;第三个类型的色域为 NTSC 的标准色域,它被使用在影音、TV和其他设备。绿色的三角锥涵盖了92% NTSC 的色域。在图像里显示的 JMPA 色域为典型的CMYK 色域。颜色色域必须跟使用者的目的和环境相互一致。尤其， 为了完整呈现AdobeRGB 和 CMYK 色域的再现性，显示器需要对应 AdobeRGB 的色域 。即使显示器只涵盖了NTSC 92%的色域无法正确地显示出AdobeRGB的鲜绿色和CMYK特别的黄色。&lt;/p&gt;\n&lt;p&gt;所以所谓广色域技术是最近显示器的热点，广色域顾名思意就是比一般的显示器能显示更多的颜色。现在一般提升色域的手段是采用LED背光模组，相比现在广泛采用的使用CCFL光源的背光模组，LED光源的白光更纯，所以透过CF彩色滤光片能表现更丰富的颜色。&lt;/p&gt;\n&lt;p&gt;一般使用LED背光的显示器的色域能超过100%NTSC色域。一般使用CCFL背光的显示器只能达到一般sRGB色域，色域越高，显示器所能显示的图片就越接近自然。&lt;/p&gt;\n&lt;p&gt;总结：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;1.RGB是RED（红），Green（绿），Blue（蓝）这三 种基色的首字母缩写。&lt;/li&gt;\n&lt;li&gt;2.“RGB色彩空间”是泛指在硬件和软件里用到的“所有颜色”&lt;/li&gt;\n&lt;li&gt;3.sRGB 是RGB是一种的一种特定类型。&lt;/li&gt;\n&lt;li&gt;4.sRGB很流行，但它的色域很有限&lt;/li&gt;\n&lt;li&gt;5.色域越高越好&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;PS 以上资料，来源于网络，本人只是摘录总结了一下，如有不对，欢迎指正，请轻拍砖&lt;/strong&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;guan-yu-ping-mu-na-xie-shi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;屏幕的参数的一篇爬文 ，无意义&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;关于屏幕那些事···&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2016-02-03 21:20:06&#34;,&#34;dateFormat&#34;:&#34;2016-02-03&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/guan-yu-ping-mu-na-xie-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:423000,&#34;words&#34;:1988,&#34;minutes&#34;:8},&#34;description&#34;:&#34;屏幕的参数的一篇爬文 ，无意义\n\n今天闲来无事又开始乱看51nb，然后看了某DC2屏幕与普通IPS的对比，感觉已经中毒。\n开始详细了解 √\nDC1是8BIT的屏幕，DC2是10BIT的屏，与普通屏幕就是色域上的区别。\n以下色域的资料：\n色域...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;开发者三条要诀&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;使用开发者系统的时候时刻牢记：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;a.命令行优于图形界面&lt;/li&gt;\n&lt;li&gt;b.键盘优于鼠标&lt;/li&gt;\n&lt;li&gt;c.搜索优于导航&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;kai-fa-zhe-ji-ben-su-yang&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;开发者三条要诀&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;开发者基本素养√&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2016-01-30 19:19:01&#34;,&#34;dateFormat&#34;:&#34;2016-01-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/kai-fa-zhe-ji-ben-su-yang/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:9000,&#34;words&#34;:45,&#34;minutes&#34;:1},&#34;description&#34;:&#34;开发者三条要诀\n\n使用开发者系统的时候时刻牢记：\n\na.命令行优于图形界面\nb.键盘优于鼠标\nc.搜索优于导航\n\n&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;常用命令的备忘记录&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;h4 id=\&#34;在进行docker学习过程中通过查询发现如下命令使用频率较高故作此备忘\&#34;&gt;在进行docker学习过程中通过查询发现如下命令使用频率较高，故作此备忘&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;查看容器的root用户密码&lt;/p&gt;\n&lt;p&gt;docker logs &amp;lt;容器名orID&amp;gt; 2&amp;gt;&amp;amp;1 | grep &#39;^User: &#39; | tail -n1&lt;/p&gt;\n&lt;p&gt;因为docker容器启动时的root用户的密码是随机分配的。所以，通过这种方式就可以得到redmine容器的root用户的密码了。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查看容器日志&lt;/p&gt;\n&lt;p&gt;docker logs -f &amp;lt;容器名orID&amp;gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查看正在运行的容器&lt;/p&gt;\n&lt;p&gt;docker ps&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;docker ps -a&lt;/code&gt;为查看所有的容器，包括已经停止的。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;删除所有容器&lt;/p&gt;\n&lt;p&gt;docker rm $(docker ps -a -q)&lt;/p&gt;\n&lt;p&gt;删除单个容器&lt;code&gt;docker rm &amp;lt;容器名orID&amp;gt;&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;停止、启动、杀死一个容器&lt;/p&gt;\n&lt;p&gt;docker stop &amp;lt;容器名orID&amp;gt;&lt;br&gt;\ndocker start &amp;lt;容器名orID&amp;gt;&lt;br&gt;\ndocker kill &amp;lt;容器名orID&amp;gt;&lt;/p&gt;\n&lt;p&gt;可以搭配$(docker ps -a -q) 对所有容器操作&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查看所有镜像&lt;/p&gt;\n&lt;p&gt;docker images&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;删除所有镜像&lt;/p&gt;\n&lt;p&gt;docker rmi $(docker images | grep none | awk &#39;{print $3}&#39; | sort -r)&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;运行一个新容器，同时为它命名、端口映射、文件夹映射。以redmine镜像为例&lt;/p&gt;\n&lt;p&gt;docker run --name redmine -p 9003:80 -p 9023:22 -d -v /var/redmine/files:/redmine/files -v     /var/redmine/mysql:/var/lib/mysql sameersbn/redmine&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;一个容器连接到另一个容器&lt;/p&gt;\n&lt;p&gt;docker run -i -t --name sonar -d -link mmysql:db   tpires/sonar-server&lt;/p&gt;\n&lt;p&gt;sonar容器连接到mmysql容器，并将mmysql容器重命名为db。这样，sonar容器就可以使用db的相关的环境变量了。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;拉取镜像&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;docker pull &amp;lt;镜像名:tag&amp;gt;\n\n如`docker pull sameersbn/redmine:latest`\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;11\&#34;&gt;\n&lt;li&gt;当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。机器a&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;docker save busybox-1 &amp;gt; /home/save.tar\n\n使用scp将save.tar拷到机器b上，然后：\n\ndocker load &amp;lt; /home/save.tar\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;12\&#34;&gt;\n&lt;li&gt;构建自己的镜像&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;docker build -t &amp;lt;镜像名&amp;gt; &amp;lt;Dockerfile路径&amp;gt;\n\n如Dockerfile在当前路径：`docker build -t xx/gitlab .`\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;13\&#34;&gt;\n&lt;li&gt;\n&lt;p&gt;将容器固化为镜像&lt;/p&gt;\n&lt;p&gt;docker commit [容器ID]  tag/name&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;docker-de-chang-yong-ming-ling&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;常用命令的备忘记录&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Docker的常用命令&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2016-01-22 20:17:39&#34;,&#34;dateFormat&#34;:&#34;2016-01-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/docker-de-chang-yong-ming-ling/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:127000,&#34;words&#34;:495,&#34;minutes&#34;:3},&#34;description&#34;:&#34;常用命令的备忘记录\n\n在进行docker学习过程中通过查询发现如下命令使用频率较高，故作此备忘\n\n\n查看容器的root用户密码\ndocker logs &amp;lt;容器名orID&amp;gt; 2&amp;gt;&amp;amp;1 | grep &#39;^User: &#39;...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%A8%E8%BF%9B%E8%A1%8Cdocker%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%80%9A%E8%BF%87%E6%9F%A5%E8%AF%A2%E5%8F%91%E7%8E%B0%E5%A6%82%E4%B8%8B%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E9%A2%91%E7%8E%87%E8%BE%83%E9%AB%98%E6%95%85%E4%BD%9C%E6%AD%A4%E5%A4%87%E5%BF%98\&#34;&gt;在进行docker学习过程中通过查询发现如下命令使用频率较高，故作此备忘&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;使用Docker 构建PHP运行开发环境 （碳素云实习期间实践）&lt;/p&gt;\n&lt;!--more--&gt;\n&lt;p&gt;本文作者是Geoffrey，他是一个PHP的Web开发者，喜欢DevOps和Docker。本文主要介绍了如何使用Docker构建PHP的开发环境，文中作者也探讨了构建基于Docker的开发环境应该使用单容器还是多容器，各有什么利弊。推荐PHP开发者阅读。   本文由php100.com dockerone翻译，本博属应用转载。&lt;br&gt;\n现在很多开发者都使用Vagrant来管理他们的虚拟机开发环境，Vagrant确实很酷， 不过也有不少缺点（最主要的是它占用太多的资源）。在容器技术、Docker和更多类Docker技术出现后，解决这个问题就变得简单了。&lt;/p&gt;\n&lt;h2 id=\&#34;免责声明\&#34;&gt;免责声明&lt;/h2&gt;\n&lt;p&gt;由于&lt;code&gt;boot2docker&lt;/code&gt;的工作方式，本文所述的方法在你的环境中可能无法正常运行。如果需要在非Linux环境下共享文件夹到Docker容器，还需要注意更多额外的细节。后续我会写篇文章专门来介绍实际遇到的问题。&lt;/p&gt;\n&lt;h2 id=\&#34;怎样才算是好的开发环境\&#34;&gt;怎样才算是好的开发环境&lt;/h2&gt;\n&lt;p&gt;首先，我们得知道什么才是好的开发环境， 对于我而言，一个好的开发环境需要具备以下几个特点：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;可随意使用。我必须可以随意删除和创建新的环境。&lt;/li&gt;\n&lt;li&gt;快速启动。我想要用它工作时候，它立马就能用。&lt;/li&gt;\n&lt;li&gt;易于更新。在我们行业中，事物发展变化非常快，必须能让我很容易将我的开发环境更新到新的软件版本。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;而Docker都支持以上这些特点，甚至更多。你几乎可以即时销毁和重建容器，而更新环境只需要重建你当前使用的镜像即可。&lt;/p&gt;\n&lt;h2 id=\&#34;什么是php开发环境\&#34;&gt;什么是PHP开发环境&lt;/h2&gt;\n&lt;p&gt;目前Web应用错综复杂，PHP开发环境需要很多的东西，为了保证环境的简单性，需要做各种各样的限制。 我们这次使用Nginx、PHP5-FPM、MySQL来运行Synmfony项目。由于在容器中运行命令行会更复杂，所以这方面的内容我会放到下一篇博客中再说。&lt;/p&gt;\n&lt;h2 id=\&#34;pet-与-cattle\&#34;&gt;Pet 与 Cattle&lt;/h2&gt;\n&lt;p&gt;另一个我们要讨论的重点是：我们要把开发环境部署在多容器还是单容器中。 两种方式各有优点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;单容器易于分发、维护。因为它们是独立的，所有的东西都运行在同一个容器中，这点就像是一个虚拟机。但这也意味着，当你要升级其中的某样东西（比如PHP新版本）的时候， 需要重新构建整个容器。&lt;/li&gt;\n&lt;li&gt;多容器可以在添加组件时提供更好的模块化。因为每个容器包含了堆栈的一部分：Web、PHP、MySQL等，这样可以单独扩展每个服务或者添加服务，并且不需要重建所有的东西。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;因为我比较懒，加上我需要在我的笔记本上放点别的内容，所以，这里我们只介绍单个容器的方法。&lt;/p&gt;\n&lt;h2 id=\&#34;初始化工程\&#34;&gt;初始化工程&lt;/h2&gt;\n&lt;p&gt;首先要做的是初始化一个新的Symfony工程. 推荐的方法是用&lt;code&gt;composer&lt;/code&gt;的&lt;code&gt;create-project&lt;/code&gt;命令。本来可以在工作站上安装composer，但是那样太简单了。这次我们通过Docker来使用它。 我之前发过一篇关于Docker命令的文章：&lt;a href=\&#34;http://geoffrey.io/making-docker-commands.html\&#34;&gt;&lt;code&gt;make docker commands&lt;/code&gt;&lt;/a&gt;（好吧，我说谎了，我本来把它写在这篇文章中了，然后觉得把它独立出来会比较好）。 不管怎么样，你可以读一下。接下来如果还没有&lt;code&gt;composer&lt;/code&gt;命令的话，你可以创建一个属于自己的&lt;code&gt;composer&lt;/code&gt; 别名。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;$ alias composer=&amp;quot;docker run -i -t -v \\\\$PWD:/srv ubermuda/composer&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;现在你可以初始化Symfony工程了：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;$ composer create-project symfony/framwork-standard-edition SomeProject\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;帅呆了！下面来点实在的工作。(省略了博主自娱自乐的一堆balabla....原文:Awesome. Give yourself a high-five， get a cup of coffee or whatever is your liquid drug of choice， and get ready for the real work.)&lt;/p&gt;\n&lt;h2 id=\&#34;容器\&#34;&gt;容器&lt;/h2&gt;\n&lt;p&gt;构建一个运行标准Symfony项目且自给自足的容器相当容易，只需要安装好常用的Nginx、PHP5-FPM和MySQL-Server即可，然后把预先准备好的Nginx的虚拟主机配置文件扔进去，再复制一些配置文件进去就完事了。 本容器的源代码在GitHub上的 &lt;a href=\&#34;https://github.com/ubermuda/docker-symfony\&#34;&gt;ubermuda/docker-symfony&lt;/a&gt;仓库中可以找到。 Dockerfile 是Docker构建镜像要用到的配置文件，我们来看一下:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;FROM debian:wheezy\nENV DEBIAN_FRONTEND noninteractive\nRUN apt-get update -y\nRUN apt-get install -y nginx php5-fpm php5-mysqlnd php5-cli mysql-server supervisor\nRUN sed -e &#39;s/;daemonize = yes/daemonize = no/&#39; -i /etc/php5/fpm/php-fpm.conf\nRUN sed -e &#39;s/;listen\\\\.owner/listen.owner/&#39; -i /etc/php5/fpm/pool.d/www.conf\nRUN sed -e &#39;s/;listen\\\\.group/listen.group/&#39; -i /etc/php5/fpm/pool.d/www.conf\nRUN echo &amp;quot;\\\\ndaemon off;&amp;quot; &amp;gt;&amp;gt; /etc/nginx/nginx.conf\nADD vhost.conf /etc/nginx/sites-available/default\nADD supervisor.conf /etc/supervisor/conf.d/supervisor.conf\nADD init.sh /init.sh\nEXPOSE 80 3306\nVOLUME \\[&amp;quot;/srv&amp;quot;\\]\nWORKDIR /srv\nCMD \\[&amp;quot;/usr/bin/supervisord&amp;quot;\\]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们通过扩展 &lt;code&gt;debian:wheezy&lt;/code&gt; 这个基础镜像开始，然后通过一系列的&lt;code&gt;sed&lt;/code&gt;命令来配置Nginx和PHP5-FPM。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;RUN sed -e &#39;s/;daemonize = yes/daemonize = no/&#39; -i /etc/php5/fpm/php-fpm.conf\nRUN sed -e &#39;s/;listen\\\\.owner/listen.owner/&#39; -i /etc/php5/fpm/pool.d/www.conf\nRUN sed -e &#39;s/;listen\\\\.group/listen.group/&#39; -i /etc/php5/fpm/pool.d/www.conf\nRUN echo &amp;quot;\\\\ndaemon off;&amp;quot; &amp;gt;&amp;gt; /etc/nginx/nginx.conf\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这里我们要做两件事。 首先配置PHP5-FPM和Nginx让他们在前台运行以便supervisord可以追踪到他们。 然后，配置PHP5-FPM以指定的用户运行Web-Server，并处理好文件权限。 接下来需要安装一组配置文件，首先是Nginx的虚拟主机配置文件&lt;code&gt;vhost.conf&lt;/code&gt;:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-conf\&#34;&gt;server {\n    listen 80;\n    server\\_name \\_;\n    access_log /var/log/nginx/access.log;\n    error_log /var/log/nginx/error.log;\n    root /srv/web;\n    index app_dev.php;\n    location / {\n        try\\_files $uri $uri/ /app\\_dev.php?$query_string;\n    }\n    location ~ \\[^/\\]\\\\.php(/|$) {\n        fastcgi_pass unix:/var/run/php5-fpm.sock;\n        include fastcgi_params;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;因为我们不需要域名，所以把&lt;code&gt;server_name&lt;/code&gt;设成了&lt;code&gt;_&lt;/code&gt;（有点像perl的&lt;code&gt;$_&lt;/code&gt;占位符变量）， 并配置根目录（document root）为/svr/web， 我们会把应用程序部署在&lt;code&gt;/srv&lt;/code&gt;下，剩下的就是标准的Mginx + PHP5-FPM配置. 因为一个容器每次只能运行一个程序， 我们需要supervisord（或者任何别的进程管理器，不过我比较中意supervisord）。幸运的是， 这个进程管理器会产生我们需要的所有进程！下面是一小段supervisord的配置：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;\\[supervisord\\]\nnodaemon=true\n\\[program:nginx\\]\ncommand=/usr/sbin/nginx\n\\[program:php5-fpm\\]\ncommand=/usr/sbin/php5-fpm\n\\[program:mysql\\]\ncommand=/usr/bin/mysqld_safe\n\\[program:init\\]\ncommand=/init.sh\nautorestart=false\nredirect_stderr=true\nredirect_stdout=/srv/app/logs/init.log\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这里我们需要做的是定义所有的服务， 加上一个特殊的&lt;code&gt;program:init&lt;/code&gt;进程，它不是一个实际的服务，而是一个独创的运行启动脚本的方式。 这个启动脚本的问题在于，它通常需要先启动某些服务。比如，你可能要初始化一些数据库表，但前提是你得先把MySQL跑起来，一个可能的解决办法是，在启动脚本中启动MySQL，然后初始化表，然后为了防止影响到supervisord的进程管理，需要停掉MySQL，最后再启动supervisord。 这样的脚本看起来类似下面这样：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;/etc/init.d/mysql start\napp/console doctrine:schema:update --force\n/etc/init.d/mysql stop\nexec /usr/bin/supervisord\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;看起来丑爆了有木有，咱换种方式，让supervisor来运行它并且永不重启。 实际的&lt;code&gt;init.sh&lt;/code&gt;脚本如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;#!/bin/bash\nRET=1\nwhile \\[\\[ RET -ne 0 \\]\\]; do\n    sleep 1;\n    mysql -e &#39;exit&#39; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; RET=$?\ndone\nDB\\_NAME=${DB\\_NAME:-symfony}\nmysqladmin -u root create $DB_NAME\nif \\[ -n &amp;quot;$INIT&amp;quot; \\]; then\n    /srv/$INIT\nfi\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;脚本先等待MySQL启动，然后根据环境变量&lt;code&gt;DB_NAME&lt;/code&gt;创建DB，默认为&lt;code&gt;symfony&lt;/code&gt;， 然后在INIT环境变量中查找要运行的脚本，并尝试运行它。本文的结尾有说明如何使用这些环境变量。&lt;/p&gt;\n&lt;h2 id=\&#34;构建并运行镜像\&#34;&gt;构建并运行镜像&lt;/h2&gt;\n&lt;p&gt;万事俱备只欠东风。我们还要构建Symfony Docker镜像， 使用&lt;code&gt;docker build&lt;/code&gt;命令:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;$ cd docker-symfony\n$ docker build -t symfony .\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;现在，可以使用它来运行你的Symfony工程了:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;$ cd SomeProject\n$ docker run -i -t -P -v $PWD:/srv symfony\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们来看看这一连串的选项分别是干嘛的:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;*   `-i` 启动_交互_（interactive）模式， 也就是说，`STDIO`（标准输入输出）连接到了你当前的终端上。当你要接收日志或者给进程发送信号时，它很有用。\n*   `-t` 为容器创建一个虚拟`TTY`， 它跟`-i`是好基友，通常一起使用。\n*   `-P` 告诉Docker守护进程发布所有指定的端口， 本例中为80端口。\n*   `-v $PWD:/srv` 把当前目录挂载到容器的/srv目录。挂载一个目录使得目录内容对目标挂载点可用。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;现在你还记得之前提到的&lt;code&gt;DB_NAME&lt;/code&gt;和&lt;code&gt;INIT&lt;/code&gt;环境变量了吧，干嘛用的呢：用于自定义你的环境。 基本上你可以通过 &lt;code&gt;docker run&lt;/code&gt;的&lt;code&gt;-e&lt;/code&gt;选项在容器中设置环境变量，启动脚本会拿到环境变量，因此，如果你的DB名为&lt;code&gt;some_project_dev&lt;/code&gt;， 你就可以这么运行容器：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;$ docker run -i -t -P -v $PWD:/srv -e DB\\_NAME=some\\_project_dev symfony\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;INIT&lt;/code&gt; 环境变量就更强大了，它允许你启动时运行指定的脚本。比如， 你有一个&lt;code&gt;bin/setup&lt;/code&gt;脚本运行&lt;code&gt;composer install&lt;/code&gt;命令并且设置数据库schema:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;#!/bin/bash\ncomposer install\napp/console doctrine:schema:update --force\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;用&lt;code&gt;-e&lt;/code&gt;来运行它：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$ docker run -i -t -P \\\n    -v $PWD:/srv \\\n    -e DB\\_NAME=some\\_project_dev \\\n    -e INIT=bin/setup\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注意，&lt;code&gt;-e&lt;/code&gt;选项可以在&lt;code&gt;docer run&lt;/code&gt;中多次使用，看起来相当酷。另外，你的启动脚本需要可执行权限（&lt;code&gt;chmod +x&lt;/code&gt;）。 现在我们通过&lt;code&gt;curl&lt;/code&gt;发送请求到容器，来检查一下是否所有的东西都像预期一样工作。首先，我们需要取到Docker映射到容器的80端口的公共端口，用&lt;code&gt;docker port&lt;/code&gt;命令:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$ docker port $(docker ps -aql 1) 80\n0.0.0.0:49153\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;docker ps -aql 1&lt;/code&gt; 是个好用的命令，可以方便的检索到最后一个容器的id， 在我们的例子中，Docker 把容器的80端口映射到了49153端口。我们 curl 一下看看。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$ curl http://localhost:49153\nYou are not allowed to access this file. Check app_dev.php for more information.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当我们不从localhost（译者注：容器的localhost）访问dev controller时，得到了Symfony的默认错误消息，这再正常不过了， 因为我们不是从容器内部发送 curl 请求的， 所以，可以安全的从前端控制器&lt;code&gt;web/app_dev.php&lt;/code&gt;中移除这些行。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-php\&#34;&gt;// This check prevents access to debug front controllers that are deployed by accident to production servers.\n// Feel free to remove this， extend it， or make something more sophisticated.\nif (isset($\\_SERVER\\[&#39;HTTP\\_CLIENT_IP&#39;\\])\n    || isset($\\_SERVER\\[&#39;HTTP\\_X\\_FORWARDED\\_FOR&#39;\\])\n    || !(in\\_array(@$\\_SERVER\\[&#39;REMOTE\\_ADDR&#39;\\]， array(&#39;127.0.0.1&#39;， &#39;fe80::1&#39;， &#39;::1&#39;)) || php\\_sapi_name() === &#39;cli-server&#39;)\n) {\n    header(&#39;HTTP/1.0 403 Forbidden&#39;);\n    exit(&#39;You are not allowed to access this file. Check &#39;.basename(\\_\\_FILE\\_\\_).&#39; for more information.&#39;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这些行阻止了任何从localhost以外的地方访问dev controller。 现在再curl的时候就可以正常工作了，或者用浏览器访问 http://localhost:49153/：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;a href=\&#34;http://www.php100.com/uploadfile/2015/0105/20150105102412393.png\&#34;&gt;&lt;img src=\&#34;http://www.php100.com/uploadfile/2015/0105/20150105102412393.png\&#34; alt=\&#34;result.png\&#34; title=\&#34;result.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/a&gt;&lt;/figure&gt;\n&lt;p&gt;很容易吧！ 现在我们可以快速的启动、更新环境了，但还是有很多地方需要改进。 （原文链接：&lt;a href=\&#34;http://geoffrey.io/a-php-development-environment-with-docker.html\&#34;&gt;A PHP development environment with Docker&lt;/a&gt;）&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;guan-yu-ru-he-shi-yong-docker-gou-jian-php-de-kai-fa-huan-jing&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;使用Docker 构建PHP运行开发环境 （碳素云实习期间实践）&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;关于如何使用Docker构建PHP的开发环境&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2015-12-30 20:15:27&#34;,&#34;dateFormat&#34;:&#34;2015-12-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://stardemo.github.io/post/guan-yu-ru-he-shi-yong-docker-gou-jian-php-de-kai-fa-huan-jing/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;12 min read&#34;,&#34;time&#34;:686000,&#34;words&#34;:2818,&#34;minutes&#34;:12},&#34;description&#34;:&#34;使用Docker 构建PHP运行开发环境 （碳素云实习期间实践）\n\n本文作者是Geoffrey，他是一个PHP的Web开发者，喜欢DevOps和Docker。本文主要介绍了如何使用Docker构建PHP的开发环境，文中作者也探讨了构建基于D...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%8D%E8%B4%A3%E5%A3%B0%E6%98%8E\&#34;&gt;免责声明&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%8E%E6%A0%B7%E6%89%8D%E7%AE%97%E6%98%AF%E5%A5%BD%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83\&#34;&gt;怎样才算是好的开发环境&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AFphp%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83\&#34;&gt;什么是PHP开发环境&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#pet-%E4%B8%8E-cattle\&#34;&gt;Pet 与 Cattle&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B\&#34;&gt;初始化工程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%B9%E5%99%A8\&#34;&gt;容器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8C%E9%95%9C%E5%83%8F\&#34;&gt;构建并运行镜像&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->

<script src="/media/js/mouse/love.js"></script>


</html>